<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap底层实现原理</title>
    <url>/2020/07/28/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>记录HashMap底层实现原理。(基于JDK 1.8)</p>
<a id="more"></a>
<h3 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h3><p>HashMap是基于哈希表的Map接口的非同步实现，其键值都允许<code>null</code>值。此类并不保证映射的顺序。<br>由于HashMap的<strong>非同步性</strong>，如果多线程同时访问HashMap，外部进行修改等操作必须保证同步。</p>
<hr>
<h3 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h3><p>HashMap是基于<strong>数据+链表</strong>的一种数据结构。HashMap底层就是一个数据，而数据中的每一项又是一个链表。<br>当进行<code>put</code>操作时，通过内部定义的算法找到数组的下标，直接将数据放到此位置。若是遇到了<strong>Hash冲突</strong>，将会对这个数组元素的链表进行遍历，将新数据放到链表末尾。</p>
<hr>
<p>###存储数据的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>Node</code>相当于数组中的元素，每一个元素相当于一个键值对，而它持有指向下一个元素的<code>next</code>指针，这就构成了链表。<br>hash：通过<strong>hash算法</strong>算出来的值。hash算法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>hashCode()</code>函数是Key自带的方法，返回一个int类型的散列值。<br>而元素的下标是通过<code>h &amp; (length - 1)</code>得到的，这也解释了为什么HashMap数组的长度永远是2的整数幂。<br>首先，当长度为2的整数幂时，<code>h &amp; (length - 1)</code>相当于hash函数的值对数组的长度取模，实现均匀分布。而<code>&amp;</code>比<code>%</code>效率更高。<br>其次，长度为2的整数幂时，可以使下标的分布更加松散。举个例子，当长度为初始值16时，<code>length - 1</code>最低位为1，在与hash函数的值<code>&amp;</code>时，最低位可以是0或1。反之最低位为0，<code>&amp;</code>后最低位则一定为0。这将导致有许多位置永远不可能存放元素，浪费了空间也增加了碰撞概率。<br>但即使是这样，如果数组长度较小，<code>&amp;</code>后也只与最低几位相关，碰撞的几率仍然很大，这时hash函数就体现了作用。将hash函数值右移16位再与自己异或，增加了低位的随机性，也变相保留了高位的信息。</p>
<hr>
<h3 id="HashMap性能参数"><a href="#HashMap性能参数" class="headerlink" title="HashMap性能参数"></a>HashMap性能参数</h3><p>HashMap有几个重要的参量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="keyword">int</span> modCount;  </span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<ol>
<li>threshold: 数组允许的最大存储数量，由<code>数组长度 * loadFactor</code>得到。超过时数组会进行扩容。</li>
<li>loadFactor: 增长因子。默认为<code>0.75</code>。太大会增加碰撞几率，太小则会浪费空间。</li>
<li>modCount: 记录内部结构发生变化的次数。put(覆盖不算)以及其他…</li>
<li>size: 实际存储的元素个数。</li>
</ol>
<hr>
<h3 id="put以及resize流程"><a href="#put以及resize流程" class="headerlink" title="put以及resize流程"></a>put以及resize流程</h3><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>![](HashMap put流程.png)<br>这里有两个参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>JDK 1.8对HashMap进行了优化，如果碰撞的次数大于8次，此时数组的长度如果小于64，会进行扩容；否则数组元素上的链表会转变为红黑树，提高查询的效率。而碰撞次数减少到6次时，红黑树将会重新变为链表。</p>
<h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p>当需要存储的元素大于<code>threshold</code>时，数组会进行扩容，扩大为原来的两倍，此时数组中的元素需要重新计算下标。这里JDK 1.8进行了优化，不再需要重新计算hash值，而是，数组元素的链表中的第一个值的下标不发生变化，其它的通过<code>e.hash &amp; oldCap != 0</code>将其放到<code>[原始下标+原始数组长度]</code>的下标。<br>![](HashMap resize流程.png)</p>
<hr>
<h3 id="线程安全问题以及Fail-Fast机制"><a href="#线程安全问题以及Fail-Fast机制" class="headerlink" title="线程安全问题以及Fail-Fast机制"></a>线程安全问题以及Fail-Fast机制</h3><p>HashMap是非线程安全的，如果在访问元素的过程中修改了HashMap，将会抛出<code>ConcurrentModificationException</code>异常，也就是所谓的Fail-Fast机制。<br>此机制是通过<code>modCount</code>参量实现的。<code>modCount</code>在源码中声明为<code>volatile</code>，保证了线程之间的可见性。通过检测<code>modCount</code>是否与预期值相等，如果不等说明在访问的过程中修改了HashMap中的值，则会抛出异常。<br>然而此机制只能检测却不能解决线程安全问题。想要保证线程安全需要用到<code>ConcurrentHashMap</code>。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域与模型</title>
    <url>/2020/06/24/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<a id="more"></a>
<h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><p><img src="Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt=""><br>其中方法区、堆是所有线程共享的，其余则是线程私有的。</p>
<ol>
<li>程序计数器<br>程序计数器是一块较小的内存空间。JVM字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。<br>因为在任何时刻，一个处理器都只会执行一条线程的指令，并且通过不断地切换线程来实现多线程。所以对于每个独立的线程，为了在切换后能恢复到正确地执行位置，都需要一个程序计数器，各条线程互不影响，独立存储。因而它是<strong>线程私有</strong>的。</li>
<li>虚拟机栈<br>虚拟机栈也是<strong>线程私有</strong>的，其生命周期与线程相同。每个方法被执行时，Java虚拟机都会同步创建一个栈帧用来存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>本地方法栈<br>作用与虚拟机栈非常类似，区别只是虚拟机栈为Java方法服务，而本地方法栈是为本地(Native)方法服务。</li>
<li>堆(heap)<br>堆是虚拟机管理的内存中最大的一块。堆是<strong>所有线程共享</strong>的一块区域，在虚拟机启动时创建。堆唯一目的就是存放对象实例。Java几乎所有的对象实例和数组都在堆分配内存。然而随着即时编译器的优化，一些如逃逸分析的技术，使得对象实例也不一定都是分配在堆上了。<br>堆还是垃圾收集器管理的内存区域，因此也被称作<code>GC堆</code>。关于这部分内容后面会详细讲解。<br>Java堆可以被实现成固定大小的，也可以是可扩展的。不过当前主流虚拟机都是按可扩展来实现的，可通过设置相关参数来设定。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<code>OutOfMemoryError</code>异常。</li>
<li>方法区<br>方法区也是<strong>线程共享</strong>的区域。它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。<br>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。<br>同时，<strong>运行时常量池</strong>也是方法区的一部分，它主要用于存放编译期间生成的各种字面量与符号引用，当类加载后存放到运行时常量池。它有一个特点是运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</li>
</ol>
<hr>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="并发编程模型"><a href="#并发编程模型" class="headerlink" title="并发编程模型"></a>并发编程模型</h4><p>在并发编程中，我们需要解决两个关键问题：线程之间如何通信以及线程之间如何同步。<br>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>。<br>在共享内存的并发模型里，线程之间通过写-读内存中的公共状态来<strong>隐式</strong>进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的信息来显式进行通信。<br>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br><strong>Java的并发采用的是共享内存模型</strong>。Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h4 id="Java内存模型-1"><a href="#Java内存模型-1" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>Java线程之间的通信由Java内存模型(JMM)控制，JMM决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度看，JMM决定了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存存储了该线程以读/写共享变量的副本。<br>Java 内存模型的抽象示意图如下：<br><img src="Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt=""><br>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<h4 id="Java内存模型的实现"><a href="#Java内存模型的实现" class="headerlink" title="Java内存模型的实现"></a>Java内存模型的实现</h4><p><img src="Java%E5%A0%86%E6%A0%88.jpeg" alt=""><br>JVM中运行的每个线程都拥有自己的<strong>线程栈</strong>，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。线程栈是线程私有的。<br>所有的原始类型的局部变量都保存在线程栈中，每个线程都是独立的，一个线程可以通过传递副本给另一个线程，但它们之间无法共享。<br>堆区则包含了Java应用创建的所有对象信息。它是线程共享的。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量。<br>一个本地变量如果是原始类型，那么它会被完全存储到栈区。<br>一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。<br>对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。<br>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。<br>Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。<br><img src="Java%E5%A0%86%E6%A0%88%E5%AD%98%E5%82%A8.jpeg" alt=""></p>
<h4 id="硬件内存结构"><a href="#硬件内存结构" class="headerlink" title="硬件内存结构"></a>硬件内存结构</h4><p>现代计算机一般都有2个以上CPU，而且每个CPU还有可能包含多个核心。因此，如果我们的应用是多线程的话，这些线程可能会在各个CPU核心中并行运行。<br>在CPU内部有一组CPU寄存器，也就是CPU的储存器。CPU操作寄存器的速度要比操作计算机主存快的多。在主存和CPU寄存器之间还存在一个CPU缓存，CPU操作CPU缓存的速度快于主存但慢于CPU寄存器。某些CPU可能有多个缓存层（一级缓存和二级缓存）。计算机的主存也称作RAM，所有的CPU都能够访问主存，而且主存比上面提到的缓存和寄存器大很多。<br>当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存，进而在读取CPU缓存到寄存器。当CPU需要写数据到主存时，同样会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主存。<br>Java内存模型与硬件结构的关系如下图所示：<br><img src="Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB.jpeg" alt=""></p>
<hr>
<h3 id="volatile变量特性"><a href="#volatile变量特性" class="headerlink" title="volatile变量特性"></a>volatile变量特性</h3><h4 id="volatile变量的可见性"><a href="#volatile变量的可见性" class="headerlink" title="volatile变量的可见性"></a>volatile变量的可见性</h4><p>当一个变量被定义成volatile之后，它将具备两项特性：第一项是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。</p>
<h4 id="volatile变量禁止指令重排序"><a href="#volatile变量禁止指令重排序" class="headerlink" title="volatile变量禁止指令重排序"></a>volatile变量禁止指令重排序</h4><p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，但不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。而volatile变量可以通过<strong>内存屏障</strong>来保证特定操作的执行顺序。<br>由于编译器和处理器都能执行指令重排序优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本，也就实现了可见性。</p>
<hr>
<h3 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性指的是一个操作是不可中断的。由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。之前说到的<code>volatile</code>就可以保证可见性。除了<code>volatile</code>，<code>synchronized</code>和<code>final</code>也可以实现可见性。<br>同步块的可见性是由<strong>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）</strong>这条规则获得的。<br>而被<code>final</code>修饰的字段在构造器中一旦被初始化完成，并且构造器没有把”this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到<strong>初始化了一半</strong>的对象），那么在其他线程中就能看见final字段的值。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>Java语言提供了<code>volatile</code>和<code>synchronized</code>两个关键字来保证线程之间操作的有序性。<code>volatile</code>关键字本身就包含了禁止指令重排序的语义，而<code>synchronized</code>则是由<strong>一个变量在同一个时刻只允许一条线程对其进行lock操作</strong>这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
<hr>
<h3 id="先行发生-happens-before-原则"><a href="#先行发生-happens-before-原则" class="headerlink" title="先行发生(happens-before)原则"></a>先行发生(happens-before)原则</h3><p>happens-before原则是判断数据是否存在竞争，线程是否安全的非常有用的手段。其原则内容如下：</p>
<ol>
<li>程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是”同一个锁”，而”后面”是指时间上的先后。</li>
<li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。</li>
<li>线程启动规则：Thread对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li>
<li>线程中断规则：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测。</li>
<li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li>传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。</li>
</ol>
<hr>
<p>参见《深入理解Java虚拟机》。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Java单例模式</title>
    <url>/2020/06/22/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式：在程序运行期间，某些类<strong>有且最多只有一个</strong>实例对象。<br>本文记录几种不同的Java单例模式实现方案以及它们的优缺点。</p>
<a id="more"></a>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>饿汉模式，顾名思义，JVM在加载这个类的时候就会完成这个单例的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量在类创建的时候就会初始化，设置成final类型直接创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：线程安全，类加载只加载一次，即使是多线程也不会创建多个实例。<br>缺点：这种方法在用户调用<code>getInstance()</code>方法之前就已经完成了单例的创建。如果这个实例的创建需要依赖用户输入的参数或者配置文件，那么这种方法就不好使了。</p>
<hr>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>为了解决上面的问题，有了懒汉模式。顾名思义就是在等用户真正需要用到这个实例的时候才创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>优点：解决了懒汉模式的问题，也节省了空间，用户没调用这个类时不会创建实例。<br>缺点：线程不安全。当多个线程同时执行<code>getInstance()</code>方法时，会得到多个实例，违背了单例模式的要求。</p>
<p>于是需要将<code>getInstance()</code>方法内部代码设置同步代码块(synchronized)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>为什么要加双重锁呢？<br>因为多线程有可能同时执行到了<code>1</code>的位置，这时一个线程进入了同步代码块，创建完了实例，释放锁，于是又有一个线程进入了同步代码块，如果没有再次判断实例是否已经创建，此线程也会新创建一个实例，而这两个实例将不会是同一个实例。<br>只有在<code>synchronized</code>内部再次检查一次，才能保证单例。</li>
<li>为什么实例要设置为<code>volatile</code>？<br>看起来代码已经很完美，但其实<code>instance = new Singleton();</code>这句话在执行时并非一个原子操作。它其实做了下面3件事情。<blockquote>
<ol>
<li>给instance分配内存</li>
<li>调用SingleTon构造函数初始化成员变量</li>
<li>将instance引用指向分配的内存空间</li>
</ol>
</blockquote>
</li>
</ol>
<p>在JVM即时编译器中，存在着指令重排序的优化。也就是说，如果上述3个步骤可能的执行顺序是1-&gt;3-&gt;2。对于这种情况，如果一个线程执行到了这句话的1和3两个指令，由于<code>instance</code>已经被分配了内存，此时已不再是<code>null</code>了。这时如果有另一个线程执行到了<code>2</code>的位置，将会直接判定<code>instance</code>不为空，将其返回使用。然而这个<code>instance</code>还没有初始化呢，所以会造成错误。<br>而<code>volatile</code>可以防止指令重排序。它在变量的赋值操作后会设置一个<strong>内存屏障</strong>，读取操作只能等到上述3个指令执行完毕。也就是<strong>happens-before</strong>原则。</p>
<p>优点：线程安全，懒汉式加载。<br>缺点：代码较复杂。</p>
<hr>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当JVM在加载类的时候，是不会加载其内部类的。这点在《深入理解Java虚拟机》中有详细讲述。只有当这个类的某个静态变量被调用时才会触发类的初始化。<br>也就是执行了<code>getInstance()</code>方法时才会初始化<code>SingletonHolder</code>类。<br>由于JVM本身的机制已经保证了线程安全的问题，所以这是一个线程安全的、懒汉式加载的方法，且实现简单。</p>
<hr>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用枚举实现实在太简单了，且枚举默认就是线程安全的。而且，其余几种方式其实都存在缺点：如果通过反射或者反序列化攻击，还是会生成多个实例。<br>利用枚举的特性，就可以完全规避这些问题。它是单例模式实现中的<strong>唯一</strong>一种不会被破坏的实现。</p>
<hr>
<h3 id="防止单例模式被破坏的方法"><a href="#防止单例模式被破坏的方法" class="headerlink" title="防止单例模式被破坏的方法"></a>防止单例模式被破坏的方法</h3><ol>
<li>反射破坏的方式是通过强行调用私有的构造方法生成新的对象，所以只要在构造方法里面判断一下就好了。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"实例已经存在，请通过getInstance()方法获取。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果单例模式实现了序列化接口，那么就可以通过反序列化进行破坏。所以可以不实现序列化接口，或者重写反序列化方法<code>readResolve()</code>，直接返回单例对象。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>…</p>
]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>Java单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收机制</title>
    <url>/2020/07/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>垃圾回收是JVM非常重要的机制之一。本文记录一下。</p>
<a id="more"></a>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是在JVM启动时创建的，运行过程中创建的对象和数组几乎都储存在这块区域。而Java的垃圾回收也主要针对这块区域。如果我们动态创建的对象没有得到及时回收，最后可能导致内存溢出。<br>因此垃圾回收机制会在后台创建一个守护进程，在内存紧张时会自动对垃圾进行回收，以保证程序正常的运行。</p>
<hr>
<h3 id="对象已死"><a href="#对象已死" class="headerlink" title="对象已死"></a>对象已死</h3><p>垃圾回收器在对堆进行回收时，第一件事就是确定哪些对象还”存活”着，哪些已经”死去”（”死去”意味着不能再用任何方式使用该对象）。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。<br>但是，这种方案存在严重的漏洞，就是无法检测对象的互相引用。当两个对象相互引用，即使它俩都不再被其他任何东西引用，它们的计数也不为零，所以JVM不会回收它们。但实际上，这两个对象已经没有用处了。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>当前主流的程序语言的无存管理子系统，都是通过可达性分析算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为<code>GC Roots</code>的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为<strong>引用链</strong>，如果某个对象到<code>GC Roots</code>间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。<br>例如下图：<br><img src="%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt=""><br>首先，GC Roots一定是可达的，其次，固定可作为GC Roots的对象包括以下几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些异常对象（如OutOfMemoryError）等，还有系统类加载器。</li>
<li>被同步锁持有的对象</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
<hr>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>JDK 1.2后，Java将引用分为<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>和<strong>虚引用</strong>。</p>
<ol>
<li>强引用<br>强引用是传统的引用的定义，指程序代码中普遍存在的引用赋值，类似<code>Object obj = new Object()</code>这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用<br>软引用用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了<code>SoftReference</code>类来实现软引用。</li>
<li>弱引用<br>弱引用的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了<code>WeakReference</code>类来实现弱引用。</li>
<li>虚引用<br>虚引用也被称为”幽灵引用”，它是最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了<code>PhantomReference</code>类来实现虚引用。</li>
</ol>
<hr>
<h3 id="生存or死亡"><a href="#生存or死亡" class="headerlink" title="生存or死亡"></a>生存or死亡</h3><p>即使在可达性分析算法中被判定为不可达的对象，也并非”非死不可”的。要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。假如对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为”没有必要执行”。<br>如果对象被判定为有必要执行<code>finalize()</code>方法，它将被放置在名为<code>F-Queue</code>的队列中，虚拟机会创建一个低调度优先级的线程去执行。这里的执行是指虚拟机会触发<code>finalize()</code>方法的执行，但不会承诺一定会等待它运行结束。原因是如果某个对象的<code>finalize()</code>方法执行缓慢或者陷入死循环，那么队列中的其他对象将一直处于等待，可能导致系统的崩溃。<br><code>finalize()</code>方法是对象最后一次”拯救”自己的机会，收集器将对队列中的对象进行第二次小规模的标记，这时只要<strong>将对象与任何一个引用链上的对象建立关联</strong>即可不被回收，否则就真的要被回收了。<br>此时如果再执行一次上述过程，对象将无法再一次”拯救”自己，这是因为任何一个对象的<code>finalize()</code>方法都只会被系统自动调用一次。</p>
<hr>
<h3 id="方法回收区"><a href="#方法回收区" class="headerlink" title="方法回收区"></a>方法回收区</h3><p>方法区的垃圾收集主要回收<strong>废弃的常量</strong>和<strong>不再使用的类型</strong>。<br>回收废弃常量与回收Java堆中的对象非常类似。如果没有任何字符串对象引用常量池中的常量，且虚拟机中也没有其他地方引用这个字面量，此时如果发生内存回收，就会将这个常量清出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。<br>而判断一个类型是否属于不再被使用的类则需要满足三个条件：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<hr>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>分代收集理论建立在两个分代假说之上：</p>
<blockquote>
<p>弱分代假说：绝大多数对象都是朝生夕灭的。<br>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
</blockquote>
<p>显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。<br>因而Java堆会被分为<strong>新生代</strong>和<strong>老年代</strong>两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。<br>然而这种分代收集存在一个明显的困难：对象不是孤立的，<strong>对象之间会存在跨代引用</strong>。<br>比如现在进行一次局限于新生代区域内的收集。但其中的对象完全有可能被老年代所引用，这时就不得不再遍历老年代中所有对象来确保其可达性，反过来也一样。虽然这样可行，但会带来很大的性能负担。因此分代收集理论需要第三条法则：</p>
<blockquote>
<p>跨代引用假说：跨代引用相对于同代引用来说只占极少数。</p>
</blockquote>
<p>存在互相引用关系的两个对象，应该倾向于同时生存或同时消亡的。比如，某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。<br>因此我们不再为了少量的跨代引用扫描整个老年代，而是在新生代上建立一个<strong>记忆集</strong>，把老年代分为若干小块，标识出老年代哪块存在跨代引用。此后发生新生代收集时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>此算法首先标记出所有需要回收的对象，完成后统一回收掉所有被标记的对象。<br>这个算法有两个缺点：一是<strong>执行效率不稳定</strong>，如果堆中有大量需要回收的对象，那就需要进行大量的标记和清除的动作，执行效率会降低；二是内存空间的碎片化，<strong>标记清除后会产生大量不连续的内存碎片</strong>，这可能导致以后分配较大对象时找不到足够的连续内存而不得不触发另一次垃圾收集动作。<br><img src="%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt=""></p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>这种算法将可用内存分为容量相等的两块，每次只使用一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。<br>现在的商用Java虚拟机大多优先采用这种算法回收新生代。由于新生代中约98%的对象熬不过第一轮收集，因此不需要按照1:1的比例来划分空间。<br>常见的做法是分为<code>8:1:1</code>这样一块较大的Eden空间和两块较小的Survivor空间。工作原理如下：</p>
<ol>
<li><code>Eden</code>区最大，对外提供内存。当<code>Eden</code>区快满时，进行收集，把存活的对象存入<code>Survivor A</code>区，清空<code>Eden</code>区，继续对外提供内存。</li>
<li><code>Eden</code>区再次快满时，对<code>Eden</code>和<code>Survivor A</code>区同时回收，把存活对象存入<code>Survivor B</code>区，清空<code>Eden</code>和<code>Survivor A</code>区，<code>Eden</code>继续对外提供内存，重复上述过程。</li>
<li>当某个<code>Survivor</code>区被填满时仍有对象未被复制完毕时，就把这部分对象放入老年区。</li>
<li>当老年区也被填满时，则开始对老年区进行回收。</li>
</ol>
<p>可以看到这种算法适用于新生代的收集。<br><img src="%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt=""></p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。这样就没有碎片了。<br>这种算法适用于老年代的收集：只需清理少量的垃圾，剩下的进行移动就可以了。<br><img src="%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt=""></p>
<hr>
<p>参见《深入理解Java虚拟机》。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识点</title>
    <url>/2020/08/06/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>记录一些遇到过的Java基础知识点。（持续更新）</p>
<a id="more"></a>
<h3 id="Java基本数据类型图"><a href="#Java基本数据类型图" class="headerlink" title="Java基本数据类型图"></a>Java基本数据类型图</h3><p><img src="Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpeg" alt=""></p>
<hr>
<h3 id="a-a-b-与-a-b"><a href="#a-a-b-与-a-b" class="headerlink" title="a = a + b 与 a += b"></a>a = a + b 与 a += b</h3><p>举例：<code>short a = 1; a = a + 1;</code>因为 1 为整型，<code>a + 1</code>也为整形，所以需要强制转换成<code>short</code>类型才能赋值。<br>而<code>short a = 1; a += 1;</code>则不需要强制转换，因为<code>+=</code>含有隐式的类型转换，可以自动转型为<code>short</code>。</p>
<hr>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol>
<li><strong>private</strong>: 当前类可见。不能修饰类</li>
<li><strong>default(缺省)</strong>: 同包可见。</li>
<li><strong>protected</strong>: 同包内的类以及所有子类可见。不能修饰类。</li>
<li><strong>public</strong>: 所有类可见。<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><img src="%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6.jpeg" alt=""></li>
</ol>
<hr>
<h3 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h3><blockquote>
<p>被final修饰的类不可以被继承<br>被final修饰的方法不可以被重写<br>被final修饰的变量不可以被改变。被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的。</p>
</blockquote>
<hr>
<h3 id="普通类与抽象类"><a href="#普通类与抽象类" class="headerlink" title="普通类与抽象类"></a>普通类与抽象类</h3><ol>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ol>
<hr>
<h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<ol>
<li><strong>重载</strong>：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），<strong>与方法返回值和访问修饰符无关</strong>，即重载的方法不能根据返回类型进行区分。</li>
<li><strong>重写</strong>：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</li>
</ol>
<hr>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ol>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ol>
<p>总的来说，Java IO流是从以下四个抽象类中派生出来的。</p>
<ol>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ol>
<hr>
<h3 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="BIO、NIO、AIO"></a>BIO、NIO、AIO</h3><ol>
<li>BIO: 同步阻塞模式。线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。</li>
<li>NIO: 同步非阻塞的IO模型。线程发起IO请求后，立即返回（非阻塞IO）。同步指的是必须等待IO缓冲区内的数据就绪，而非阻塞指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区数据是否就绪。</li>
<li>AIO: 异步非阻塞IO模型。基于事件和回调机制而实现，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ol>
<hr>
<h3 id="String-str-“i”-与-String-str-new-String-“i”"><a href="#String-str-“i”-与-String-str-new-String-“i”" class="headerlink" title="String str = “i” 与 String str = new String(“i”)"></a>String str = “i” 与 String str = new String(“i”)</h3><p>内存分配的方式不同。<code>String str = &quot;i&quot;</code>JVM会将其分配到常量池；另一种会分配到堆内存中。</p>
<hr>
<h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="number">3</span>;  <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">System.out.println(a == c); <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">System.out.println(b == c); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer a1 = <span class="number">128</span>;</span><br><span class="line">Integer b1 = <span class="number">128</span>;</span><br><span class="line">System.out.println(a1 == b1); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Integer a2 = <span class="number">127</span>;</span><br><span class="line">Integer b2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(a2 == b2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果整型字面量的值在<code>-128</code>到<code>127</code>之间，那么自动装箱时不会创建新的Integer对象，而是直接引用常量池中的Integer对象；超过范围时会创建新对象，因此<code>a2 == b2</code>返回<code>false</code>。</p>
<hr>
<h3 id="strictfp关键字"><a href="#strictfp关键字" class="headerlink" title="strictfp关键字"></a>strictfp关键字</h3><p><code>strictfp</code>可以用来修饰类、接口和方法。在所声明的范围内，所有浮点数的计算都是精确的。当一个类被<code>strictfp</code>修饰时，所有方法默认也被<code>strictfp</code>修饰。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载器</title>
    <url>/2020/06/22/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<p>Java类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p>
<a id="more"></a>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>Java类加载器就是在类加载这个阶段通过类的全限定名获取定义此类的二进制字节流。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。<br>也就是说，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<hr>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>自从JDK1.2以来，Java一直保持着<strong>三层类加载器</strong>、<strong>双亲委派的类加载结构</strong>。<br>绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载。</p>
<ol>
<li>启动类加载器。这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</li>
<li>扩展类加载器。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li>
<li>应用程序类加载器。它负责加载用户类路径（ClassPath）上所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
<p>这三层类加载器的协作关系通常如下图所示，一般被称为<strong>双亲委派模型</strong>。<br><img src="%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt=""><br>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。<br>其工作原理是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。<br>这种工作机制的好处是：可以提高系统的安全性。例如Object类始终是由最上层加载器加载的，如果用户自定义了一个Object类，是不会被最顶层的启动类加载器加载运行的。这也防止了恶意代码对系统的破坏。</p>
<hr>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>然而，双亲委派模型并不是一种具有强制约束性的模型。这意味着它是可以被”破坏”的。<br>那么为什么要破坏双亲委派模型呢？例如JDBC，原生的JDBC中Driver驱动只是一个接口，具体的实现是由不同的数据库进行实现的，比如mysql有自己的实现，oracle也有自己的实现。这时就需要Driver动态的去加载不同数据库的实现，然而由于Driver是由启动类加载器加载的，它并不能加载到用户具体的实现，所以这时就需要打破双亲委派模型，由父类加载器去请求子类加载器完成类加载。<br>此时引入了<strong>线程上下文类加载器</strong>，把原本需要由启动类加载器加载的类，委派给了应用程序类加载器进行加载。</p>
<p>如果用户想要自定义类加载器，有两种方法。</p>
<ol>
<li>重写ClassLoader中的loadClass()方法，不过这将破坏双亲委派的模型。</li>
<li>重写findClass()方法。这个方法不会破坏双亲委派模型。这也是Java预留给开发者的方法。</li>
</ol>
<hr>
<p>参见《深入理解 java 虚拟机》。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>/2020/06/20/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行<strong>校验、转换解析和初始化</strong>，最<br>终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
<a id="more"></a>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。<br>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有:<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_n_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。<br>例如以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行后，只会输出”SuperClass init!”，而不会输出”SubClass init!”。<br>因为对于静态字段，只有直接定义这个字段的类才会被初始化。所以对于上述代码子类不会被初始化。</p>
<p>再如，对上述<code>SuperClass</code>类，如果有以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后依然没有输出”SuperClass init!”。说明通过数组定义来引用类，不会触发类的初始化。</p>
<p>还有一种是调用类的常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量在编译阶段会存入调用类的<strong>常量池</strong>中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。<br>而接口的加载过程与类加载过程稍有不同。接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器，用于初始化接口中所定义的成员变量。<br>一个接口在初始化时，并不要求父接口都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>
<hr>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><ol>
<li><strong>加载</strong><br>在加载阶段，Java虚拟机需要完成以下三件事情：<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
</li>
<li><strong>验证</strong><br>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。<br>验证阶段大致上会完成下面四个阶段的检验动作：<strong>文件格式验证、元数据验证、字节码验证和符号引用验证。</strong><ul>
<li>文件格式验证。主要验证字节流是否符合Class文件格式的规范。比如魔数开头、版本号、常量类型等等问题。</li>
<li>元数据验证。对字节码描述的信息进行语义分析。比如一个类是否有父类、是不是抽象类等等。</li>
<li>字节码验证。主要通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。比如保证类中的方法体在运行时不会危害虚拟机。</li>
<li>符号引用验证。发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</li>
</ul>
</li>
<li><strong>准备</strong><br>准备阶段是正式为类中定义的变量（即<strong>静态变量</strong>，被static修饰的变量）分配内存并设置类变量初始值的阶段。<br>也就是说，<strong>实例变量</strong>在这个阶段是不会被初始化的。例如：<blockquote>
<p>public static int value = 123;<br>public int value = 123;</p>
</blockquote>
</li>
</ol>
<p>对于以上两行代码，只有第一行会执行并初始化值为0。赋值为123要等到类的初始化阶段才会执行。<br>然而也有特殊情况，比如，如果上述<code>value</code>字段被<code>final</code>修饰，那么在这一阶段将会被直接赋值为123。<br>4. <strong>解析</strong><br>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。JVM针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类引用进行解析。<br>5. <strong>初始化</strong><br>到了这个阶段，Java虚拟机才真正开始执行类中编写的Java代码。在这个阶段，JVM会对类进行初始化。具体场景在前面<strong>类加载的时机</strong>已经描述。<br>6. <strong>使用</strong><br>JVM完成初始化后，便从入口方法开始执行代码。<br>7. <strong>卸载</strong><br>执行完程序代码后，JVM开始销毁创建的Class对象，最后JVM也退出内存。</p>
<hr>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandPa</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"grandpa代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"grandpa静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrandPa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"grandpa构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandPa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"father静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"father代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"son静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，输出是</p>
<blockquote>
<p>grandpa静态代码块<br>  father静态代码块<br>  30</p>
</blockquote>
<p>首先程序找到main方法，程序输出Son类的age类变量，但是由于Son类并没有直接定义这个变量，于是往父类找，触发了Father类初始化。<br>接着根据<strong>类加载的时机</strong>第3条<strong>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</strong>所以又会触发GrandPa类的初始化。<br>最后再输出Father类中age的值30。</p>
<p>再看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Test静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Test代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test构造器"</span>);</span><br><span class="line">        System.out.println(<span class="string">"age: "</span> + age + <span class="string">" weight: "</span> + weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> weight = <span class="number">120</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码输出是</p>
<blockquote>
<p>Test代码块<br>  Test构造器<br>  age: 20 weight: 0<br>  Test静态代码块<br>  Test静态方法</p>
</blockquote>
<p>之前那个例子，main方法所在的类没有多余的代码，所以忽略了类的初始化。这个例子就不同了。<br>首先在准备阶段，会为类变量分配内存，初始化值。<code>test</code>实例变量被初始化为null，<code>weight</code>类变量初始化为0。<br>接着进入初始化阶段，首先初始化类构造器，也就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Test静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> weight = <span class="number">120</span>;</span><br></pre></td></tr></table></figure>
<p>首先执行第一句，触发了类的实例化。于是执行对象构造器，也就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"Test代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Test构造器"</span>);</span><br><span class="line">    System.out.println(<span class="string">"age: "</span> + age + <span class="string">" weight: "</span> + weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>对于以上代码，JVM先初始化代码块，然后初始化变量，最后是构造器。所以先打印了<code>Test代码块</code>，为<code>age</code>赋值20，然后打印<code>Test构造器</code>。<br>接着，打印<code>age: 20 weight: 0</code>，因为<code>age</code>已被赋值，但是<code>weight</code>目前只在准备阶段被赋了0。<br>执行完对象构造器，接着执行类构造器第二句，打印<code>Test静态代码块</code>，然后初始化<code>weight</code>为120。<br>此时已完成类的初始化，开始执行main方法，执行run方法输出<code>Test静态方法</code>。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java中的静态变量和静态代码块在类加载的时候就会执行，执行顺序与代码书写顺序一致。然后执行对象构造器，构造函数最后执行，其余按书写顺序。如果子类继承了父类，则会先进行父类的初始化。</p>
<hr>
<p>参见《深入理解 java 虚拟机》。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程安全与锁</title>
    <url>/2020/06/25/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81/</url>
    <content><![CDATA[<p>本文记录Java线程安全有关问题以及Java的各种锁。</p>
<a id="more"></a>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>Java线程安全可按照安全程度排序，主要可分为5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<ol>
<li>不可变<br>JDK 5以后，不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。只要一个不可变的对象被正确地构建出来（即没有发生this引用逃逸的情况），那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态。”不可变”带来的安全性是最直接、最纯粹的。<br>如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用<code>final</code>关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。例如Java的<code>Integer</code>类，其内部状态变量value就是定义为<code>final</code>来保障状态不变。</li>
<li>绝对线程安全<br>绝对线程安全的定义其实是非常严格的，要求<strong>不管运行时环境如何，调用者都不需要任何额外的同步措施</strong>。其实在Java API中标注自己是线程安全的类，大多数都不是绝对线程安全的，依然需要额外加同步措施。</li>
<li>相对线程安全<br>相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</li>
<li>线程兼容<br>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。Java类库API中大部分的类都是线程兼容的。</li>
<li>线程对立<br>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。由于Java语言天生就支持多线程的特性，线程对立这种排斥多线程的代码是很少出现的。</li>
</ol>
<hr>
<h3 id="线程安全的实现"><a href="#线程安全的实现" class="headerlink" title="线程安全的实现"></a>线程安全的实现</h3><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段。因此在“互斥同步”这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的。<br>Java中，最简单的互斥同步手段就是使用<code>synchronized</code>关键字。它对于一条线程来说是<strong>可重入的</strong>，且被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。<br>但<code>synchronized</code>有局限性，它是一个重量级操作，在主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。</p>
<p>所以自JDK 5起，Java类库中新提供了<code>java.util.concurrent</code>包，其中的<code>Lock</code>接口成了一种全新的互斥同步手段。<br><strong>重入锁</strong>（ReentrantLock）是<code>Lock</code>接口的一种常见实现，它也是<strong>可重入的</strong>，对比<code>synchronized</code>它增加了以下几种功能：</p>
<ol>
<li>等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li>公平锁：是指多个线程在等待同一个锁时，必须按照<strong>申请锁的时间顺序</strong>来依次获得锁。不过一旦使用了公平锁，将会导致<code>ReentrantLock</code>的性能急剧下降，会明显影响吞吐量。</li>
<li>绑定多个条件：是指一个<code>ReentrantLock</code>对象可以同时绑定多个Condition对象。在<code>synchronized</code>中，锁对象的<code>wait()</code>跟它的<code>notify()</code>或者<code>notifyAll()</code>方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而<code>ReentrantLock</code>则无须这样做，多次调用<code>newCondition()</code>方法即可。</li>
</ol>
<p><code>Lock</code>需要确保在<code>finally</code>块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。而使用<code>synchronized</code>则可以由JVM来确保即使出现异常，锁也能自动释放。<br>在JDK 5时代，<code>Lock</code>在性能上优于<code>synchronized</code>，然而由于后续Java团队的优化，现在两者在性能上基本持平，所以性能已不是选择的决定因素。</p>
<h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p>互斥同步由于线程的阻塞和唤醒带来的性能开销，被称为<strong>阻塞同步</strong>。互斥同步属于<strong>悲观</strong>的并发策略，也就是悲观地认为只要不加同步措施，就一定会出现问题，无论共享的数据是否真的会出现竞争，都进行加锁。<br>相应的，还有一种选择则是基于冲突检测的<strong>乐观</strong>并发策略。也就是说，不管风险先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。这种同步操作被称为<strong>非阻塞同步</strong>。<br>对于非阻塞同步，一个重要的指令就是<strong>CAS</strong>指令。它需要进行3个操作，分别是<strong>内存位置</strong>（在Java中可以简单地理解为变量的内存地址，用V表示）、<strong>旧的预期值</strong>（用A表示）和<strong>准备设置的新值</strong>（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。<br>java中有一个<code>AtomicInteger</code>类，用它代替int后，即可实现CAS操作避免阻塞同步。其中的<code>incrementAndGet()</code>方法在一个无限循环中，不断尝试将一个比当前值大一的新值赋值给自己。如果失败了，那说明在执行CAS操作的时候，旧值已经发生改变，于是再次循环进行下一次操作，直到设置成功为止。<br>CAS看起来很美好，但其实有一个逻辑漏洞：例如一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，CAS会认为它没有被改变过，但其实这个变量的值有可能在过程中被改成了B，又改回为A。这个漏洞成为CAS操作的<strong>ABA问题</strong>。为了解决这个问题，有一个带有标记的原子引用类<code>AtomicStampedReference</code>，它可以通过控制变量值的版本来保证CAS的正确性。不过由于ABA问题并不会影响程序并发的正确性，所以问题不大。</p>
<h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><p>如果一个方法不涉及共享数据，那自然就不需要加任何同步措施。<br>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。<br>Java中，如果一个变量只要被某个线程独享，我们可通过<code>java.lang.ThreadLocal</code>类来实现线程本地存储的功能。</p>
<blockquote>
<p>每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</p>
</blockquote>
<hr>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h4><p>自旋锁在JDK 1.4.2就已经引入，直到JDK 6才默认开启。它可以使线程一直处于<strong>RUNNABLE</strong>状态，循环检测锁标志位，避免了线程切换的开销。但它会一直占用CPU资源却什么也不做，如果锁被其他线程占用的时间很长，则会造成大量资源的浪费。因此可以设置自旋的次数(默认为十)，如果自旋超过了这个次数，就以传统的方式挂起线程。<br>在JDK 6中，引入了<strong>自适应自旋锁</strong>，对自旋锁进行了优化。自适应意味着自旋的时间不再固定，而是由前一次在同一个锁的自旋时间以及锁的拥有者的状态来决定的。<br>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么JVM会认为这次自旋也很有可能再次成功，就会允许自旋等待持续相对更长的时间。反之以后获取这个锁则有可能直接忽略掉自旋过程，避免浪费处理器资源。</p>
<h4 id="独享锁、共享锁"><a href="#独享锁、共享锁" class="headerlink" title="独享锁、共享锁"></a>独享锁、共享锁</h4><p><code>ReentrantLock</code>和<code>synchronized</code>都是独享锁，<code>ReadWriteLock</code>的读锁是共享锁，写锁是独享锁。</p>
<h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><p>一种锁的设计策略。在JDK 1.8之前，对于<code>ConcurrentHashMap</code>而言并发的实现就是通过分段锁的策略实现高效并发。要put元素时并不对整个HashMap加锁，而是先通过<code>hashcode</code>确定其分段，再对那个分段进行加锁。所以多线程put元素可以实现真正的并行插入。</p>
<h4 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h4><p><code>synchronized</code>是不可中断的，<code>Lock</code>是可中断的。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。<br>例如<code>StringBuffer</code>类，如果在单线程进行<code>append()</code>方法，编译器会自动消除锁，转化为非线程安全的<code>StringBuilder</code>类进行操作，提高效率。</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>平时在写代码时，总是推荐将同步块的范围尽量缩小。但如果一系列连续的操作都是针对同一对象反复加锁和解锁，那么效率将会下降。<br>例如对<code>StringBuilder</code>类连续调用<code>append()</code>方法，加锁范围将会粗化到整个操作序列外部，这样只需要加锁一次即可。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在无竞争的情况下把整个同步消除，连CAS都不做。<br>偏向锁意思这个锁会偏向第一个获得它的线程。如果这个锁一直没有被其他锁获取，那么持有这个锁的线程将永远不需要同步。一旦另一个线程获取该锁，偏向模式解除，后续的同步操作按照轻量级锁一样去执行。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>偏向锁解除偏向模式后就会升级为轻量级锁。<br>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁，等待的线程全部进入阻塞状态。</p>
<hr>
<p>总结：<br><img src="Java%E4%B8%BB%E6%B5%81%E9%94%81.png" alt=""><br>参见《深入理解Java虚拟机》。</p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>Java锁</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(1)</title>
    <url>/2020/05/30/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-1/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(1)</p>
<a id="more"></a>
<h4 id="01-01-判定字符是否唯一"><a href="#01-01-判定字符是否唯一" class="headerlink" title="01.01 判定字符是否唯一"></a>01.01 <a href="https://leetcode-cn.com/problems/is-unique-lcci/" target="_blank" rel="noopener">判定字符是否唯一</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>用set存储字符出现次数，判断是否有重复。<br>如果字符范围在字母内，可以用int32，利用每一位判断出现次数。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; astr.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = astr.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> ((n &gt;&gt; tmp &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            n ^= (<span class="number">1</span> &lt;&lt; tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="01-05-一次编辑"><a href="#01-05-一次编辑" class="headerlink" title="01.05 一次编辑"></a>01.05 <a href="https://leetcode-cn.com/problems/one-away-lcci/" target="_blank" rel="noopener">一次编辑</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>用双指针以及两个字符串的长短判断修改的次数。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">oneEditAway</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first.equals(second)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> m = first.length(), n = second.length();</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(m - n) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 长度差超过1直接返回false</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n; i++, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.charAt(i) != second.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 修改次数已用完</span></span><br><span class="line">                <span class="comment">// 短的字符串指针不移动</span></span><br><span class="line">                <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="01-07-旋转矩阵"><a href="#01-07-旋转矩阵" class="headerlink" title="01.07 旋转矩阵"></a>01.07 <a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">旋转矩阵</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像顺时针旋转 90 度。<br>不占用额外内存空间能否做到？</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>先按 \ 对角线翻转数组再左右翻转数组，或者先按 / 对角线翻转数组再上下翻转数组。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 按 \ 翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][l];</span><br><span class="line">                matrix[i][l] = matrix[i][r];</span><br><span class="line">                matrix[i][r] = tmp;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-01-移除重复节点"><a href="#02-01-移除重复节点" class="headerlink" title="02.01 移除重复节点"></a>02.01 <a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener">移除重复节点</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>用set存储出现过的节点值，判断。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        set.add(cur.val);</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(cur.next.val)) &#123;</span><br><span class="line">                set.add(cur.next.val);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = cur.next.next; <span class="comment">// set存在当前节点值，删除节点，当前指针不移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-02-返回倒数第-k-个节点"><a href="#02-02-返回倒数第-k-个节点" class="headerlink" title="02.02 返回倒数第 k 个节点"></a>02.02 <a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/" target="_blank" rel="noopener">返回倒数第 k 个节点</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>先让一个指针走k步，再双指针一起走。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(3)</title>
    <url>/2020/05/30/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-3/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(3)</p>
<a id="more"></a>
<h4 id="03-04-化栈为队"><a href="#03-04-化栈为队" class="headerlink" title="03.04 化栈为队"></a>03.04 <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/" target="_blank" rel="noopener">化栈为队</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>实现一个MyQueue类，该类用两个栈来实现一个队列。<br>假设所有操作都是有效的（例如，一个空的队列不会调用 pop 或者 peek 操作）。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>一个栈存元素，另一个栈取元素。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1; <span class="comment">// 存元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2; <span class="comment">// 取元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.empty() &amp;&amp; stack2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-02-最小高度树"><a href="#04-02-最小高度树" class="headerlink" title="04.02 最小高度树"></a>04.02 <a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/" target="_blank" rel="noopener">最小高度树</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>二叉搜索树<strong>中序遍历</strong>有序，所以以数组中间元素为根节点，不断二分递归。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(nums[mid]); <span class="comment">// 中间元素为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="comment">// 递归得到左右子树</span></span><br><span class="line">        node.left = buildTree(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        node.right = buildTree(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-04-检查平衡性"><a href="#04-04-检查平衡性" class="headerlink" title="04.04 检查平衡性"></a>04.04 <a href="https://leetcode-cn.com/problems/check-balance-lcci/" target="_blank" rel="noopener">检查平衡性</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p><strong>递归</strong>判断所有节点的两子树的最大高度差。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 递归判断</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(getHeight(root.left) - getHeight(root.right)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取树的最大高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getHeight(node.left), getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-08-首个共同祖先"><a href="#04-08-首个共同祖先" class="headerlink" title="04.08 首个共同祖先"></a>04.08 <a href="https://leetcode-cn.com/problems/first-common-ancestor-lcci/" target="_blank" rel="noopener">首个共同祖先</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。<br>所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p><strong>递归</strong>寻找共同祖先。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root; <span class="comment">// 找到节点</span></span><br><span class="line">        root.left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        root.right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// 如果p、q分别在两子树，首个共同祖先为此节点，否则为某个子节点。</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="keyword">return</span> root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-10-检查子树"><a href="#04-10-检查子树" class="headerlink" title="04.10 检查子树"></a>04.10 <a href="https://leetcode-cn.com/problems/check-subtree-lcci/" target="_blank" rel="noopener">检查子树</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。<br>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p><strong>递归</strong>比较子树是否相等。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 节点值相等，则递归检查以此节点为根的子树与t2是否相等。</span></span><br><span class="line">        <span class="keyword">if</span> (t1.val == t2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkSubTree(t1.left, t2.left) &amp;&amp; checkSubTree(t1.right, t2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则遍历t1其他节点</span></span><br><span class="line">        <span class="keyword">return</span> checkSubTree(t1.left, t2) || checkSubTree(t1.right, t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(2)</title>
    <url>/2020/05/30/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-2/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(2)</p>
<a id="more"></a>
<h4 id="02-04-分割链表"><a href="#02-04-分割链表" class="headerlink" title="02.04 分割链表"></a>02.04 <a href="https://leetcode-cn.com/problems/partition-list-lcci/" target="_blank" rel="noopener">分割链表</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>双指针，与x比较进行交换。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode small = head, large = head;</span><br><span class="line">        <span class="keyword">while</span> (small != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (small.val &lt; x) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = small.val;</span><br><span class="line">                small.val = large.val;</span><br><span class="line">                large.val = tmp;</span><br><span class="line">                large = large.next;</span><br><span class="line">            &#125;</span><br><span class="line">            small = small.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-05-链表求和"><a href="#02-05-链表求和" class="headerlink" title="02.05 链表求和"></a>02.05 <a href="https://leetcode-cn.com/problems/sum-lists-lcci/" target="_blank" rel="noopener">链表求和</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>给定两个用链表表示的整数，每个节点包含一个数位。<br>这些数位是反向存放的，也就是个位排在链表首部。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>双指针从个位逐步累加，边界处理。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="keyword">int</span> tmp = n1 + n2 + carry;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">            l1 = l1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l1.next;</span><br><span class="line">            l2 = l2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l2.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) cur.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>); <span class="comment">// 处理最高位的进位</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-06-回文链表"><a href="#02-06-回文链表" class="headerlink" title="02.06 回文链表"></a>02.06 <a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">回文链表</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>编写一个函数，检查输入的链表是否是回文的。<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>找到中间节点，翻转后半部分链表，再与前半部分进行比较。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="comment">// 找到中间节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode latter = reverse(slow.next); <span class="comment">// 翻转后半部链表</span></span><br><span class="line">        <span class="keyword">while</span> (latter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != latter.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode cur = node, last = <span class="keyword">null</span>, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = last;</span><br><span class="line">            last = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-07-链表相交"><a href="#02-07-链表相交" class="headerlink" title="02.07 链表相交"></a>02.07 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">链表相交</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。<br>如果两个链表没有交点，返回 null 。<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>可以用set存储链表的引用，判断是否有重复。要求O(1)内存就使用两个指针。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA, b = headB;</span><br><span class="line">        <span class="comment">// 都指向交点或者null退出循环</span></span><br><span class="line">        <span class="comment">// 一个链表的指针到末尾就指向另一个链表头</span></span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a == <span class="keyword">null</span> ? headB : a.next;</span><br><span class="line">            b = b == <span class="keyword">null</span> ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-08-环路检测"><a href="#02-08-环路检测" class="headerlink" title="02.08 环路检测"></a>02.08 <a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/" target="_blank" rel="noopener">环路检测</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>给定一个有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。<br>你是否可以不用额外空间解决此题？</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>快慢指针找环的入口。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head.next, fast = head.next.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 遇到空指针说明没有环</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(6)</title>
    <url>/2020/06/18/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-6/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(6)</p>
<a id="more"></a>
<h4 id="16-05-阶乘尾数"><a href="#16-05-阶乘尾数" class="headerlink" title="16.05 阶乘尾数"></a>16.05 <a href="https://leetcode-cn.com/problems/factorial-zeros-lcci/" target="_blank" rel="noopener">阶乘尾数</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>设计一个算法，算出 n 阶乘有多少个尾随零。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>0是由<code>*10</code>得到的，而10是由<code>2*5</code>得到的。<br>2的个数比5多，所以计算5的个数。每隔5个数就会出现一个5，隔25出现两个5，以此类推。<br>count = n / 5 + n / 5 / 5 + n / 5 / 5 / 5 + …</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            ans += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(4)</title>
    <url>/2020/05/31/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-4/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(4)</p>
<a id="more"></a>
<h4 id="04-12-求和路径"><a href="#04-12-求和路径" class="headerlink" title="04.12 求和路径"></a>04.12 <a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/" target="_blank" rel="noopener">求和路径</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>暴力求解，<strong>递归</strong>每一个节点。或者用<strong>前缀和</strong>进行缓存，降低时间复杂度。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力(9ms)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="comment">// 递归每个节点</span></span><br><span class="line">        pathSum(root.left, sum);</span><br><span class="line">        pathSum(root.right, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.val == sum) ans++; <span class="comment">// 找到路径</span></span><br><span class="line">        dfs(node.left, sum - node.val);</span><br><span class="line">        dfs(node.right, sum - node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀和(2ms)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录前缀和(前缀和有可能重复，所以要用map)</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; prefixSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        prefixSum.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        dfs(root, sum, root.val);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum, <span class="keyword">int</span> curSum)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 判断是否找到路径</span></span><br><span class="line">        ans += prefixSum.getOrDefault(curSum - sum, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 添加当前前缀和</span></span><br><span class="line">        prefixSum.put(curSum, prefixSum.getOrDefault(curSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) dfs(node.left, sum, curSum + node.left.val);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) dfs(node.right, sum, curSum + node.right.val);</span><br><span class="line">        <span class="comment">// 回滚</span></span><br><span class="line">        prefixSum.put(curSum, prefixSum.get(curSum) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="05-01-插入"><a href="#05-01-插入" class="headerlink" title="05.01 插入"></a>05.01 <a href="https://leetcode-cn.com/problems/insert-into-bits-lcci/" target="_blank" rel="noopener">插入</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>题目描述得不太好，就是将N的第j位到第i位替换成M，长度不够高位补0。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>先将N的j到i位替换成0，再加上移位后的M即可。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBits</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">        	<span class="comment">// 替换</span></span><br><span class="line">            N -= (<span class="number">1</span> &amp; (N &gt;&gt; k)) == <span class="number">1</span> ? (<span class="number">1</span> &lt;&lt; k) : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        N |= (M &lt;&lt; i); <span class="comment">// 覆盖</span></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="05-02-二进制数转字符串"><a href="#05-02-二进制数转字符串" class="headerlink" title="05.02 二进制数转字符串"></a>05.02 <a href="https://leetcode-cn.com/problems/bianry-number-to-string-lcci/" target="_blank" rel="noopener">二进制数转字符串</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>二进制数转字符串。给定一个介于0和1之间的实数(如0.72)，类型为double，打印它的二进制表达式。如果该数字不在0和1之间，或者无法精确地用32位以内的二进制表示，则打印“ERROR”。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>十进制小数转二进制：<strong>乘2取整，顺序排列</strong>。<br><img src="%E5%8D%81%E8%BF%9B%E5%88%B6%E5%B0%8F%E6%95%B0%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt=""><br><strong>末尾不为5的十进制小数无法精确转换为二进制，因为小数部分永远不可能为0。</strong></p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printBin</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">"0."</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                num *= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(<span class="number">1</span>);</span><br><span class="line">                    num -= <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">// 等于1说明小数部分已为0</span></span><br><span class="line">                    sb.append(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> sb.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行到这里说明此小数无法精确转换成二进制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="05-03-翻转数位"><a href="#05-03-翻转数位" class="headerlink" title="05.03 翻转数位"></a>05.03 <a href="https://leetcode-cn.com/problems/reverse-bits-lcci/" target="_blank" rel="noopener">翻转数位</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>因为只能改变一个0，所以记录先前长度，遇到0时减去即可。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, cur = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">            	<span class="comment">// 减去上次改动0的位置</span></span><br><span class="line">                cur -= pre;</span><br><span class="line">                <span class="comment">// pre记录的是上一次改动0的位置</span></span><br><span class="line">                pre = cur + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur++;</span><br><span class="line">            max = Math.max(max, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="05-07-配对交换"><a href="#05-07-配对交换" class="headerlink" title="05.07 配对交换"></a>05.07 <a href="https://leetcode-cn.com/problems/exchange-lcci/" target="_blank" rel="noopener">配对交换</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。<br>num的范围在[0, 2^30 - 1]之间，不会发生整数溢出。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>循环。或者使用<code>0x55555555</code>和<code>0xaaaaaaaa</code>得到奇偶位进行交换。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为1，奇数位为0）</span></span><br><span class="line">        <span class="comment">// 0x55555555 = 01010101010101010101010101010101 (偶数位为0，奇数位为1）</span></span><br><span class="line">        <span class="comment">// 分别与num位与，可以分别得到num奇偶位的数位。因为要交换，所以分别位移后进行或运算即可。</span></span><br><span class="line">        <span class="keyword">return</span> ((num &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>) | ((num &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(5)</title>
    <url>/2020/06/09/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-5/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(5)</p>
<a id="more"></a>
<h4 id="08-05-递归乘法"><a href="#08-05-递归乘法" class="headerlink" title="08.05 递归乘法"></a>08.05 <a href="https://leetcode-cn.com/problems/recursive-mulitply-lcci/" target="_blank" rel="noopener">递归乘法</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>可以利用加法，效率偏低。<br>还可以借助快速幂的思想，降低循环次数。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 较小值进行循环，提高效率</span></span><br><span class="line">        <span class="keyword">return</span> dfs(Math.max(A, B), Math.min(A, B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="comment">// 20 * 6 == 40 * 3</span></span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> dfs(a &lt;&lt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 20 * 3 == 20 + 40 * 1</span></span><br><span class="line">        <span class="keyword">return</span> a + (dfs(a &lt;&lt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="08-11-硬币"><a href="#08-11-硬币" class="headerlink" title="08.11 硬币"></a>08.11 <a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">硬币</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>完全背包问题。动态规划。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">// dp[i]表示i分有几种表示方法</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 0分有一种表示法</span></span><br><span class="line">        <span class="comment">// 每种硬币都可以选无数次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 大于当前硬币数额的分数才可以选这个硬币</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="comment">// 之前选的种类数加上这一步选的</span></span><br><span class="line">                dp[i] = (dp[i] + dp[i-coin]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="08-12-八皇后"><a href="#08-12-八皇后" class="headerlink" title="08.12 八皇后"></a>08.12 <a href="https://leetcode-cn.com/problems/eight-queens-lcci/" target="_blank" rel="noopener">八皇后</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>dfs。遍历所有情况，判断在不在同一对角线剪枝。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; pie = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 对于/对角线，在同一对角线上i+j相等。</span></span><br><span class="line">    Set&lt;Integer&gt; na = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 对于\对角线，在同一对角线上i-j相等。</span></span><br><span class="line">    Set&lt;Integer&gt; col = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 当前列是否出现过Q</span></span><br><span class="line">    List&lt;String&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 一行一行遍历</span></span><br><span class="line">        dfs(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历完了最后一行，说明这种摆法可行</span></span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历第i行每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col.contains(j) || pie.contains(i + j) || na.contains(i - j)) <span class="keyword">continue</span>;</span><br><span class="line">            col.add(j);</span><br><span class="line">            pie.add(i + j);</span><br><span class="line">            na.add(i - j);</span><br><span class="line">            cur.add(generate(j, n)); <span class="comment">// 生成字符串</span></span><br><span class="line">            dfs(i + <span class="number">1</span>, n); <span class="comment">// 搜索下一行</span></span><br><span class="line">            <span class="comment">// 撤回这一列的选择</span></span><br><span class="line">            col.remove(j);</span><br><span class="line">            pie.remove(i + j);</span><br><span class="line">            na.remove(i - j);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generate</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i) sb.append(<span class="string">"Q"</span>);</span><br><span class="line">            <span class="keyword">else</span> sb.append(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="08-13-堆箱子"><a href="#08-13-堆箱子" class="headerlink" title="08.13 堆箱子"></a>08.13 <a href="https://leetcode-cn.com/problems/pile-box-lcci/" target="_blank" rel="noopener">堆箱子</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。<br>输入使用数组[wi, di, hi]表示每个箱子。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>按某一维排序，转换成最长递增子序列问题。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pileBox</span><span class="params">(<span class="keyword">int</span>[][] box)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = box.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按宽排序</span></span><br><span class="line">        Arrays.sort(box, (x, y) -&gt; x[<span class="number">0</span>] - y[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// dp[i]表示第i个箱子在最底下时最大的箱子高度总和</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 最低高度就是只有第i个这一个箱子</span></span><br><span class="line">            dp[i] = box[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (box[i][<span class="number">0</span>] &gt; box[j][<span class="number">0</span>] &amp;&amp; box[i][<span class="number">1</span>] &gt; box[j][<span class="number">1</span>] &amp;&amp; box[i][<span class="number">2</span>] &gt; box[j][<span class="number">2</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 第i个箱子高度+第j个箱子在最底的最高高度与当前相比</span></span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + box[i][<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每一步都需要比较</span></span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="10-05-稀疏数组搜索"><a href="#10-05-稀疏数组搜索" class="headerlink" title="10.05 稀疏数组搜索"></a>10.05 <a href="https://leetcode-cn.com/problems/sparse-array-search-lcci/" target="_blank" rel="noopener">稀疏数组搜索</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>二分查找。遇到空字符串特殊处理。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findString</span><span class="params">(String[] words, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>), tmp = mid;</span><br><span class="line">            <span class="comment">// 如果words[mid]是空串，一直循环直到右边第一个非空串。</span></span><br><span class="line">            <span class="keyword">while</span> (words[mid].equals(<span class="string">""</span>) &amp;&amp; mid &lt; r) mid++;</span><br><span class="line">            <span class="comment">// 如果此时还是空串，说明从mid到r都是空串</span></span><br><span class="line">            <span class="keyword">if</span> (words[mid].equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="comment">// 将r直接变成mid-1</span></span><br><span class="line">                r = tmp - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 二分模板</span></span><br><span class="line">            <span class="keyword">int</span> cmp = words[mid].compareTo(s);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(1)</title>
    <url>/2020/06/01/%E5%89%91%E6%8C%87offer-1/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(1)</p>
<a id="more"></a>
<h4 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03 数组中重复的数字"></a>03 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>排序后查找重复数字。<br>哈希表。<br>二分。<br>利用题中条件<strong>所有数字都在 0～n-1 的范围内</strong>，比较下标以及下标对应的数字进行交换。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n)  空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	<span class="comment">// 下标对应的数字不等于下标时</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">            	<span class="comment">// 数字相等说明已找到重复</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[nums[i]];</span><br><span class="line">                <span class="comment">// 这里不能用nums[nums[i]] = tmp，因为上一步nums[i]已被更改。</span></span><br><span class="line">                nums[tmp] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上一段代码更改了源数组。如果要求不能更改，可以使用二分。</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(nlogn)  空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">// 此方法不一定能找出所有重复的数字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = i + ((j - i) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">int</span> cnt = countRange(nums, i, mid);</span><br><span class="line">			<span class="keyword">if</span> (i == j) &#123; <span class="comment">// 只剩一个数字</span></span><br><span class="line">				<span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// i～mid数字在数组中出现次数大于mid-i+1说明此范围有重复</span></span><br><span class="line">			<span class="keyword">if</span> (cnt &gt; (mid - i + <span class="number">1</span>)) j = mid;</span><br><span class="line">			<span class="keyword">else</span> i = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n &gt;= i &amp;&amp; n &lt;= j) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11 旋转数组的最小数字"></a>11 <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>数组相对有序，使用二分查找。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(logn)  空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 中间比右边大，说明此元素属于被旋转的那部分，最小元素一定不在这里。</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[l]) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> r--; <span class="comment">// 相等时无法判断处于哪部分，只能缩小范围去重。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="14-i-剪绳子"><a href="#14-i-剪绳子" class="headerlink" title="14 i.剪绳子"></a>14 <a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">i.剪绳子</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]*k[1]*…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>动态规划或者贪心。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(n^2)  空间复杂度：O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 由于至少剪一次，n=2或3时特殊处理。</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 绳子剩余2或3时，已经至少剪过1次，此时最好的情况是不剪</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>; dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] * dp[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-ii-剪绳子"><a href="#14-ii-剪绳子" class="headerlink" title="14 ii.剪绳子"></a>14 <a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">ii.剪绳子</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>与上题一样。但答案可能会很大，需要取模 1e9+7（1000000007）。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>本题不能用动态规划。因为取模后无法正确比较大小。只能用贪心。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        	<span class="comment">// 有3取3</span></span><br><span class="line">            ans *= <span class="number">3</span>;</span><br><span class="line">            ans %= <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (ans * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16 数值的整数次方"></a>16 <a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">数值的整数次方</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>快速幂。注意边界问题。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// -2147483648直接取绝对值会溢出，需要先转成long。</span></span><br><span class="line">        <span class="keyword">long</span> y = n;</span><br><span class="line">        y = y &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line">        <span class="comment">// 快速幂</span></span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((y &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? res : <span class="number">1</span> / res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(2)</title>
    <url>/2020/06/02/%E5%89%91%E6%8C%87offer-2/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(2)</p>
<a id="more"></a>
<h4 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19 正则表达式匹配"></a>19 <a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">正则表达式匹配</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>动态规划。二维dp数组。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="comment">// 需要判断为空的情况，所以长度+1</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// s为空也可能被p匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">2</span>] &amp;&amp; p.charAt(i-<span class="number">1</span>) == <span class="string">'*'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// s的前i位能否被p的前j位匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                	<span class="comment">// 1.之前元素出现0次，直接移除p两个元素，s不变</span></span><br><span class="line">                	<span class="comment">// 2.之前元素出现1或多次，比较s的i元素与p的j-1元素，</span></span><br><span class="line">                	<span class="comment">//   相等则移除s当前元素，p继续匹配</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] || (check(s, p, i, j - <span class="number">1</span>) &amp;&amp; dp[i][j+<span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">// s的i元素与p的j元素是否相等，相等则分别移除当前元素比较之前元素</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] &amp;&amp; check(s, p, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.charAt(j) == <span class="string">'.'</span> || s.charAt(i) == p.charAt(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29 顺时针打印矩阵"></a>29 <a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">顺时针打印矩阵</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>四个变量分别记录当前上下左右边界的索引，判断结束条件。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">        <span class="comment">// 当前边界索引</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, u = <span class="number">0</span>, d = m - <span class="number">1</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        	<span class="comment">// 右下左上顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                res[idx++] = matrix[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++u &gt; d) <span class="keyword">break</span>; <span class="comment">// 跳出循环条件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = u; i &lt;= d; i++) &#123;</span><br><span class="line">                res[idx++] = matrix[i][r];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--) &#123;</span><br><span class="line">                res[idx++] = matrix[d][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--d &lt; u) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &gt;= u; i--) &#123;</span><br><span class="line">                res[idx++] = matrix[i][l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33 二叉搜索树的后序遍历序列"></a>33 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>数组最后一位为根节点，根据大小找到左子树与右子树，递归判断是否合法。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = postorder.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> check(postorder, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 剩一个元素，递归终止。</span></span><br><span class="line">        <span class="keyword">int</span> idx; <span class="comment">// 左子树索引</span></span><br><span class="line">        <span class="keyword">for</span> (idx = left; idx &lt; right; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[idx] &gt; arr[right]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; right; i++) &#123;</span><br><span class="line">        	<span class="comment">// 如果右子树有值小于根节点的数，则不是二叉搜索树。</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[right]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归判断子树</span></span><br><span class="line">        <span class="keyword">return</span> check(arr, left, idx - <span class="number">1</span>) &amp;&amp; check(arr, idx, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35 复杂链表的复制"></a>35 <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>普通方法只能复制一般的链表，无法复制random指针。<br>可以利用哈希表存储原链表与复制链表，这样就可以根据键值对找到random指针，但要消耗O(n)空间。<br>所以还有一种原地修改的方法。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node cur = head, copy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 1-&gt;2-&gt;3 ----&gt; 1-&gt;1'-&gt;2-&gt;2'-&gt;3-&gt;3'</span></span><br><span class="line">        <span class="comment">// 这样就可以定位random指针的位置</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            copy = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            copy.next = cur.next;</span><br><span class="line">            cur.next = copy;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">// 复制random指针</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        Node ans = head.next, tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 分离原始链表和复制链表，head.next即为复制的链表。</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = tmp.next;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36 二叉搜索树与双向链表"></a>36 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>二叉搜索树<strong>中序遍历</strong>有序。全局变量记录头节点和上一个节点，利用中序遍历将所有节点连在一起，最后将头尾相连即可。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node head = <span class="keyword">null</span>, pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">// 执行完dfs，pre即为尾节点，将头尾相连。</span></span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) dfs(node.left);</span><br><span class="line">        node.left = pre;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.right = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// pre == null，说明当前节点是中序遍历头节点。</span></span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) dfs(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(3)</title>
    <url>/2020/06/05/%E5%89%91%E6%8C%87offer-3/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(3)</p>
<a id="more"></a>
<h4 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38 字符串的排列"></a>38 <a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>输入一个字符串，打印出该字符串中字符的所有排列。<br>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>dfs。因为有重复元素需要剪枝去重。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n!)  // 空间复杂度 O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        dfs(c, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> String[ans.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 到达最后一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> String(arr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">        	<span class="comment">// 如果字符已经存在，跳过这个字符</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(arr[j])) <span class="keyword">continue</span>;</span><br><span class="line">            set.add(arr[j]);</span><br><span class="line">            <span class="comment">// 固定arr[j]在i位置</span></span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">            dfs(arr, i + <span class="number">1</span>, n);</span><br><span class="line">            <span class="comment">// 恢复交换</span></span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42 连续子数组的最大和"></a>42 <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>要求时间复杂度为O(n)。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p><strong>动态规划</strong>。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 初始值为nums[0]，如果数组只有一个数，直接返回。</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	<span class="comment">// dp[i]表示以第i个数结尾的子数组的最大和</span></span><br><span class="line">        	<span class="comment">// 如果之前的最大和加上当前这个数比这个数大，就加上</span></span><br><span class="line">            dp[i] = Math.max(nums[i], dp[i-<span class="number">1</span>] + nums[i]);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="43-1-n整数中1出现的次数"><a href="#43-1-n整数中1出现的次数" class="headerlink" title="43 1~n整数中1出现的次数"></a>43 <a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">1~n整数中1出现的次数</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。<br>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。<br>1 &lt;= n &lt; 2^31</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>暴力。由于n的范围较大，会超时。<br>循环每一位数，统计每一位数上1出现的次数，最后累加即为结果。时间复杂度为O(logn)。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n / i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> high = n / (<span class="number">10</span> * i); <span class="comment">// 高位</span></span><br><span class="line">            <span class="keyword">long</span> cur = n / i % <span class="number">10</span>; <span class="comment">// 当前位</span></span><br><span class="line">            <span class="keyword">long</span> low = n - n / i * i; <span class="comment">// 低位</span></span><br><span class="line">            <span class="comment">// 当前位等于0，出现1的次数只与高位有关。</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += high * i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="comment">// 等于1与高低位都有关</span></span><br><span class="line">                ans += high * i + low + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 其他数也只与高位有关</span></span><br><span class="line">                ans += (high + <span class="number">1</span>) * i;</span><br><span class="line">            &#125;</span><br><span class="line">            i *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44 数字序列中某一位的数字"></a>44 <a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">数字序列中某一位的数字</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。<br>请写一个函数，求任意第n位对应的数字。<br>0 &lt;= n &lt; 2^31</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>转成字符串处理。由于数字范围较大，内存会溢出。<br>找规律，判断数字出现的范围。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 1～9 9位  10～99 90位。100～999 900位。以此类推。</span></span><br><span class="line">        <span class="keyword">long</span> cnt = <span class="number">9</span>, start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; cnt) &#123;</span><br><span class="line">            n -= cnt;</span><br><span class="line">            digit++;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            cnt = start * digit * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断数位在哪个数字中</span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit;</span><br><span class="line">        <span class="comment">// 判断在数字的哪一位</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48 最长不含重复字符的子字符串"></a>48 <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>动态规划。记录当前字符在字符串中上一次出现的下标，与当前长度对比更新最大值。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] lastIdx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 初始化下标为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) lastIdx[i] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = lastIdx[(<span class="keyword">int</span>) s.charAt(i)];</span><br><span class="line">            <span class="comment">// 如果当前字符未出现过或者出现的距离大于当前子串长度，长度+1</span></span><br><span class="line">            <span class="comment">// 否则将当前子串长度设为出现的位置下标之差以保证不含重复字符</span></span><br><span class="line">            <span class="keyword">if</span> (last == -<span class="number">1</span> || i - last &gt; cur) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = i - last;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, cur);</span><br><span class="line">            <span class="comment">// 更新最后出现当前字符的下标</span></span><br><span class="line">            lastIdx[(<span class="keyword">int</span>) s.charAt(i)] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(5)</title>
    <url>/2020/06/07/%E5%89%91%E6%8C%87offer-5/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(5)</p>
<a id="more"></a>
<h4 id="59-i-滑动窗口的最大值"><a href="#59-i-滑动窗口的最大值" class="headerlink" title="59-i 滑动窗口的最大值"></a>59-i <a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">滑动窗口的最大值</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>维护一个队列，首元素为当前窗口的最大值。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化前k位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        	<span class="comment">// 当前元素和队列里的元素进行比较，大的话就删除队列里的元素</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) deque.pollLast();</span><br><span class="line">            deque.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = deque.peek();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">        	<span class="comment">// 如果队列里的最大元素等于nums[i-k]，说明此最大值已不再当前窗口</span></span><br><span class="line">            <span class="keyword">if</span> (deque.peek() == nums[i-k]) deque.poll();</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) deque.pollLast();</span><br><span class="line">            deque.offer(nums[i]);</span><br><span class="line">            <span class="comment">// 当前窗口的最大值为队列首元素</span></span><br><span class="line">            ans[i-k+<span class="number">1</span>] = deque.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60 n个骰子的点数"></a>60 <a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">n个骰子的点数</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。<br>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>动态规划。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] twoSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    	<span class="comment">// dp[i][j]表示扔了i个骰子后和为j的排列情况总数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">6</span>*n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 结果数组长度为6n-n+1</span></span><br><span class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>*n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 第一个骰子，总和只能为1～6，每种出现一次。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// n个骰子，每个1～6点数，总共6^n种排列情况。</span></span><br><span class="line">        <span class="keyword">double</span> all = Math.pow(<span class="number">6</span>, n);</span><br><span class="line">        <span class="comment">// n个骰子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        	<span class="comment">// i个骰子可能出现的点数总和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= <span class="number">6</span> * i; j++) &#123;</span><br><span class="line">            	<span class="comment">// 每个骰子1～6点数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span>; k++) &#123;</span><br><span class="line">                	<span class="comment">// i个骰子总和为j的情况总数等于</span></span><br><span class="line">                	<span class="comment">// i-1个骰子总和为j-k的情况总数，k为当前着个骰子扔的点数。</span></span><br><span class="line">                    dp[i][j] += j &gt;= k ? dp[i-<span class="number">1</span>][j-k] : <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// i == n，说明已经扔到了最后一个骰子，可以开始添加结果。</span></span><br><span class="line">                    <span class="keyword">if</span> (i == n) ans[j-i] = dp[i][j] / all;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 <a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">不用加减乘除做加法</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。<br>a, b 均可能是负数或 0，结果不会溢出 32 位整数。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>既然不能用加减乘除，那就用位运算。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123; <span class="comment">// 进位为0退出</span></span><br><span class="line">        	<span class="comment">// 非进位和(相当于异或)</span></span><br><span class="line">            <span class="keyword">int</span> sum = a ^ b;</span><br><span class="line">            <span class="comment">// 进位和(位与再左移一位，这样当某一位上两个数都是1时就会进位)</span></span><br><span class="line">            <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>原码、反码、补码</title>
    <url>/2020/05/28/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<p> 之前不了解机器为何要使用补码进行存储，学习之后记录一下。</p>
<a id="more"></a>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>原码就是符号位加上真值的绝对值，即最高位用<code>1</code>表示负数，<code>0</code>表示正数，其余位表示数值。<br>例如8位二进制：</p>
<blockquote>
<p>[+1]原：00000001<br>[-1]原：10000001</p>
</blockquote>
<p>可见8位二进制表示数字的范围为<code>[-127, 127]</code>。</p>
<hr>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>反码的表示形式是：</p>
<ul>
<li>正数的反码是其本身</li>
<li>负数的反码是在其原码的基础上，符号位不变，其余各个位取反</li>
</ul>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反<br>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>如果一个用反码表示的负数，人脑需要将其转成原码才比较好计算。</p>
<hr>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>反码的表示形式是：</p>
<ul>
<li>正数的补码是其本身</li>
<li>负数的补码是在其反码的基础上+1</li>
</ul>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补<br>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>如果一个用补码表示的负数，人脑依然很难直接看出数值。</p>
<hr>
<h3 id="为何要发明反码和补码"><a href="#为何要发明反码和补码" class="headerlink" title="为何要发明反码和补码"></a>为何要发明反码和补码</h3><p>首先，人脑可以很容易地根据最高位分辨出一个数是正数还是负数，但对于计算机来说，肯定要设计得尽量简单，让计算机判断符号位会使计算机的电路设计显得很复杂。于是计算机会将符号位也参与计算。比如对于<code>1-1</code>这个运算，计算机会将运算变成<code>1+(-1)</code>，这时如果用原码进行计算，就会出现问题。</p>
<blockquote>
<p>1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>
</blockquote>
<p>结果并不等于0。所以计算机并不使用原码表示一个数。</p>
<p>因此出现了反码。用反码进行计算。</p>
<blockquote>
<p>1 + (-1) = [00000001]反 + [11111110]反 = [11111111]反 = [10000000]原 = -0</p>
</blockquote>
<p>这时结果为-0，已经能得到正确结果。这时唯一的问题就是0。因为0带符号是没有意义的，而且原码的<code>[10000000]</code>和<code>[00000000]</code>都表示0，这显然不够完美。</p>
<p>于是补码应运而生，它完美的解决了这个问题。</p>
<blockquote>
<p>1 + (-1) = [00000001]补 + [11111111]补 = [00000000]补 = [00000000]原 = 0</p>
</blockquote>
<p>这时0只用一个编码来表示了，而-0则可以用来表示-128。</p>
<blockquote>
<p>(-1) + (-127) = [11111111]补 + [10000001]补 = [10000000]补</p>
</blockquote>
<p>所以在补码运算的结果中<code>[10000000]补</code>就是-128。但由于其实是用以前的-0的补码来表示-128，所以-128并没有反码和原码来表示。<br>这也是为什么对于8位二进制数，原码和反码表示的范围是<code>[-127, 127]</code>，而补码表示的是<code>[-128, 127]</code>。而对于常见的int32也是如此。由于机器是使用补码存储，所以int32表示的范围是<code>[-2^31, 2^31-1]</code>。</p>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/05/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>最近闲在家里没事，就用hexo搭建了一个博客。不过不知道写点啥，先开个头吧～</p>
<a id="more"></a>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(4)</title>
    <url>/2020/06/06/%E5%89%91%E6%8C%87offer-4/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(4)</p>
<a id="more"></a>
<h4 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49 丑数"></a>49 <a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>三指针。第一个丑数是1，以后的丑数都是基于前面的小丑数分别乘2，3，5构成的。每次添加当前计算出的最小的丑数，更新相应的指针。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">6</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 第一个丑数是1</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx2 = <span class="number">0</span>, idx3 = <span class="number">0</span>, idx5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	<span class="comment">// 计算出当前最小丑数</span></span><br><span class="line">            dp[i] = Math.min(dp[idx2] * <span class="number">2</span>, Math.min(dp[idx3] * <span class="number">3</span>, dp[idx5] * <span class="number">5</span>));</span><br><span class="line">            <span class="comment">// 更新指针。由于可能出现相等的情况，这时多个指针都要更新，所以不用else if。</span></span><br><span class="line">            <span class="keyword">if</span> (dp[idx2] * <span class="number">2</span> == dp[i]) idx2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[idx3] * <span class="number">3</span> == dp[i]) idx3++;</span><br><span class="line">            <span class="keyword">if</span> (dp[idx5] * <span class="number">5</span> == dp[i]) idx5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51 数组中的逆序对"></a>51 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>归并排序。每次归并时统计有多少逆序对。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        mergeSort(nums, start, mid);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// 归并并找逆序对</span></span><br><span class="line">        merge(nums, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = start, r = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= nums[r]) &#123;</span><br><span class="line">                tmp[k++] = nums[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 如果左半边的数比右边大，存在逆序</span></span><br><span class="line">            	<span class="comment">// 2, 3, 4, 5      1, 3, 6, 7</span></span><br><span class="line">            	<span class="comment">// 2比1大，说明2到mid的数全大于1，存在4个逆序对</span></span><br><span class="line">                cnt += mid - l + <span class="number">1</span>;</span><br><span class="line">                tmp[k++] = nums[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">            tmp[k++] = nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= end) &#123;</span><br><span class="line">            tmp[k++] = nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 赋给源数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            nums[i] = tmp[i - start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53 在排序数组中查找数字"></a>53 <a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">在排序数组中查找数字</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>统计一个数字在排序数组中出现的次数。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>有序数组，使用两次二分法分别找出数字的左右边界。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左边界</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 小的话target左边界只可能在另一边</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 大的话target左边界只可能在左边</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 相等的话左边界可能是这个或者在左边</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右下标即为左边界</span></span><br><span class="line">        <span class="keyword">int</span> left = r;</span><br><span class="line">        l = <span class="number">0</span>; r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右边界</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左下标为右边界</span></span><br><span class="line">        <span class="keyword">return</span> l - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="56-数组中数字出现的次数-i"><a href="#56-数组中数字出现的次数-i" class="headerlink" title="56 数组中数字出现的次数 i"></a>56 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">数组中数字出现的次数 i</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。<br>要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>循环数组取异或，结果为这两个数字的异或。判断这个数最低位的1的位置，对数组中的元素根据此位是否为1划分为两部分。<br>再次异或即可得到其中一个数，由<code>a ^ b ^ a = b</code>得到另一个数。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        	<span class="comment">// n最终为两个出现了一次的数的异或</span></span><br><span class="line">            n ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找出最低位的1</span></span><br><span class="line">        <span class="keyword">while</span> ((n &amp; (<span class="number">1</span> &lt;&lt; idx)) == <span class="number">0</span>) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 筛选idx位为0的数，得到其中一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; idx)) == <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再异或得到另一个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;a, n ^ a&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="56-数组中数字出现的次数-ii"><a href="#56-数组中数字出现的次数-ii" class="headerlink" title="56 数组中数字出现的次数 ii"></a>56 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">数组中数字出现的次数 ii</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>如果一个数出现了三次，它的二进制表示的每一位也出现三次，即每一位的和可以被3整除。<br>将所有数字的每一位相加，最后如果某一位能被3整除，说明出现一次的数字的这一位是0，否则是1。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">// 计算每一位的和，对3取模。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                arr[i] += (n &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">                arr[i] %= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 得到出现一次的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            ans += arr[i] == <span class="number">1</span> ? <span class="number">1</span> &lt;&lt; i : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/05/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>记录一下常规的排序算法</p>
<a id="more"></a>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h4><p>常见的排序算法可分为以下两大类：</p>
<blockquote>
<p>比较类排序：通过比较来决定元素间的相对顺序，由于其时间复杂度不能突破<code>O(nlogn)</code>，因此也称为非线性时间比较类排序。<br>非比较类排序：不通过比较来决定元素间的相对顺序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。<br><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png" alt=""></p>
</blockquote>
<h4 id="时间、空间复杂度分析"><a href="#时间、空间复杂度分析" class="headerlink" title="时间、空间复杂度分析"></a>时间、空间复杂度分析</h4><h2 id=""><a href="#" class="headerlink" title=""></a><img src="%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt=""></h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="算法逻辑"><a href="#算法逻辑" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>循环数组中的每一对元素，比较二者大小，逆序就交换位置。这样循环一轮后最大的数会在数组末尾。重复即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123; <span class="comment">// 除了最后一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123; <span class="comment">// 后面已经排好序无需再比</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="算法逻辑-1"><a href="#算法逻辑-1" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>个人认为选择排序是最直观、最好理解的排序算法。从第1个数开始循环数组，每次循环都把当前最小值放到数组前面。重复即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 保存最小值对应的索引</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[min];</span><br><span class="line">        arr[min] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="算法逻辑-2"><a href="#算法逻辑-2" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>从第1个数开始循环数组，取出当前元素，从后到前分别与每一个元素进行比较，直到遇到第一个比当前元素小的数字，将当前元素插入此数字后面即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prei = i - <span class="number">1</span>, cur = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (prei &gt;= <span class="number">0</span> &amp;&amp; arr[prei] &gt; cur) &#123; <span class="comment">// 遇到第一个比当前小的就退出</span></span><br><span class="line">            arr[prei+<span class="number">1</span>] = arr[prei];</span><br><span class="line">            prei--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[prei+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="算法逻辑-3"><a href="#算法逻辑-3" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>选出一个元素作为<code>pivot</code>，通过一次循环将<code>pivot</code>直接放到最终结果的正确位置，即<code>pivot</code>左边的元素均比它小，右边均比它大。将左右两个子数组<strong>递归</strong>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">int</span> pivot = partition(arr, start, end); <span class="comment">// 获取基准值对应的索引</span></span><br><span class="line">    <span class="comment">// 对两部分数组递归</span></span><br><span class="line">    quickSort(arr, start, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivot + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = end, counter = start; <span class="comment">// counter: 记录小于基准值的数的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="comment">// 比基准值小就放到前面</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, counter, i);</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, counter, pivot); <span class="comment">// 使基准值位于最终结果的正确位置</span></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="算法逻辑-4"><a href="#算法逻辑-4" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>算法采用<strong>分治</strong>的思想。先将数组分成长度为<code>n/2</code>的两个数组，再对这两个子数组递归进行归并排序，最后将子数组合并成有序数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>; <span class="comment">// 长度小于2退出递归</span></span><br><span class="line">    <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 递归到最小单元</span></span><br><span class="line">    mergeSort(arr, start, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">    merge(arr, start, mid, end); <span class="comment">// 合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>]; <span class="comment">// 中间数组</span></span><br><span class="line">    <span class="keyword">int</span> i = start, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 双指针归并</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">        tmp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= end) tmp[k++] = arr[j++];</span><br><span class="line">    <span class="comment">// 赋给源数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; end - start + <span class="number">1</span>; idx++) &#123;</span><br><span class="line">        arr[idx+start] = tmp[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="算法逻辑-5"><a href="#算法逻辑-5" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>用堆维护一个大顶堆或小顶堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue; <span class="comment">// java中的优先队列底层数据结构就是堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(); <span class="comment">// 默认升序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) pq.offer(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) arr[i] = pq.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>上述几个排序算法都是比较排序，还有几种非比较排序算法，主要逻辑就是利用额外数组根据下标存储，缺点是源数组的元素只能是<strong>整数</strong>。本文不做多记录。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(1)</title>
    <url>/2020/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1/</url>
    <content><![CDATA[<p>记录常见的设计模式(1)。</p>
<a id="more"></a>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><a href="http://irvlin.xyz/2020/06/22/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/#more">单例模式</a></p>
<hr>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.gif" alt=""></p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductImpl</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"产品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryImpl</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory f = <span class="keyword">new</span> FactoryImpl();</span><br><span class="line">        Product p = f.createProduct();</span><br><span class="line">        p.productMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四要素"><a href="#四要素" class="headerlink" title="四要素"></a>四要素</h4><ol>
<li>工厂接口。工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。在实际编程中，有时候也会使用一个抽象类来作为与调用者交互的接口，其本质上是一样的。</li>
<li>工厂实现。在编程中，工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。</li>
<li>产品接口。产品接口的主要目的是定义产品的规范，所有的产品实现都必须遵循产品接口定义的规范。产品接口是调用者最为关心的，产品接口定义的优劣直接决定了调用者代码的稳定性。同样，产品接口也可以用抽象类来代替，但要注意最好不要违反<img src="https://baike.baidu.com/item/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99" alt="里氏替换原则">。</li>
<li>产品实现。实现产品接口的具体类，决定了产品在客户端中的具体行为。<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4></li>
<li>可以使代码结构清晰，有效地封装变化。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需依赖工厂即可得到自己想要的产品。</li>
<li>对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。即使变更了具体的实现，对调用者来说没有任何影响。</li>
<li>降低耦合度。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4>首先，作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。<br>其次，工厂模式是一种典型的解耦模式，<img src="https://baike.baidu.com/item/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99" alt="迪米特法则">在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度。<br>再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。<h4 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h4>以组装汽车为例。场景如下：汽车由发动机、轮、底盘组成，现在需要组装一辆车交给调用者。<br>如果没有用工厂模式，代码大概是这样的：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStyle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是汽车的发动机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Underpan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStyle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是汽车的底盘"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStyle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是汽车的轮胎"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Engine engine = <span class="keyword">new</span> Engine();</span><br><span class="line">        Underpan underpan = <span class="keyword">new</span> Underpan();</span><br><span class="line">        Wheel wheel = <span class="keyword">new</span> Wheel();</span><br><span class="line">        ICar car = <span class="keyword">new</span> Car(underpan, wheel, engine);</span><br><span class="line">        car.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，调用者为了得到汽车，还需要自己实例化发动机、轮和底盘。这严重违反了迪米特法则，耦合度太高。并且非常不利于扩展。<br>另外，这个例子中发动机、轮和底盘还是比较具体的，在实际应用中，可能这些产品的组件也都是抽象的，调用者根本不知道怎样组装产品。所以，就需要用到工厂模式。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Engine engine = <span class="keyword">new</span> Engine();</span><br><span class="line">        Underpan underpan = <span class="keyword">new</span> Underpan();</span><br><span class="line">        Wheel wheel = <span class="keyword">new</span> Wheel();</span><br><span class="line">        ICar car = <span class="keyword">new</span> Car(underpan, wheel, engine);</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IFactory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">        ICar car = factory.createCar();</span><br><span class="line">        car.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用了工厂模式之后，调用端的耦合度大大降低。对于工厂类，可扩展性也大大增加。并且调用者不需要关心底层是如何组装汽车的，只需要实例化工厂类，调用其方法就行了。</li>
</ol>
<hr>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</p>
<h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><p><img src="%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.jpg" alt=""></p>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prototype = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"原型模式实现类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcretePrototype cp = <span class="keyword">new</span> ConcretePrototype();</span><br><span class="line">        ConcretePrototype clonecp = (ConcretePrototype) cp.clone();</span><br><span class="line">        clonecp.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。</li>
<li>使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。</li>
</ol>
<p>所以，如果需要重复创建相似对象时，可以考虑使用原型模式。假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。还记得单例模式吗？单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。</li>
<li>深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。</li>
</ol>
<hr>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。</p>
<h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h4><p><img src="%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg" alt=""></p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>模板方法是编程中经常用到的模式。例如，有一个程序员A拿到了一个任务，要对一个整型数组进行排序并打印出来。这个任务可以分成两部分，排序和打印输出。程序员A首先很快地完成了打印的任务，由于排序的部分比较麻烦，于是A把排序的任务交给了B。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showResult</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sort(arr);</span><br><span class="line">        System.out.print(<span class="string">"排序结果："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B拿到任务后很快完成了排序的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSort</span> <span class="keyword">extends</span> <span class="title">AbstractSort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            xxxSort(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">xxxSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，A再进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortAndShow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        AbstractSort as = <span class="keyword">new</span> ConcreteSort();</span><br><span class="line">        as.showResult(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成。<br>这种某些人先完成其中一部分功能，并将其它功能声明为抽象方法再交由其他人完成的模式就叫做模板方法模式。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>模板方法模式由一个抽象类和一个（或一组）实现类通过继承结构组成，抽象类中的方法分为三种：</p>
<ol>
<li>抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。</li>
<li>模板方法：由抽象类声明并加以实现。一般来说，模板方法调用抽象方法来完成主要的逻辑功能，并且，模板方法大多会定义为final类型，指明<strong>主要的逻辑功能在子类中不能被重写</strong>。</li>
<li>钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模板方法的逻辑。</li>
<li>抽象类的任务是搭建逻辑的框架，通常由经验丰富的人员编写，因为抽象类的好坏直接决定了程序是否稳定性。实现类用来实现细节。抽象类中的模板方法正是通过实现类扩展的方法来完成业务逻辑。只要实现类中的扩展方法通过了单元测试，在模板方法正确的前提下，整体功能一般不会出现大的错误。<h4 id="优点及适用场景"><a href="#优点及适用场景" class="headerlink" title="优点及适用场景"></a>优点及适用场景</h4></li>
<li>容易扩展。一般来说，抽象类中的模板方法是不易反生改变的部分，而抽象方法是容易反生变化的部分，因此通过增加实现类一般可以很容易实现功能的扩展，符合<img src="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" alt="开闭原则">。</li>
<li>便于维护。对于模板方法模式来说，正是由于他们的主要逻辑相同，才使用了模板方法，假如不使用模板方法，任由这些相同的代码散乱的分布在不同的类中，维护起来是非常不方便的。</li>
<li>比较灵活。因为有钩子方法，因此，子类的实现也可以影响父类中主逻辑的运行。但是，在灵活的同时，由于子类影响到了父类，违反了里氏替换原则，也会给程序带来风险。这就对抽象类的设计有了更高的要求。</li>
<li>在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模板方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。</li>
</ol>
<hr>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p>
<h4 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h4><p><img src="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt=""><br>在软件系统中经常会有这样的需求：如果一个对象的状态发生改变，某些与它相关的对象也要随之做出相应的变化。能实现这一个点的方案很多，但无疑观察者模式是主流的一个选择。</p>
<h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p>在基础的观察者模式中，包含以下四种角色：</p>
<ol>
<li><strong>被观察者</strong>：从类图中可以看到，类中有一个用来存放观察者对象的Vector容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。</li>
<li><strong>观察者</strong>：观察者角色一般是一个接口，它只有一个update方法，在被观察者状态发生变化时，这个方法就会被触发调用。</li>
<li><strong>具体的被观察者</strong>：使用这个角色是为了便于扩展，可以在此角色中定义具体的业务逻辑。</li>
<li><strong>具体的观察者</strong>：观察者接口的具体实现，在这个角色中，将定义被观察者对象状态发生变化时所要处理的逻辑。<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Vector obs = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer obs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obs.add(obs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delObserver</span><span class="params">(Observer obs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obs.remove(obs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer o : obs) &#123;</span><br><span class="line">            o.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"被观察者事件反生"</span>);</span><br><span class="line">        <span class="keyword">this</span>.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"观察者1收到信息，并进行处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"观察者2收到信息，并进行处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject sub = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        sub.addObserver(<span class="keyword">new</span> ConcreteObserver1()); <span class="comment">//添加观察者1</span></span><br><span class="line">        sub.addObserver(<span class="keyword">new</span> ConcreteObserver2()); <span class="comment">//添加观察者2</span></span><br><span class="line">        sub.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行的结果：<blockquote>
<p>被观察者事件反生<br>观察者1收到信息，并进行处理。<br>观察者2收到信息，并进行处理。</p>
</blockquote>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4></li>
<li>观察者与被观察者之间是属于轻度的关联关系，并且是抽象耦合的，这样，对于两者来说都比较容易进行扩展。</li>
<li>观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理。但同时，这也算是观察者模式一个缺点，由于是链式触发，当观察者比较多的时候，性能问题是比较令人担忧的。并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>java语言中，有一个接口Observer，以及它的实现类Observable，对观察者角色常进行了实现。我们可以在jdk的api文档具体查看这两个类的使用方法。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2020/08/09/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>记录Java线程池相关知识。</p>
<a id="more"></a>
<h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><p>随着计算机行业的飞速发展，多核CPU逐渐成为主流。多线程成为了提升服务器性能的必备武器。<br>线程池是一种<code>池化技术</code>，用于管理多线程，经常出现在多线程服务器中，例如MySQL。</p>
<hr>
<h3 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h3><p>线程过多会带来额外的开销，包括线程的创建和调度以及销毁，导致系统性能的降低，最终有可能导致系统内存耗尽。而使用线程池则可以避免这些问题：</p>
<ol>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li><strong>提高响应速度</strong>：无需等待创建线程即可立即执行任务。</li>
<li><strong>提高线程的可管理性</strong>：对线程进行进行统一的分配、调优和监控。</li>
<li><strong>提供额外功能</strong>：线程池还有许多拓展的功能，例如延时定时线程池，可对任务延期执行或者定期执行。</li>
</ol>
<hr>
<h3 id="线程池核心设计"><a href="#线程池核心设计" class="headerlink" title="线程池核心设计"></a>线程池核心设计</h3><p>Java线程池的核心实现类是<code>ThreadPoolExecutor</code>，其类图如下:<br><img src="ThreadPoolExecutor%E7%B1%BB%E5%9B%BE.png" alt=""><br>ThreadPoolExecutor的顶层接口是<code>Executor</code>，它提供了一种思想，将任务提交和任务执行进行解耦。将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，只需提供<code>Runnable</code>对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。<br>而<code>ExecutorService</code>接口则拓展了一些功能：</p>
<ol>
<li>扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法。</li>
<li>提供了管控线程池的方法，比如停止线程池的运行。</li>
</ol>
<p><code>AbstractExecutorService</code>则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。<br>最下层的实现类<code>ThreadPoolExecutor</code>实现最复杂的运行部分。一方面维护自身的生命周期，另一方面管理线程和任务，使两者良好的结合从而执行并行任务。<br><code>ThreadPoolExecutor</code>运行流程如下：<br><img src="ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""><br>线程池内部构建了一个生产者消费者模型，将线程与任务解耦，并不直接关联，从而良好的缓冲任务，复用线程。<br>任务管理充当生产者，任务提交后，线程池会进行后续的判断：是直接申请线程执行任务，还是将其加入到阻塞队列进行等待，亦或是直接拒绝该任务。<br>线程管理则充当消费者，根据任务的请求进行线程的分配，执行完任务又会继续获取新的任务，直到任务全部获取完成，对线程进行回收。</p>
<hr>
<h3 id="线程池生命周期"><a href="#线程池生命周期" class="headerlink" title="线程池生命周期"></a>线程池生命周期</h3><p><code>ThreadPoolExecutor</code>的运行状态有5种：<br><img src="ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81.png" alt=""><br>生命周期转换图如下：<br><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p>
<hr>
<h3 id="任务执行机制"><a href="#任务执行机制" class="headerlink" title="任务执行机制"></a>任务执行机制</h3><p>前面提到了任务提交后线程会进行判断如何处理任务，其主要执行机制如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是<code>RUNNING</code>，则直接拒绝，线程池要保证在<code>RUNNING</code>的状态下执行任务。</li>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中，该任务会等到线程空闲时执行。</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据<strong>拒绝策略</strong>来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>流程图如下：<br><img src="%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt=""></p>
<hr>
<h3 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h3><p>任务缓冲模块是线程池管理任务的核心部分。线程池的作用是将任务与线程解耦，再对任务进行分配。线程池是通过<strong>阻塞队列</strong>来实现的。阻塞队列对任务进行缓存，线程则从阻塞队列取出任务执行。<br>阻塞队列是一个双端队列，生产者往队列添加元素，消费者从队列取出元素。使用不同的队列可以实现不同的任务存取策略：<br><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%88%90%E5%91%98.png" alt=""></p>
<hr>
<h3 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h3><p>任务进行提交后，执行的情况有两种：一种是线程池直接创建一个线程执行该任务，另一个是从阻塞队列中获取任务并执行，该线程执行完任务会继续从阻塞队列中获取任务执行。前者这种情况仅出现在线程初始创建的时候，后者是大多数情况。<br>这部分策略由<code>getTask</code>方法实现，其执行流程如下图：<br><img src="%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt=""></p>
<hr>
<h3 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h3><p>任务拒绝模块是线程池的保护策略，当阻塞队列已满，且线程池中的线程数目已达到<code>maximumPoolSize</code>时，线程池就会根据拒绝策略处理新的任务。<br>用户可以自定义拒绝策略，也可以选择JDK提供的4中拒绝策略：<br><img src="%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png" alt=""></p>
<hr>
<h3 id="worker线程"><a href="#worker线程" class="headerlink" title="worker线程"></a>worker线程</h3><p>…</p>
<hr>
<h3 id="线程池几个重要的方法"><a href="#线程池几个重要的方法" class="headerlink" title="线程池几个重要的方法"></a>线程池几个重要的方法</h3><blockquote>
<p>execute()<br>submit()<br>shutdown()<br>shutdownNow()</p>
</blockquote>
<h4 id="execute-和-submit-区别"><a href="#execute-和-submit-区别" class="headerlink" title="execute() 和 submit() 区别"></a>execute() 和 submit() 区别</h4><p><code>submit()</code>有返回值，<code>execute()</code>无返回值。</p>
<h4 id="shutdown-和-shutdownNow-区别"><a href="#shutdown-和-shutdownNow-区别" class="headerlink" title="shutdown() 和 shutdownNow() 区别"></a>shutdown() 和 shutdownNow() 区别</h4><p><code>shutdown()</code>和<code>shutdownNow()</code>是用来关闭线程池的。<br><code>shutdown()</code>: 此方法执行后不得向线程池再提交任务，如果有空闲线程则销毁空闲线程，等待所有正在执行的任务及位于阻塞队列中的任务执行结束，然后销毁所有线程。<br><code>shutdownNow()</code>: 此方法执行后不得向线程池再提交任务，如果有空闲线程则销毁空闲线程，取消所有位于阻塞队列中的任务，并将其放入List容器，作为返回值。取消正在执行的线程(设置正在执行线程的中断标志位,调用线程的<code>interrupt</code>方法来中断线程)。</p>
<hr>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
</search>
