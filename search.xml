<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap底层实现原理</title>
    <url>/2020/07/28/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>记录HashMap底层实现原理。(基于JDK 1.8)</p>
<a id="more"></a>
<h3 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h3><p>HashMap是基于哈希表的Map接口的非同步实现，其键值都允许<code>null</code>值。此类并不保证映射的顺序。<br>由于HashMap的<strong>非同步性</strong>，如果多线程同时访问HashMap，外部进行修改等操作必须保证同步。</p>
<hr>
<h3 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h3><p>HashMap是基于<strong>数据+链表</strong>的一种数据结构。HashMap底层就是一个数据，而数据中的每一项又是一个链表。<br>当进行<code>put</code>操作时，通过内部定义的算法找到数组的下标，直接将数据放到此位置。若是遇到了<strong>Hash冲突</strong>，将会对这个数组元素的链表进行遍历，将新数据放到链表末尾。</p>
<hr>
<h3 id="存储数据的对象"><a href="#存储数据的对象" class="headerlink" title="存储数据的对象"></a>存储数据的对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>Node</code>相当于数组中的元素，每一个元素相当于一个键值对，而它持有指向下一个元素的<code>next</code>指针，这就构成了链表。<br>hash：通过<strong>hash算法</strong>算出来的值。hash算法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>hashCode()</code>函数是Key自带的方法，返回一个int类型的散列值。<br>而元素的下标是通过<code>h &amp; (length - 1)</code>得到的，这也解释了为什么HashMap数组的长度永远是2的整数幂。<br>首先，当长度为2的整数幂时，<code>h &amp; (length - 1)</code>相当于hash函数的值对数组的长度取模，实现均匀分布。而<code>&amp;</code>比<code>%</code>效率更高。<br>其次，长度为2的整数幂时，可以使下标的分布更加松散。举个例子，当长度为初始值16时，<code>length - 1</code>最低位为1，在与hash函数的值<code>&amp;</code>时，最低位可以是0或1。反之最低位为0，<code>&amp;</code>后最低位则一定为0。这将导致有许多位置永远不可能存放元素，浪费了空间也增加了碰撞概率。<br>但即使是这样，如果数组长度较小，<code>&amp;</code>后也只与最低几位相关，碰撞的几率仍然很大，这时hash函数就体现了作用。将hash函数值右移16位再与自己异或，增加了低位的随机性，也变相保留了高位的信息。</p>
<hr>
<h3 id="HashMap性能参数"><a href="#HashMap性能参数" class="headerlink" title="HashMap性能参数"></a>HashMap性能参数</h3><p>HashMap有几个重要的参量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="keyword">int</span> modCount;  </span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<ol>
<li>threshold: 数组允许的最大存储数量，由<code>数组长度 * loadFactor</code>得到。超过时数组会进行扩容。</li>
<li>loadFactor: 增长因子。默认为<code>0.75</code>。太大会增加碰撞几率，太小则会浪费空间。</li>
<li>modCount: 记录内部结构发生变化的次数。put(覆盖不算)以及其他…</li>
<li>size: 实际存储的元素个数。</li>
</ol>
<hr>
<h3 id="put以及resize流程"><a href="#put以及resize流程" class="headerlink" title="put以及resize流程"></a>put以及resize流程</h3><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p><img src="HashMap_put%E6%B5%81%E7%A8%8B.png" alt=""><br>这里有两个参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>JDK 1.8对HashMap进行了优化，如果碰撞的次数大于8次，此时数组的长度如果小于64，会进行扩容；否则数组元素上的链表会转变为红黑树，提高查询的效率。而碰撞次数减少到6次时，红黑树将会重新变为链表。</p>
<p>红黑树具有以下几个性质：</p>
<ol>
<li>每个结点要么是黑色，要么是红色</li>
<li>根结点是黑色的。</li>
<li>每个叶子结点是黑色的。</li>
<li>每个红色结点的两个子结点是黑色的。</li>
<li>任意一结点到每个叶子结点都包含相同数量的黑结点。</li>
</ol>
<p><img src="%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" alt=""></p>
<h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p>当需要存储的元素大于<code>threshold</code>时，数组会进行扩容，扩大为原来的两倍，此时数组中的元素需要重新计算下标。这里JDK 1.8进行了优化，不再需要重新计算hash值，而是，数组元素的链表中的第一个值的下标不发生变化，其它的通过<code>e.hash &amp; oldCap != 0</code>将其放到<code>[原始下标+原始数组长度]</code>的下标。<br><img src="HashMap_resize%E6%B5%81%E7%A8%8B.png" alt=""></p>
<hr>
<h3 id="线程安全问题以及Fail-Fast机制"><a href="#线程安全问题以及Fail-Fast机制" class="headerlink" title="线程安全问题以及Fail-Fast机制"></a>线程安全问题以及Fail-Fast机制</h3><p>HashMap是非线程安全的，如果在访问元素的过程中修改了HashMap，将会抛出<code>ConcurrentModificationException</code>异常，也就是所谓的Fail-Fast机制。<br>此机制是通过<code>modCount</code>参量实现的。<code>modCount</code>在源码中声明为<code>volatile</code>，保证了线程之间的可见性。通过检测<code>modCount</code>是否与预期值相等，如果不等说明在访问的过程中修改了HashMap中的值，则会抛出异常。<br>然而此机制只能检测却不能解决线程安全问题。想要保证线程安全需要用到<code>ConcurrentHashMap</code>。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域与模型</title>
    <url>/2020/06/24/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<a id="more"></a>
<h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><p><img src="Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt=""><br>其中方法区、堆是所有线程共享的，其余则是线程私有的。</p>
<ol>
<li>程序计数器<br>程序计数器是一块较小的内存空间。JVM字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。<br>因为在任何时刻，一个处理器都只会执行一条线程的指令，并且通过不断地切换线程来实现多线程。所以对于每个独立的线程，为了在切换后能恢复到正确地执行位置，都需要一个程序计数器，各条线程互不影响，独立存储。因而它是<strong>线程私有</strong>的。</li>
<li>虚拟机栈<br>虚拟机栈也是<strong>线程私有</strong>的，其生命周期与线程相同。每个方法被执行时，Java虚拟机都会同步创建一个栈帧用来存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>本地方法栈<br>作用与虚拟机栈非常类似，区别只是虚拟机栈为Java方法服务，而本地方法栈是为本地(Native)方法服务。</li>
<li>堆(heap)<br>堆是虚拟机管理的内存中最大的一块。堆是<strong>所有线程共享</strong>的一块区域，在虚拟机启动时创建。堆唯一目的就是存放对象实例。Java几乎所有的对象实例和数组都在堆分配内存。然而随着即时编译器的优化，一些如逃逸分析的技术，使得对象实例也不一定都是分配在堆上了。<br>堆还是垃圾收集器管理的内存区域，因此也被称作<code>GC堆</code>。关于这部分内容后面会详细讲解。<br>Java堆可以被实现成固定大小的，也可以是可扩展的。不过当前主流虚拟机都是按可扩展来实现的，可通过设置相关参数来设定。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<code>OutOfMemoryError</code>异常。</li>
<li>方法区<br>方法区也是<strong>线程共享</strong>的区域。它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。<br>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。<br>同时，<strong>运行时常量池</strong>也是方法区的一部分，它主要用于存放编译期间生成的各种字面量与符号引用，当类加载后存放到运行时常量池。它有一个特点是运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</li>
</ol>
<hr>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="并发编程模型"><a href="#并发编程模型" class="headerlink" title="并发编程模型"></a>并发编程模型</h4><p>在并发编程中，我们需要解决两个关键问题：线程之间如何通信以及线程之间如何同步。<br>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>。<br>在共享内存的并发模型里，线程之间通过写-读内存中的公共状态来<strong>隐式</strong>进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的信息来显式进行通信。<br>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br><strong>Java的并发采用的是共享内存模型</strong>。Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h4 id="Java内存模型-1"><a href="#Java内存模型-1" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>Java线程之间的通信由Java内存模型(JMM)控制，JMM决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度看，JMM决定了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存存储了该线程以读/写共享变量的副本。<br>Java 内存模型的抽象示意图如下：<br><img src="Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt=""><br>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<h4 id="Java内存模型的实现"><a href="#Java内存模型的实现" class="headerlink" title="Java内存模型的实现"></a>Java内存模型的实现</h4><p><img src="Java%E5%A0%86%E6%A0%88.jpeg" alt=""><br>JVM中运行的每个线程都拥有自己的<strong>线程栈</strong>，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。线程栈是线程私有的。<br>所有的原始类型的局部变量都保存在线程栈中，每个线程都是独立的，一个线程可以通过传递副本给另一个线程，但它们之间无法共享。<br>堆区则包含了Java应用创建的所有对象信息。它是线程共享的。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量。<br>一个本地变量如果是原始类型，那么它会被完全存储到栈区。<br>一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。<br>对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。<br>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。<br>Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。<br><img src="Java%E5%A0%86%E6%A0%88%E5%AD%98%E5%82%A8.jpeg" alt=""></p>
<h4 id="硬件内存结构"><a href="#硬件内存结构" class="headerlink" title="硬件内存结构"></a>硬件内存结构</h4><p>现代计算机一般都有2个以上CPU，而且每个CPU还有可能包含多个核心。因此，如果我们的应用是多线程的话，这些线程可能会在各个CPU核心中并行运行。<br>在CPU内部有一组CPU寄存器，也就是CPU的储存器。CPU操作寄存器的速度要比操作计算机主存快的多。在主存和CPU寄存器之间还存在一个CPU缓存，CPU操作CPU缓存的速度快于主存但慢于CPU寄存器。某些CPU可能有多个缓存层（一级缓存和二级缓存）。计算机的主存也称作RAM，所有的CPU都能够访问主存，而且主存比上面提到的缓存和寄存器大很多。<br>当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存，进而在读取CPU缓存到寄存器。当CPU需要写数据到主存时，同样会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主存。<br>Java内存模型与硬件结构的关系如下图所示：<br><img src="Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB.jpeg" alt=""></p>
<hr>
<h3 id="volatile变量特性"><a href="#volatile变量特性" class="headerlink" title="volatile变量特性"></a>volatile变量特性</h3><h4 id="volatile变量的可见性"><a href="#volatile变量的可见性" class="headerlink" title="volatile变量的可见性"></a>volatile变量的可见性</h4><p>当一个变量被定义成volatile之后，它将具备两项特性：第一项是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。</p>
<h4 id="volatile变量禁止指令重排序"><a href="#volatile变量禁止指令重排序" class="headerlink" title="volatile变量禁止指令重排序"></a>volatile变量禁止指令重排序</h4><p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，但不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。而volatile变量可以通过<strong>内存屏障</strong>来保证特定操作的执行顺序。<br>由于编译器和处理器都能执行指令重排序优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本，也就实现了可见性。</p>
<hr>
<h3 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性指的是一个操作是不可中断的。由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。之前说到的<code>volatile</code>就可以保证可见性。除了<code>volatile</code>，<code>synchronized</code>和<code>final</code>也可以实现可见性。<br>同步块的可见性是由<strong>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）</strong>这条规则获得的。<br>而被<code>final</code>修饰的字段在构造器中一旦被初始化完成，并且构造器没有把”this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到<strong>初始化了一半</strong>的对象），那么在其他线程中就能看见final字段的值。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>Java语言提供了<code>volatile</code>和<code>synchronized</code>两个关键字来保证线程之间操作的有序性。<code>volatile</code>关键字本身就包含了禁止指令重排序的语义，而<code>synchronized</code>则是由<strong>一个变量在同一个时刻只允许一条线程对其进行lock操作</strong>这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
<hr>
<h3 id="先行发生-happens-before-原则"><a href="#先行发生-happens-before-原则" class="headerlink" title="先行发生(happens-before)原则"></a>先行发生(happens-before)原则</h3><p>happens-before原则是判断数据是否存在竞争，线程是否安全的非常有用的手段。其原则内容如下：</p>
<ol>
<li>程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是”同一个锁”，而”后面”是指时间上的先后。</li>
<li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。</li>
<li>线程启动规则：Thread对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li>
<li>线程中断规则：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测。</li>
<li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li>传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。</li>
</ol>
<hr>
<p>参见《深入理解Java虚拟机》。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Java单例模式</title>
    <url>/2020/06/22/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式：在程序运行期间，某些类<strong>有且最多只有一个</strong>实例对象。<br>本文记录几种不同的Java单例模式实现方案以及它们的优缺点。</p>
<a id="more"></a>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>饿汉模式，顾名思义，JVM在加载这个类的时候就会完成这个单例的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量在类创建的时候就会初始化，设置成final类型直接创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：线程安全，类加载只加载一次，即使是多线程也不会创建多个实例。<br>缺点：这种方法在用户调用<code>getInstance()</code>方法之前就已经完成了单例的创建。如果这个实例的创建需要依赖用户输入的参数或者配置文件，那么这种方法就不好使了。</p>
<hr>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>为了解决上面的问题，有了懒汉模式。顾名思义就是在等用户真正需要用到这个实例的时候才创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>优点：解决了懒汉模式的问题，也节省了空间，用户没调用这个类时不会创建实例。<br>缺点：线程不安全。当多个线程同时执行<code>getInstance()</code>方法时，会得到多个实例，违背了单例模式的要求。</p>
<p>于是需要将<code>getInstance()</code>方法内部代码设置同步代码块(synchronized)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>为什么要加双重锁呢？<br>因为多线程有可能同时执行到了<code>1</code>的位置，这时一个线程进入了同步代码块，创建完了实例，释放锁，于是又有一个线程进入了同步代码块，如果没有再次判断实例是否已经创建，此线程也会新创建一个实例，而这两个实例将不会是同一个实例。<br>只有在<code>synchronized</code>内部再次检查一次，才能保证单例。</li>
<li>为什么实例要设置为<code>volatile</code>？<br>看起来代码已经很完美，但其实<code>instance = new Singleton();</code>这句话在执行时并非一个原子操作。它其实做了下面3件事情。<blockquote>
<ol>
<li>给instance分配内存</li>
<li>调用SingleTon构造函数初始化成员变量</li>
<li>将instance引用指向分配的内存空间</li>
</ol>
</blockquote>
</li>
</ol>
<p>在JVM即时编译器中，存在着指令重排序的优化。也就是说，如果上述3个步骤可能的执行顺序是1-&gt;3-&gt;2。对于这种情况，如果一个线程执行到了这句话的1和3两个指令，由于<code>instance</code>已经被分配了内存，此时已不再是<code>null</code>了。这时如果有另一个线程执行到了<code>2</code>的位置，将会直接判定<code>instance</code>不为空，将其返回使用。然而这个<code>instance</code>还没有初始化呢，所以会造成错误。<br>而<code>volatile</code>可以防止指令重排序。它在变量的赋值操作后会设置一个<strong>内存屏障</strong>，读取操作只能等到上述3个指令执行完毕。也就是<strong>happens-before</strong>原则。</p>
<p>优点：线程安全，懒汉式加载。<br>缺点：代码较复杂。</p>
<hr>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当JVM在加载类的时候，是不会加载其内部类的。这点在《深入理解Java虚拟机》中有详细讲述。只有当这个类的某个静态变量被调用时才会触发类的初始化。<br>也就是执行了<code>getInstance()</code>方法时才会初始化<code>SingletonHolder</code>类。<br>由于JVM本身的机制已经保证了线程安全的问题，所以这是一个线程安全的、懒汉式加载的方法，且实现简单。</p>
<hr>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用枚举实现实在太简单了，且枚举默认就是线程安全的。而且，其余几种方式其实都存在缺点：如果通过反射或者反序列化攻击，还是会生成多个实例。<br>利用枚举的特性，就可以完全规避这些问题。它是单例模式实现中的<strong>唯一</strong>一种不会被破坏的实现。</p>
<hr>
<h3 id="防止单例模式被破坏的方法"><a href="#防止单例模式被破坏的方法" class="headerlink" title="防止单例模式被破坏的方法"></a>防止单例模式被破坏的方法</h3><ol>
<li>反射破坏的方式是通过强行调用私有的构造方法生成新的对象，所以只要在构造方法里面判断一下就好了。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"实例已经存在，请通过getInstance()方法获取。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果单例模式实现了序列化接口，那么就可以通过反序列化进行破坏。所以可以不实现序列化接口，或者重写反序列化方法<code>readResolve()</code>，直接返回单例对象。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>Java单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收机制</title>
    <url>/2020/07/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>垃圾回收是JVM非常重要的机制之一。本文记录一下。</p>
<a id="more"></a>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是在JVM启动时创建的，运行过程中创建的对象和数组几乎都储存在这块区域。而Java的垃圾回收也主要针对这块区域。如果我们动态创建的对象没有得到及时回收，最后可能导致内存溢出。<br>因此垃圾回收机制会在后台创建一个守护进程，在内存紧张时会自动对垃圾进行回收，以保证程序正常的运行。</p>
<hr>
<h3 id="对象已死"><a href="#对象已死" class="headerlink" title="对象已死"></a>对象已死</h3><p>垃圾回收器在对堆进行回收时，第一件事就是确定哪些对象还”存活”着，哪些已经”死去”（”死去”意味着不能再用任何方式使用该对象）。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。<br>但是，这种方案存在严重的漏洞，就是无法检测对象的互相引用。当两个对象相互引用，即使它俩都不再被其他任何东西引用，它们的计数也不为零，所以JVM不会回收它们。但实际上，这两个对象已经没有用处了。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>当前主流的程序语言的无存管理子系统，都是通过可达性分析算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为<code>GC Roots</code>的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为<strong>引用链</strong>，如果某个对象到<code>GC Roots</code>间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。<br>例如下图：<br><img src="%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt=""><br>首先，GC Roots一定是可达的，其次，固定可作为GC Roots的对象包括以下几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些异常对象（如OutOfMemoryError）等，还有系统类加载器。</li>
<li>被同步锁持有的对象</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
<hr>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>JDK 1.2后，Java将引用分为<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>和<strong>虚引用</strong>。</p>
<ol>
<li>强引用<br>强引用是传统的引用的定义，指程序代码中普遍存在的引用赋值，类似<code>Object obj = new Object()</code>这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用<br>软引用用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了<code>SoftReference</code>类来实现软引用。</li>
<li>弱引用<br>弱引用的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了<code>WeakReference</code>类来实现弱引用。</li>
<li>虚引用<br>虚引用也被称为”幽灵引用”，它是最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了<code>PhantomReference</code>类来实现虚引用。</li>
</ol>
<hr>
<h3 id="生存or死亡"><a href="#生存or死亡" class="headerlink" title="生存or死亡"></a>生存or死亡</h3><p>即使在可达性分析算法中被判定为不可达的对象，也并非”非死不可”的。要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。假如对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为”没有必要执行”。<br>如果对象被判定为有必要执行<code>finalize()</code>方法，它将被放置在名为<code>F-Queue</code>的队列中，虚拟机会创建一个低调度优先级的线程去执行。这里的执行是指虚拟机会触发<code>finalize()</code>方法的执行，但不会承诺一定会等待它运行结束。原因是如果某个对象的<code>finalize()</code>方法执行缓慢或者陷入死循环，那么队列中的其他对象将一直处于等待，可能导致系统的崩溃。<br><code>finalize()</code>方法是对象最后一次”拯救”自己的机会，收集器将对队列中的对象进行第二次小规模的标记，这时只要<strong>将对象与任何一个引用链上的对象建立关联</strong>即可不被回收，否则就真的要被回收了。<br>此时如果再执行一次上述过程，对象将无法再一次”拯救”自己，这是因为任何一个对象的<code>finalize()</code>方法都只会被系统自动调用一次。</p>
<hr>
<h3 id="方法回收区"><a href="#方法回收区" class="headerlink" title="方法回收区"></a>方法回收区</h3><p>方法区的垃圾收集主要回收<strong>废弃的常量</strong>和<strong>不再使用的类型</strong>。<br>回收废弃常量与回收Java堆中的对象非常类似。如果没有任何字符串对象引用常量池中的常量，且虚拟机中也没有其他地方引用这个字面量，此时如果发生内存回收，就会将这个常量清出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。<br>而判断一个类型是否属于不再被使用的类则需要满足三个条件：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<hr>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>分代收集理论建立在两个分代假说之上：</p>
<ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。<br>因而Java堆会被分为<strong>新生代</strong>和<strong>老年代</strong>两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。<br>然而这种分代收集存在一个明显的困难：对象不是孤立的，<strong>对象之间会存在跨代引用</strong>。<br>比如现在进行一次局限于新生代区域内的收集。但其中的对象完全有可能被老年代所引用，这时就不得不再遍历老年代中所有对象来确保其可达性，反过来也一样。虽然这样可行，但会带来很大的性能负担。因此分代收集理论需要第三条法则：</p>
<ul>
<li>跨代引用假说：跨代引用相对于同代引用来说只占极少数。</li>
</ul>
<p>存在互相引用关系的两个对象，应该倾向于同时生存或同时消亡的。比如，某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。<br>因此我们不再为了少量的跨代引用扫描整个老年代，而是在新生代上建立一个<strong>记忆集</strong>，把老年代分为若干小块，标识出老年代哪块存在跨代引用。此后发生新生代收集时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>此算法首先标记出所有需要回收的对象，完成后统一回收掉所有被标记的对象。<br>这个算法有两个缺点：一是<strong>执行效率不稳定</strong>，如果堆中有大量需要回收的对象，那就需要进行大量的标记和清除的动作，执行效率会降低；二是内存空间的碎片化，<strong>标记清除后会产生大量不连续的内存碎片</strong>，这可能导致以后分配较大对象时找不到足够的连续内存而不得不触发另一次垃圾收集动作。<br><img src="%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt=""></p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>这种算法将可用内存分为容量相等的两块，每次只使用一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。<br>现在的商用Java虚拟机大多优先采用这种算法回收新生代。由于新生代中约98%的对象熬不过第一轮收集，因此不需要按照1:1的比例来划分空间。<br>常见的做法是分为<code>8:1:1</code>这样一块较大的Eden空间和两块较小的Survivor空间。工作原理如下：</p>
<ol>
<li><code>Eden</code>区最大，对外提供内存。当<code>Eden</code>区快满时，进行收集，把存活的对象存入<code>Survivor A</code>区，清空<code>Eden</code>区，继续对外提供内存。</li>
<li><code>Eden</code>区再次快满时，对<code>Eden</code>和<code>Survivor A</code>区同时回收，把存活对象存入<code>Survivor B</code>区，清空<code>Eden</code>和<code>Survivor A</code>区，<code>Eden</code>继续对外提供内存，重复上述过程。</li>
<li>当某个<code>Survivor</code>区被填满时仍有对象未被复制完毕时，就把这部分对象放入老年区。</li>
<li>当老年区也被填满时，则开始对老年区进行回收。</li>
</ol>
<p>可以看到这种算法适用于新生代的收集。<br><img src="%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt=""></p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。这样就没有碎片了。<br>这种算法适用于老年代的收集：只需清理少量的垃圾，剩下的进行移动就可以了。<br><img src="%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt=""></p>
<hr>
<p>参见《深入理解Java虚拟机》。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识点</title>
    <url>/2020/08/06/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>记录一些遇到过的Java基础知识点。（持续更新）</p>
<a id="more"></a>
<h4 id="Java基本数据类型图"><a href="#Java基本数据类型图" class="headerlink" title="Java基本数据类型图"></a>Java基本数据类型图</h4><p><img src="Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpeg" alt=""></p>
<hr>
<h4 id="a-a-b-与-a-b"><a href="#a-a-b-与-a-b" class="headerlink" title="a = a + b 与 a += b"></a>a = a + b 与 a += b</h4><p>举例：<code>short a = 1; a = a + 1;</code>因为 1 为整型，<code>a + 1</code>也为整形，所以需要强制转换成<code>short</code>类型才能赋值。<br>而<code>short a = 1; a += 1;</code>则不需要强制转换，因为<code>+=</code>含有隐式的类型转换，可以自动转型为<code>short</code>。</p>
<hr>
<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ol>
<li><code>private</code>: 当前类可见。不能修饰类</li>
<li><code>default(缺省)</code>: 同包可见。</li>
<li><code>protected</code>: 同包内的类以及所有子类可见。不能修饰类。</li>
<li><code>public</code>: 所有类可见。<h5 id="图"><a href="#图" class="headerlink" title="图"></a>图</h5><img src="%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6.jpeg" alt=""></li>
</ol>
<hr>
<h4 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h4><ol>
<li>被<code>final</code>修饰的类不可以被继承</li>
<li>被<code>final</code>修饰的方法不可以被重写</li>
<li>被<code>final</code>修饰的变量不可以被改变。被<code>final</code>修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的。</li>
</ol>
<hr>
<h4 id="普通类与抽象类"><a href="#普通类与抽象类" class="headerlink" title="普通类与抽象类"></a>普通类与抽象类</h4><ol>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ol>
<hr>
<h4 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h4><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<ol>
<li><strong>重载</strong>：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），<strong>与方法返回值和访问修饰符无关</strong>，即重载的方法不能根据返回类型进行区分。</li>
<li><strong>重写</strong>：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</li>
</ol>
<hr>
<h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h5><ol>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ol>
<p>总的来说，Java IO流是从以下四个抽象类中派生出来的。</p>
<ol>
<li><code>InputStream/Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream/Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ol>
<hr>
<h4 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="BIO、NIO、AIO"></a>BIO、NIO、AIO</h4><ol>
<li><code>BIO</code>: 同步阻塞模式。线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。</li>
<li><code>NIO</code>: 同步非阻塞的IO模型。线程发起IO请求后，立即返回（非阻塞IO）。同步指的是必须等待IO缓冲区内的数据就绪，而非阻塞指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时<strong>轮询</strong>检查IO缓冲区数据是否就绪。</li>
<li><code>AIO</code>: 异步非阻塞IO模型。基于事件和回调机制而实现，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ol>
<hr>
<h4 id="String-str-“i”-与-String-str-new-String-“i”"><a href="#String-str-“i”-与-String-str-new-String-“i”" class="headerlink" title="String str = “i” 与 String str = new String(“i”)"></a>String str = “i” 与 String str = new String(“i”)</h4><p>内存分配的方式不同。<code>String str = &quot;i&quot;</code>JVM会将其分配到常量池；另一种会分配到堆内存中。</p>
<hr>
<h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="number">3</span>;  <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">System.out.println(a == c); <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">System.out.println(b == c); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer a1 = <span class="number">128</span>;</span><br><span class="line">Integer b1 = <span class="number">128</span>;</span><br><span class="line">System.out.println(a1 == b1); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Integer a2 = <span class="number">127</span>;</span><br><span class="line">Integer b2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(a2 == b2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果整型字面量的值在<code>-128</code>到<code>127</code>之间，那么自动装箱时不会创建新的<code>Integer</code>对象，而是直接引用常量池中的Integer对象；超过范围时会创建新对象，因此<code>a2 == b2</code>返回<code>false</code>。</p>
<hr>
<h4 id="strictfp关键字"><a href="#strictfp关键字" class="headerlink" title="strictfp关键字"></a>strictfp关键字</h4><p><code>strictfp</code>可以用来修饰类、接口和方法。在所声明的范围内，所有浮点数的计算都是精确的。当一个类被<code>strictfp</code>修饰时，所有方法默认也被<code>strictfp</code>修饰。</p>
<h4 id="单精度、双精度"><a href="#单精度、双精度" class="headerlink" title="单精度、双精度"></a>单精度、双精度</h4><p><img src="%E5%8D%95%E7%B2%BE%E5%BA%A6%E3%80%81%E5%8F%8C%E7%B2%BE%E5%BA%A6.png" alt=""></p>
<hr>
<h4 id="Java对象内存分配如何保证线程安全"><a href="#Java对象内存分配如何保证线程安全" class="headerlink" title="Java对象内存分配如何保证线程安全"></a>Java对象内存分配如何保证线程安全</h4><ul>
<li><code>CAS</code></li>
<li><code>TLAB(Thread Local Allocation Buffer)</code>：每个线程在Java堆中预分配一小块内存，在给对象分配内存时，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载器</title>
    <url>/2020/06/22/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<p>Java类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p>
<a id="more"></a>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>Java类加载器就是在类加载这个阶段通过类的全限定名获取定义此类的二进制字节流。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。<br>也就是说，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<hr>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>自从JDK1.2以来，Java一直保持着<strong>三层类加载器</strong>、<strong>双亲委派的类加载结构</strong>。<br>绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载。</p>
<ol>
<li>启动类加载器。这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</li>
<li>扩展类加载器。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li>
<li>应用程序类加载器。它负责加载用户类路径（ClassPath）上所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
<p>这三层类加载器的协作关系通常如下图所示，一般被称为<strong>双亲委派模型</strong>。<br><img src="%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt=""><br>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。<br>其工作原理是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。<br>这种工作机制的好处是：可以提高系统的安全性。例如Object类始终是由最上层加载器加载的，如果用户自定义了一个Object类，是不会被最顶层的启动类加载器加载运行的。这也防止了恶意代码对系统的破坏。</p>
<hr>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>然而，双亲委派模型并不是一种具有强制约束性的模型。这意味着它是可以被”破坏”的。<br>那么为什么要破坏双亲委派模型呢？例如JDBC，原生的JDBC中Driver驱动只是一个接口，具体的实现是由不同的数据库进行实现的，比如mysql有自己的实现，oracle也有自己的实现。这时就需要Driver动态的去加载不同数据库的实现，然而由于Driver是由启动类加载器加载的，它并不能加载到用户具体的实现，所以这时就需要打破双亲委派模型，由父类加载器去请求子类加载器完成类加载。<br>此时引入了<strong>线程上下文类加载器</strong>，把原本需要由启动类加载器加载的类，委派给了应用程序类加载器进行加载。</p>
<p>如果用户想要自定义类加载器，有两种方法。</p>
<ol>
<li>重写ClassLoader中的loadClass()方法，不过这将破坏双亲委派的模型。</li>
<li>重写findClass()方法。这个方法不会破坏双亲委派模型。这也是Java预留给开发者的方法。</li>
</ol>
<hr>
<p>参见《深入理解 java 虚拟机》。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>/2020/06/20/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行<strong>校验、转换解析和初始化</strong>，最<br>终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
<a id="more"></a>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。<br>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有:<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_n_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。<br>例如以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行后，只会输出”SuperClass init!”，而不会输出”SubClass init!”。<br>因为对于静态字段，只有直接定义这个字段的类才会被初始化。所以对于上述代码子类不会被初始化。</p>
<p>再如，对上述<code>SuperClass</code>类，如果有以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后依然没有输出”SuperClass init!”。说明通过数组定义来引用类，不会触发类的初始化。</p>
<p>还有一种是调用类的常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量在编译阶段会存入调用类的<strong>常量池</strong>中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。<br>而接口的加载过程与类加载过程稍有不同。接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器，用于初始化接口中所定义的成员变量。<br>一个接口在初始化时，并不要求父接口都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>
<hr>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><ol>
<li><p><strong>加载</strong><br>在加载阶段，Java虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
</li>
<li><p><strong>验证</strong><br>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。<br>验证阶段大致上会完成下面四个阶段的检验动作：<strong>文件格式验证、元数据验证、字节码验证和符号引用验证。</strong></p>
<ul>
<li>文件格式验证。主要验证字节流是否符合Class文件格式的规范。比如魔数开头、版本号、常量类型等等问题。</li>
<li>元数据验证。对字节码描述的信息进行语义分析。比如一个类是否有父类、是不是抽象类等等。</li>
<li>字节码验证。主要通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。比如保证类中的方法体在运行时不会危害虚拟机。</li>
<li>符号引用验证。发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</li>
</ul>
</li>
<li><p><strong>准备</strong><br>准备阶段是正式为类中定义的变量（即<strong>静态变量</strong>，被static修饰的变量）分配内存并设置类变量初始值的阶段。<br>也就是说，<strong>实例变量</strong>在这个阶段是不会被初始化的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>对于以上两行代码，只有第一行会执行并初始化值为0。赋值为123要等到类的初始化阶段才会执行。<br>然而也有特殊情况，比如，如果上述<code>value</code>字段被<code>final</code>修饰，那么在这一阶段将会被直接赋值为123。</p>
</li>
<li><p><strong>解析</strong><br>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。JVM针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类引用进行解析。</p>
</li>
<li><p><strong>初始化</strong><br>到了这个阶段，Java虚拟机才真正开始执行类中编写的Java代码。在这个阶段，JVM会对类进行初始化。具体场景在前面<strong>类加载的时机</strong>已经描述。</p>
</li>
<li><p><strong>使用</strong><br>JVM完成初始化后，便从入口方法开始执行代码。</p>
</li>
<li><p><strong>卸载</strong><br>执行完程序代码后，JVM开始销毁创建的Class对象，最后JVM也退出内存。</p>
</li>
</ol>
<hr>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandPa</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"grandpa代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"grandpa静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrandPa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"grandpa构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandPa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"father静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"father代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"son静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，输出是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grandpa静态代码块</span><br><span class="line">father静态代码块</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>首先程序找到main方法，程序输出Son类的age类变量，但是由于Son类并没有直接定义这个变量，于是往父类找，触发了Father类初始化。<br>接着根据<strong>类加载的时机</strong>第3条<strong>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</strong>所以又会触发GrandPa类的初始化。<br>最后再输出Father类中age的值30。</p>
<p>再看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Test静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Test代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test构造器"</span>);</span><br><span class="line">        System.out.println(<span class="string">"age: "</span> + age + <span class="string">" weight: "</span> + weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> weight = <span class="number">120</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码输出是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test代码块</span><br><span class="line">Test构造器</span><br><span class="line">age: <span class="number">20</span> weight: <span class="number">0</span></span><br><span class="line">Test静态代码块</span><br><span class="line">Test静态方法</span><br></pre></td></tr></table></figure>

<p>之前那个例子，main方法所在的类没有多余的代码，所以忽略了类的初始化。这个例子就不同了。<br>首先在准备阶段，会为类变量分配内存，初始化值。<code>test</code>实例变量被初始化为null，<code>weight</code>类变量初始化为0。<br>接着进入初始化阶段，首先初始化类构造器，也就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Test静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> weight = <span class="number">120</span>;</span><br></pre></td></tr></table></figure>
<p>首先执行第一句，触发了类的实例化。于是执行对象构造器，也就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"Test代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Test构造器"</span>);</span><br><span class="line">    System.out.println(<span class="string">"age: "</span> + age + <span class="string">" weight: "</span> + weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>对于以上代码，JVM先初始化代码块，然后初始化变量，最后是构造器。所以先打印了<code>Test代码块</code>，为<code>age</code>赋值20，然后打印<code>Test构造器</code>。<br>接着，打印<code>age: 20 weight: 0</code>，因为<code>age</code>已被赋值，但是<code>weight</code>目前只在准备阶段被赋了0。<br>执行完对象构造器，接着执行类构造器第二句，打印<code>Test静态代码块</code>，然后初始化<code>weight</code>为120。<br>此时已完成类的初始化，开始执行main方法，执行run方法输出<code>Test静态方法</code>。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java中的静态变量和静态代码块在类加载的时候就会执行，执行顺序与代码书写顺序一致。然后执行对象构造器，构造函数最后执行，其余按书写顺序。如果子类继承了父类，则会先进行父类的初始化。</p>
<hr>
<p>参见《深入理解 java 虚拟机》。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程安全与锁</title>
    <url>/2020/06/25/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81/</url>
    <content><![CDATA[<p>本文记录Java线程安全有关问题以及Java的各种锁。</p>
<a id="more"></a>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>Java线程安全可按照安全程度排序，主要可分为5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<ol>
<li>不可变<br>JDK 5以后，不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。只要一个不可变的对象被正确地构建出来（即没有发生this引用逃逸的情况），那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态。”不可变”带来的安全性是最直接、最纯粹的。<br>如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用<code>final</code>关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。例如Java的<code>Integer</code>类，其内部状态变量value就是定义为<code>final</code>来保障状态不变。</li>
<li>绝对线程安全<br>绝对线程安全的定义其实是非常严格的，要求<strong>不管运行时环境如何，调用者都不需要任何额外的同步措施</strong>。其实在Java API中标注自己是线程安全的类，大多数都不是绝对线程安全的，依然需要额外加同步措施。</li>
<li>相对线程安全<br>相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</li>
<li>线程兼容<br>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。Java类库API中大部分的类都是线程兼容的。</li>
<li>线程对立<br>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。由于Java语言天生就支持多线程的特性，线程对立这种排斥多线程的代码是很少出现的。</li>
</ol>
<hr>
<h3 id="线程安全的实现"><a href="#线程安全的实现" class="headerlink" title="线程安全的实现"></a>线程安全的实现</h3><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段。因此在“互斥同步”这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的。<br>Java中，最简单的互斥同步手段就是使用<code>synchronized</code>关键字。它对于一条线程来说是<strong>可重入的</strong>，且被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。<br>但<code>synchronized</code>有局限性，它是一个重量级操作，在主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。</p>
<p>所以自JDK 5起，Java类库中新提供了<code>java.util.concurrent</code>包，其中的<code>Lock</code>接口成了一种全新的互斥同步手段。<br><strong>重入锁</strong>（ReentrantLock）是<code>Lock</code>接口的一种常见实现，它也是<strong>可重入的</strong>，对比<code>synchronized</code>它增加了以下几种功能：</p>
<ol>
<li>等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li>公平锁：是指多个线程在等待同一个锁时，必须按照<strong>申请锁的时间顺序</strong>来依次获得锁。不过一旦使用了公平锁，将会导致<code>ReentrantLock</code>的性能急剧下降，会明显影响吞吐量。</li>
<li>绑定多个条件：是指一个<code>ReentrantLock</code>对象可以同时绑定多个Condition对象。在<code>synchronized</code>中，锁对象的<code>wait()</code>跟它的<code>notify()</code>或者<code>notifyAll()</code>方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而<code>ReentrantLock</code>则无须这样做，多次调用<code>newCondition()</code>方法即可。</li>
</ol>
<p><code>Lock</code>需要确保在<code>finally</code>块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。而使用<code>synchronized</code>则可以由JVM来确保即使出现异常，锁也能自动释放。<br>在JDK 5时代，<code>Lock</code>在性能上优于<code>synchronized</code>，然而由于后续Java团队的优化，现在两者在性能上基本持平，所以性能已不是选择的决定因素。</p>
<h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p>互斥同步由于线程的阻塞和唤醒带来的性能开销，被称为<strong>阻塞同步</strong>。互斥同步属于<strong>悲观</strong>的并发策略，也就是悲观地认为只要不加同步措施，就一定会出现问题，无论共享的数据是否真的会出现竞争，都进行加锁。<br>相应的，还有一种选择则是基于冲突检测的<strong>乐观</strong>并发策略。也就是说，不管风险先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。这种同步操作被称为<strong>非阻塞同步</strong>。<br>对于非阻塞同步，一个重要的指令就是<strong>CAS</strong>指令。它需要进行3个操作，分别是<strong>内存位置</strong>（在Java中可以简单地理解为变量的内存地址，用V表示）、<strong>旧的预期值</strong>（用A表示）和<strong>准备设置的新值</strong>（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。<br>java中有一个<code>AtomicInteger</code>类，用它代替int后，即可实现CAS操作避免阻塞同步。其中的<code>incrementAndGet()</code>方法在一个无限循环中，不断尝试将一个比当前值大一的新值赋值给自己。如果失败了，那说明在执行CAS操作的时候，旧值已经发生改变，于是再次循环进行下一次操作，直到设置成功为止。<br>CAS看起来很美好，但其实有一个逻辑漏洞：例如一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，CAS会认为它没有被改变过，但其实这个变量的值有可能在过程中被改成了B，又改回为A。这个漏洞成为CAS操作的<strong>ABA问题</strong>。为了解决这个问题，有一个带有标记的原子引用类<code>AtomicStampedReference</code>，它可以通过控制变量值的版本来保证CAS的正确性。不过由于ABA问题并不会影响程序并发的正确性，所以问题不大。</p>
<h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><p>如果一个方法不涉及共享数据，那自然就不需要加任何同步措施。<br>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。<br>Java中，如果一个变量只要被某个线程独享，我们可通过<code>java.lang.ThreadLocal</code>类来实现线程本地存储的功能。</p>
<ul>
<li>每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</li>
</ul>
<hr>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h4><p>自旋锁在JDK 1.4.2就已经引入，直到JDK 6才默认开启。它可以使线程一直处于<strong>RUNNABLE</strong>状态，循环检测锁标志位，避免了线程切换的开销。但它会一直占用CPU资源却什么也不做，如果锁被其他线程占用的时间很长，则会造成大量资源的浪费。因此可以设置自旋的次数(默认为十)，如果自旋超过了这个次数，就以传统的方式挂起线程。<br>在JDK 6中，引入了<strong>自适应自旋锁</strong>，对自旋锁进行了优化。自适应意味着自旋的时间不再固定，而是由前一次在同一个锁的自旋时间以及锁的拥有者的状态来决定的。<br>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么JVM会认为这次自旋也很有可能再次成功，就会允许自旋等待持续相对更长的时间。反之以后获取这个锁则有可能直接忽略掉自旋过程，避免浪费处理器资源。</p>
<h4 id="独享锁、共享锁"><a href="#独享锁、共享锁" class="headerlink" title="独享锁、共享锁"></a>独享锁、共享锁</h4><p><code>ReentrantLock</code>和<code>synchronized</code>都是独享锁，<code>ReadWriteLock</code>的读锁是共享锁，写锁是独享锁。</p>
<h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><p>一种锁的设计策略。在JDK 1.8之前，对于<code>ConcurrentHashMap</code>而言并发的实现就是通过分段锁的策略实现高效并发。要put元素时并不对整个HashMap加锁，而是先通过<code>hashcode</code>确定其分段，再对那个分段进行加锁。所以多线程put元素可以实现真正的并行插入。</p>
<h4 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h4><p><code>synchronized</code>是不可中断的，<code>Lock</code>是可中断的。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。<br>例如<code>StringBuffer</code>类，如果在单线程进行<code>append()</code>方法，编译器会自动消除锁，转化为非线程安全的<code>StringBuilder</code>类进行操作，提高效率。</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>平时在写代码时，总是推荐将同步块的范围尽量缩小。但如果一系列连续的操作都是针对同一对象反复加锁和解锁，那么效率将会下降。<br>例如对<code>StringBuilder</code>类连续调用<code>append()</code>方法，加锁范围将会粗化到整个操作序列外部，这样只需要加锁一次即可。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在无竞争的情况下把整个同步消除，连CAS都不做。<br>偏向锁意思这个锁会偏向第一个获得它的线程。如果这个锁一直没有被其他锁获取，那么持有这个锁的线程将永远不需要同步。一旦另一个线程获取该锁，偏向模式解除，后续的同步操作按照轻量级锁一样去执行。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>偏向锁解除偏向模式后就会升级为轻量级锁。<br>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁，等待的线程全部进入阻塞状态。</p>
<hr>
<p>总结：<br><img src="Java%E4%B8%BB%E6%B5%81%E9%94%81.png" alt=""><br>参见《深入理解Java虚拟机》。</p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>Java锁</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(1)</title>
    <url>/2020/05/30/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-1/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(1)</p>
<a id="more"></a>
<h4 id="01-01-判定字符是否唯一"><a href="#01-01-判定字符是否唯一" class="headerlink" title="01.01 判定字符是否唯一"></a>01.01 <a href="https://leetcode-cn.com/problems/is-unique-lcci/" target="_blank" rel="noopener">判定字符是否唯一</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>用set存储字符出现次数，判断是否有重复。<br>如果字符范围在字母内，可以用int32，利用每一位判断出现次数。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; astr.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = astr.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> ((n &gt;&gt; tmp &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            n ^= (<span class="number">1</span> &lt;&lt; tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="01-05-一次编辑"><a href="#01-05-一次编辑" class="headerlink" title="01.05 一次编辑"></a>01.05 <a href="https://leetcode-cn.com/problems/one-away-lcci/" target="_blank" rel="noopener">一次编辑</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>用双指针以及两个字符串的长短判断修改的次数。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">oneEditAway</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first.equals(second)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> m = first.length(), n = second.length();</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(m - n) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 长度差超过1直接返回false</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n; i++, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.charAt(i) != second.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 修改次数已用完</span></span><br><span class="line">                <span class="comment">// 短的字符串指针不移动</span></span><br><span class="line">                <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="01-07-旋转矩阵"><a href="#01-07-旋转矩阵" class="headerlink" title="01.07 旋转矩阵"></a>01.07 <a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">旋转矩阵</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像顺时针旋转 90 度。<br>不占用额外内存空间能否做到？</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>先按 \ 对角线翻转数组再左右翻转数组，或者先按 / 对角线翻转数组再上下翻转数组。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 按 \ 翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][l];</span><br><span class="line">                matrix[i][l] = matrix[i][r];</span><br><span class="line">                matrix[i][r] = tmp;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-01-移除重复节点"><a href="#02-01-移除重复节点" class="headerlink" title="02.01 移除重复节点"></a>02.01 <a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener">移除重复节点</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>用set存储出现过的节点值，判断。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        set.add(cur.val);</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(cur.next.val)) &#123;</span><br><span class="line">                set.add(cur.next.val);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = cur.next.next; <span class="comment">// set存在当前节点值，删除节点，当前指针不移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-02-返回倒数第-k-个节点"><a href="#02-02-返回倒数第-k-个节点" class="headerlink" title="02.02 返回倒数第 k 个节点"></a>02.02 <a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/" target="_blank" rel="noopener">返回倒数第 k 个节点</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>先让一个指针走k步，再双指针一起走。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(3)</title>
    <url>/2020/05/30/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-3/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(3)</p>
<a id="more"></a>
<h4 id="03-04-化栈为队"><a href="#03-04-化栈为队" class="headerlink" title="03.04 化栈为队"></a>03.04 <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/" target="_blank" rel="noopener">化栈为队</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>实现一个MyQueue类，该类用两个栈来实现一个队列。<br>假设所有操作都是有效的（例如，一个空的队列不会调用 pop 或者 peek 操作）。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>一个栈存元素，另一个栈取元素。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1; <span class="comment">// 存元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2; <span class="comment">// 取元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.empty() &amp;&amp; stack2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-02-最小高度树"><a href="#04-02-最小高度树" class="headerlink" title="04.02 最小高度树"></a>04.02 <a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/" target="_blank" rel="noopener">最小高度树</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>二叉搜索树<strong>中序遍历</strong>有序，所以以数组中间元素为根节点，不断二分递归。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(nums[mid]); <span class="comment">// 中间元素为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="comment">// 递归得到左右子树</span></span><br><span class="line">        node.left = buildTree(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        node.right = buildTree(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-04-检查平衡性"><a href="#04-04-检查平衡性" class="headerlink" title="04.04 检查平衡性"></a>04.04 <a href="https://leetcode-cn.com/problems/check-balance-lcci/" target="_blank" rel="noopener">检查平衡性</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p><strong>递归</strong>判断所有节点的两子树的最大高度差。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 递归判断</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(getHeight(root.left) - getHeight(root.right)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取树的最大高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getHeight(node.left), getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-08-首个共同祖先"><a href="#04-08-首个共同祖先" class="headerlink" title="04.08 首个共同祖先"></a>04.08 <a href="https://leetcode-cn.com/problems/first-common-ancestor-lcci/" target="_blank" rel="noopener">首个共同祖先</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。<br>所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p><strong>递归</strong>寻找共同祖先。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root; <span class="comment">// 找到节点</span></span><br><span class="line">        root.left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        root.right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// 如果p、q分别在两子树，首个共同祖先为此节点，否则为某个子节点。</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="keyword">return</span> root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-10-检查子树"><a href="#04-10-检查子树" class="headerlink" title="04.10 检查子树"></a>04.10 <a href="https://leetcode-cn.com/problems/check-subtree-lcci/" target="_blank" rel="noopener">检查子树</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。<br>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p><strong>递归</strong>比较子树是否相等。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 节点值相等，则递归检查以此节点为根的子树与t2是否相等。</span></span><br><span class="line">        <span class="keyword">if</span> (t1.val == t2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkSubTree(t1.left, t2.left) &amp;&amp; checkSubTree(t1.right, t2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则遍历t1其他节点</span></span><br><span class="line">        <span class="keyword">return</span> checkSubTree(t1.left, t2) || checkSubTree(t1.right, t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(2)</title>
    <url>/2020/05/30/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-2/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(2)</p>
<a id="more"></a>
<h4 id="02-04-分割链表"><a href="#02-04-分割链表" class="headerlink" title="02.04 分割链表"></a>02.04 <a href="https://leetcode-cn.com/problems/partition-list-lcci/" target="_blank" rel="noopener">分割链表</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>双指针，与x比较进行交换。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode small = head, large = head;</span><br><span class="line">        <span class="keyword">while</span> (small != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (small.val &lt; x) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = small.val;</span><br><span class="line">                small.val = large.val;</span><br><span class="line">                large.val = tmp;</span><br><span class="line">                large = large.next;</span><br><span class="line">            &#125;</span><br><span class="line">            small = small.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-05-链表求和"><a href="#02-05-链表求和" class="headerlink" title="02.05 链表求和"></a>02.05 <a href="https://leetcode-cn.com/problems/sum-lists-lcci/" target="_blank" rel="noopener">链表求和</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>给定两个用链表表示的整数，每个节点包含一个数位。<br>这些数位是反向存放的，也就是个位排在链表首部。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>双指针从个位逐步累加，边界处理。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="keyword">int</span> tmp = n1 + n2 + carry;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">            l1 = l1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l1.next;</span><br><span class="line">            l2 = l2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l2.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) cur.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>); <span class="comment">// 处理最高位的进位</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-06-回文链表"><a href="#02-06-回文链表" class="headerlink" title="02.06 回文链表"></a>02.06 <a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">回文链表</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>编写一个函数，检查输入的链表是否是回文的。<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>找到中间节点，翻转后半部分链表，再与前半部分进行比较。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="comment">// 找到中间节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode latter = reverse(slow.next); <span class="comment">// 翻转后半部链表</span></span><br><span class="line">        <span class="keyword">while</span> (latter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != latter.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode cur = node, last = <span class="keyword">null</span>, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = last;</span><br><span class="line">            last = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-07-链表相交"><a href="#02-07-链表相交" class="headerlink" title="02.07 链表相交"></a>02.07 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">链表相交</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。<br>如果两个链表没有交点，返回 null 。<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>可以用set存储链表的引用，判断是否有重复。要求O(1)内存就使用两个指针。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA, b = headB;</span><br><span class="line">        <span class="comment">// 都指向交点或者null退出循环</span></span><br><span class="line">        <span class="comment">// 一个链表的指针到末尾就指向另一个链表头</span></span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a == <span class="keyword">null</span> ? headB : a.next;</span><br><span class="line">            b = b == <span class="keyword">null</span> ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-08-环路检测"><a href="#02-08-环路检测" class="headerlink" title="02.08 环路检测"></a>02.08 <a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/" target="_blank" rel="noopener">环路检测</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>给定一个有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。<br>你是否可以不用额外空间解决此题？</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>快慢指针找环的入口。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head.next, fast = head.next.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 遇到空指针说明没有环</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(6)</title>
    <url>/2020/06/18/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-6/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(6)</p>
<a id="more"></a>
<h4 id="16-05-阶乘尾数"><a href="#16-05-阶乘尾数" class="headerlink" title="16.05 阶乘尾数"></a>16.05 <a href="https://leetcode-cn.com/problems/factorial-zeros-lcci/" target="_blank" rel="noopener">阶乘尾数</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>设计一个算法，算出 n 阶乘有多少个尾随零。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>0是由<code>*10</code>得到的，而10是由<code>2*5</code>得到的。<br>2的个数比5多，所以计算5的个数。每隔5个数就会出现一个5，隔25出现两个5，以此类推。<br>count = n / 5 + n / 5 / 5 + n / 5 / 5 / 5 + …</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            ans += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(4)</title>
    <url>/2020/05/31/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-4/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(4)</p>
<a id="more"></a>
<h4 id="04-12-求和路径"><a href="#04-12-求和路径" class="headerlink" title="04.12 求和路径"></a>04.12 <a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/" target="_blank" rel="noopener">求和路径</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>暴力求解，<strong>递归</strong>每一个节点。或者用<strong>前缀和</strong>进行缓存，降低时间复杂度。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力(9ms)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="comment">// 递归每个节点</span></span><br><span class="line">        pathSum(root.left, sum);</span><br><span class="line">        pathSum(root.right, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.val == sum) ans++; <span class="comment">// 找到路径</span></span><br><span class="line">        dfs(node.left, sum - node.val);</span><br><span class="line">        dfs(node.right, sum - node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀和(2ms)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录前缀和(前缀和有可能重复，所以要用map)</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; prefixSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        prefixSum.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        dfs(root, sum, root.val);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum, <span class="keyword">int</span> curSum)</span> </span>&#123;</span><br><span class="line">    		<span class="comment">// 判断是否找到路径</span></span><br><span class="line">        ans += prefixSum.getOrDefault(curSum - sum, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 添加当前前缀和</span></span><br><span class="line">        prefixSum.put(curSum, prefixSum.getOrDefault(curSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) dfs(node.left, sum, curSum + node.left.val);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) dfs(node.right, sum, curSum + node.right.val);</span><br><span class="line">        <span class="comment">// 回滚</span></span><br><span class="line">        prefixSum.put(curSum, prefixSum.get(curSum) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="05-01-插入"><a href="#05-01-插入" class="headerlink" title="05.01 插入"></a>05.01 <a href="https://leetcode-cn.com/problems/insert-into-bits-lcci/" target="_blank" rel="noopener">插入</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>题目描述得不太好，就是将N的第j位到第i位替换成M，长度不够高位补0。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>先将N的j到i位替换成0，再加上移位后的M即可。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBits</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">        		<span class="comment">// 替换</span></span><br><span class="line">            N -= (<span class="number">1</span> &amp; (N &gt;&gt; k)) == <span class="number">1</span> ? (<span class="number">1</span> &lt;&lt; k) : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        N |= (M &lt;&lt; i); <span class="comment">// 覆盖</span></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="05-02-二进制数转字符串"><a href="#05-02-二进制数转字符串" class="headerlink" title="05.02 二进制数转字符串"></a>05.02 <a href="https://leetcode-cn.com/problems/bianry-number-to-string-lcci/" target="_blank" rel="noopener">二进制数转字符串</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>二进制数转字符串。给定一个介于0和1之间的实数(如0.72)，类型为double，打印它的二进制表达式。如果该数字不在0和1之间，或者无法精确地用32位以内的二进制表示，则打印“ERROR”。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>十进制小数转二进制：<strong>乘2取整，顺序排列</strong>。<br><img src="%E5%8D%81%E8%BF%9B%E5%88%B6%E5%B0%8F%E6%95%B0%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt=""><br><strong>末尾不为5的十进制小数无法精确转换为二进制，因为小数部分永远不可能为0。</strong></p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printBin</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">"0."</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                num *= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(<span class="number">1</span>);</span><br><span class="line">                    num -= <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                		<span class="comment">// 等于1说明小数部分已为0</span></span><br><span class="line">                    sb.append(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> sb.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行到这里说明此小数无法精确转换成二进制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="05-03-翻转数位"><a href="#05-03-翻转数位" class="headerlink" title="05.03 翻转数位"></a>05.03 <a href="https://leetcode-cn.com/problems/reverse-bits-lcci/" target="_blank" rel="noopener">翻转数位</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>因为只能改变一个0，所以记录先前长度，遇到0时减去即可。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, cur = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">            		<span class="comment">// 减去上次改动0的位置</span></span><br><span class="line">                cur -= pre;</span><br><span class="line">                <span class="comment">// pre记录的是上一次改动0的位置</span></span><br><span class="line">                pre = cur + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur++;</span><br><span class="line">            max = Math.max(max, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="05-07-配对交换"><a href="#05-07-配对交换" class="headerlink" title="05.07 配对交换"></a>05.07 <a href="https://leetcode-cn.com/problems/exchange-lcci/" target="_blank" rel="noopener">配对交换</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。<br>num的范围在[0, 2^30 - 1]之间，不会发生整数溢出。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>循环。或者使用<code>0x55555555</code>和<code>0xaaaaaaaa</code>得到奇偶位进行交换。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    		<span class="comment">// 0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为1，奇数位为0）</span></span><br><span class="line">        <span class="comment">// 0x55555555 = 01010101010101010101010101010101 (偶数位为0，奇数位为1）</span></span><br><span class="line">        <span class="comment">// 分别与num位与，可以分别得到num奇偶位的数位。因为要交换，所以分别位移后进行或运算即可。</span></span><br><span class="line">        <span class="keyword">return</span> ((num &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>) | ((num &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(5)</title>
    <url>/2020/06/09/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-5/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(5)</p>
<a id="more"></a>
<h4 id="08-05-递归乘法"><a href="#08-05-递归乘法" class="headerlink" title="08.05 递归乘法"></a>08.05 <a href="https://leetcode-cn.com/problems/recursive-mulitply-lcci/" target="_blank" rel="noopener">递归乘法</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>可以利用加法，效率偏低。<br>还可以借助快速幂的思想，降低循环次数。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    		<span class="comment">// 较小值进行循环，提高效率</span></span><br><span class="line">        <span class="keyword">return</span> dfs(Math.max(A, B), Math.min(A, B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    		<span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="comment">// 20 * 6 == 40 * 3</span></span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> dfs(a &lt;&lt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 20 * 3 == 20 + 40 * 1</span></span><br><span class="line">        <span class="keyword">return</span> a + (dfs(a &lt;&lt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="08-11-硬币"><a href="#08-11-硬币" class="headerlink" title="08.11 硬币"></a>08.11 <a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">硬币</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>完全背包问题。动态规划。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">// dp[i]表示i分有几种表示方法</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 0分有一种表示法</span></span><br><span class="line">        <span class="comment">// 每种硬币都可以选无数次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 大于当前硬币数额的分数才可以选这个硬币</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="comment">// 之前选的种类数加上这一步选的</span></span><br><span class="line">                dp[i] = (dp[i] + dp[i-coin]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="08-12-八皇后"><a href="#08-12-八皇后" class="headerlink" title="08.12 八皇后"></a>08.12 <a href="https://leetcode-cn.com/problems/eight-queens-lcci/" target="_blank" rel="noopener">八皇后</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>dfs。遍历所有情况，判断在不在同一对角线剪枝。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; pie = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 对于/对角线，在同一对角线上i+j相等。</span></span><br><span class="line">    Set&lt;Integer&gt; na = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 对于\对角线，在同一对角线上i-j相等。</span></span><br><span class="line">    Set&lt;Integer&gt; col = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 当前列是否出现过Q</span></span><br><span class="line">    List&lt;String&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 一行一行遍历</span></span><br><span class="line">        dfs(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历完了最后一行，说明这种摆法可行</span></span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历第i行每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col.contains(j) || pie.contains(i + j) || na.contains(i - j)) <span class="keyword">continue</span>;</span><br><span class="line">            col.add(j);</span><br><span class="line">            pie.add(i + j);</span><br><span class="line">            na.add(i - j);</span><br><span class="line">            cur.add(generate(j, n)); <span class="comment">// 生成字符串</span></span><br><span class="line">            dfs(i + <span class="number">1</span>, n); <span class="comment">// 搜索下一行</span></span><br><span class="line">            <span class="comment">// 撤回这一列的选择</span></span><br><span class="line">            col.remove(j);</span><br><span class="line">            pie.remove(i + j);</span><br><span class="line">            na.remove(i - j);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generate</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i) sb.append(<span class="string">"Q"</span>);</span><br><span class="line">            <span class="keyword">else</span> sb.append(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="08-13-堆箱子"><a href="#08-13-堆箱子" class="headerlink" title="08.13 堆箱子"></a>08.13 <a href="https://leetcode-cn.com/problems/pile-box-lcci/" target="_blank" rel="noopener">堆箱子</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。<br>输入使用数组[wi, di, hi]表示每个箱子。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>按某一维排序，转换成最长递增子序列问题。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pileBox</span><span class="params">(<span class="keyword">int</span>[][] box)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = box.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按宽排序</span></span><br><span class="line">        Arrays.sort(box, (x, y) -&gt; x[<span class="number">0</span>] - y[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// dp[i]表示第i个箱子在最底下时最大的箱子高度总和</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 最低高度就是只有第i个这一个箱子</span></span><br><span class="line">            dp[i] = box[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (box[i][<span class="number">0</span>] &gt; box[j][<span class="number">0</span>] &amp;&amp; box[i][<span class="number">1</span>] &gt; box[j][<span class="number">1</span>] &amp;&amp; box[i][<span class="number">2</span>] &gt; box[j][<span class="number">2</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 第i个箱子高度+第j个箱子在最底的最高高度与当前相比</span></span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + box[i][<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每一步都需要比较</span></span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="10-05-稀疏数组搜索"><a href="#10-05-稀疏数组搜索" class="headerlink" title="10.05 稀疏数组搜索"></a>10.05 <a href="https://leetcode-cn.com/problems/sparse-array-search-lcci/" target="_blank" rel="noopener">稀疏数组搜索</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>二分查找。遇到空字符串特殊处理。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findString</span><span class="params">(String[] words, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>), tmp = mid;</span><br><span class="line">            <span class="comment">// 如果words[mid]是空串，一直循环直到右边第一个非空串。</span></span><br><span class="line">            <span class="keyword">while</span> (words[mid].equals(<span class="string">""</span>) &amp;&amp; mid &lt; r) mid++;</span><br><span class="line">            <span class="comment">// 如果此时还是空串，说明从mid到r都是空串</span></span><br><span class="line">            <span class="keyword">if</span> (words[mid].equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="comment">// 将r直接变成mid-1</span></span><br><span class="line">                r = tmp - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 二分模板</span></span><br><span class="line">            <span class="keyword">int</span> cmp = words[mid].compareTo(s);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(1)</title>
    <url>/2020/06/01/%E5%89%91%E6%8C%87offer-1/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(1)</p>
<a id="more"></a>
<h4 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03 数组中重复的数字"></a>03 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>排序后查找重复数字。<br>哈希表。<br>二分。<br>利用题中条件<strong>所有数字都在 0～n-1 的范围内</strong>，比较下标以及下标对应的数字进行交换。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n)  空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        		<span class="comment">// 下标对应的数字不等于下标时</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">            		<span class="comment">// 数字相等说明已找到重复</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[nums[i]];</span><br><span class="line">                <span class="comment">// 这里不能用nums[nums[i]] = tmp，因为上一步nums[i]已被更改。</span></span><br><span class="line">                nums[tmp] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上一段代码更改了源数组。如果要求不能更改，可以使用二分。</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(nlogn)  空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">// 此方法不一定能找出所有重复的数字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + ((j - i) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> cnt = countRange(nums, i, mid);</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123; <span class="comment">// 只剩一个数字</span></span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i～mid数字在数组中出现次数大于mid-i+1说明此范围有重复</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; (mid - i + <span class="number">1</span>)) j = mid;</span><br><span class="line">            <span class="keyword">else</span> i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= i &amp;&amp; n &lt;= j) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11 旋转数组的最小数字"></a>11 <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>数组相对有序，使用二分查找。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(logn)  空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 中间比右边大，说明此元素属于被旋转的那部分，最小元素一定不在这里。</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[l]) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> r--; <span class="comment">// 相等时无法判断处于哪部分，只能缩小范围去重。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="14-i-剪绳子"><a href="#14-i-剪绳子" class="headerlink" title="14 i.剪绳子"></a>14 <a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">i.剪绳子</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]*k[1]*…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>动态规划或者贪心。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(n^2)  空间复杂度：O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    		<span class="comment">// 由于至少剪一次，n=2或3时特殊处理。</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 绳子剩余2或3时，已经至少剪过1次，此时最好的情况是不剪</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>; dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] * dp[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-ii-剪绳子"><a href="#14-ii-剪绳子" class="headerlink" title="14 ii.剪绳子"></a>14 <a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">ii.剪绳子</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>与上题一样。但答案可能会很大，需要取模 1e9+7（1000000007）。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>本题不能用动态规划。因为取模后无法正确比较大小。只能用贪心。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        		<span class="comment">// 有3取3</span></span><br><span class="line">            ans *= <span class="number">3</span>;</span><br><span class="line">            ans %= <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (ans * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16 数值的整数次方"></a>16 <a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">数值的整数次方</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>快速幂。注意边界问题。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// -2147483648直接取绝对值会溢出，需要先转成long。</span></span><br><span class="line">        <span class="keyword">long</span> y = n;</span><br><span class="line">        y = y &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line">        <span class="comment">// 快速幂</span></span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((y &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? res : <span class="number">1</span> / res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(2)</title>
    <url>/2020/06/02/%E5%89%91%E6%8C%87offer-2/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(2)</p>
<a id="more"></a>
<h4 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19 正则表达式匹配"></a>19 <a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">正则表达式匹配</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>动态规划。二维dp数组。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="comment">// 需要判断为空的情况，所以长度+1</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// s为空也可能被p匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">2</span>] &amp;&amp; p.charAt(i-<span class="number">1</span>) == <span class="string">'*'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// s的前i位能否被p的前j位匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 1.之前元素出现0次，直接移除p两个元素，s不变</span></span><br><span class="line">                    <span class="comment">// 2.之前元素出现1或多次，比较s的i元素与p的j-1元素，</span></span><br><span class="line">                    <span class="comment">// 相等则移除s当前元素，p继续匹配</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] || (check(s, p, i, j - <span class="number">1</span>) &amp;&amp; dp[i][j+<span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                		<span class="comment">// s的i元素与p的j元素是否相等，相等则分别移除当前元素比较之前元素</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] &amp;&amp; check(s, p, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.charAt(j) == <span class="string">'.'</span> || s.charAt(i) == p.charAt(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29 顺时针打印矩阵"></a>29 <a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">顺时针打印矩阵</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>四个变量分别记录当前上下左右边界的索引，判断结束条件。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">        <span class="comment">// 当前边界索引</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, u = <span class="number">0</span>, d = m - <span class="number">1</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        		<span class="comment">// 右下左上顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                res[idx++] = matrix[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++u &gt; d) <span class="keyword">break</span>; <span class="comment">// 跳出循环条件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = u; i &lt;= d; i++) &#123;</span><br><span class="line">                res[idx++] = matrix[i][r];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--) &#123;</span><br><span class="line">                res[idx++] = matrix[d][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--d &lt; u) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &gt;= u; i--) &#123;</span><br><span class="line">                res[idx++] = matrix[i][l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33 二叉搜索树的后序遍历序列"></a>33 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>数组最后一位为根节点，根据大小找到左子树与右子树，递归判断是否合法。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = postorder.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> check(postorder, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 剩一个元素，递归终止。</span></span><br><span class="line">        <span class="keyword">int</span> idx; <span class="comment">// 左子树索引</span></span><br><span class="line">        <span class="keyword">for</span> (idx = left; idx &lt; right; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[idx] &gt; arr[right]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; right; i++) &#123;</span><br><span class="line">        		<span class="comment">// 如果右子树有值小于根节点的数，则不是二叉搜索树。</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[right]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归判断子树</span></span><br><span class="line">        <span class="keyword">return</span> check(arr, left, idx - <span class="number">1</span>) &amp;&amp; check(arr, idx, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35 复杂链表的复制"></a>35 <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>普通方法只能复制一般的链表，无法复制random指针。<br>可以利用哈希表存储原链表与复制链表，这样就可以根据键值对找到random指针，但要消耗O(n)空间。<br>所以还有一种原地修改的方法。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node cur = head, copy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 1-&gt;2-&gt;3 ----&gt; 1-&gt;1'-&gt;2-&gt;2'-&gt;3-&gt;3'</span></span><br><span class="line">        <span class="comment">// 这样就可以定位random指针的位置</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            copy = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            copy.next = cur.next;</span><br><span class="line">            cur.next = copy;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">// 复制random指针</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        Node ans = head.next, tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 分离原始链表和复制链表，head.next即为复制的链表。</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = tmp.next;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36 二叉搜索树与双向链表"></a>36 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>二叉搜索树<strong>中序遍历</strong>有序。全局变量记录头节点和上一个节点，利用中序遍历将所有节点连在一起，最后将头尾相连即可。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node head = <span class="keyword">null</span>, pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">// 执行完dfs，pre即为尾节点，将头尾相连。</span></span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) dfs(node.left);</span><br><span class="line">        node.left = pre;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.right = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="comment">// pre == null，说明当前节点是中序遍历头节点。</span></span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) dfs(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(3)</title>
    <url>/2020/06/05/%E5%89%91%E6%8C%87offer-3/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(3)</p>
<a id="more"></a>
<h4 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38 字符串的排列"></a>38 <a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>输入一个字符串，打印出该字符串中字符的所有排列。<br>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>dfs。因为有重复元素需要剪枝去重。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n!)  // 空间复杂度 O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        dfs(c, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> String[ans.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    		<span class="comment">// 到达最后一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> String(arr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">        		<span class="comment">// 如果字符已经存在，跳过这个字符</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(arr[j])) <span class="keyword">continue</span>;</span><br><span class="line">            set.add(arr[j]);</span><br><span class="line">            <span class="comment">// 固定arr[j]在i位置</span></span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">            dfs(arr, i + <span class="number">1</span>, n);</span><br><span class="line">            <span class="comment">// 恢复交换</span></span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42 连续子数组的最大和"></a>42 <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>要求时间复杂度为O(n)。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p><strong>动态规划</strong>。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 初始值为nums[0]，如果数组只有一个数，直接返回。</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// dp[i]表示以第i个数结尾的子数组的最大和</span></span><br><span class="line">            <span class="comment">// 如果之前的最大和加上当前这个数比这个数大，就加上</span></span><br><span class="line">            dp[i] = Math.max(nums[i], dp[i-<span class="number">1</span>] + nums[i]);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="43-1-n整数中1出现的次数"><a href="#43-1-n整数中1出现的次数" class="headerlink" title="43 1~n整数中1出现的次数"></a>43 <a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">1~n整数中1出现的次数</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。<br>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。<br>1 &lt;= n &lt; 2^31</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>暴力。由于n的范围较大，会超时。<br>循环每一位数，统计每一位数上1出现的次数，最后累加即为结果。时间复杂度为O(logn)。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n / i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> high = n / (<span class="number">10</span> * i); <span class="comment">// 高位</span></span><br><span class="line">            <span class="keyword">long</span> cur = n / i % <span class="number">10</span>; <span class="comment">// 当前位</span></span><br><span class="line">            <span class="keyword">long</span> low = n - n / i * i; <span class="comment">// 低位</span></span><br><span class="line">            <span class="comment">// 当前位等于0，出现1的次数只与高位有关。</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += high * i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">            		<span class="comment">// 等于1与高低位都有关</span></span><br><span class="line">                ans += high * i + low + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            		<span class="comment">// 其他数也只与高位有关</span></span><br><span class="line">                ans += (high + <span class="number">1</span>) * i;</span><br><span class="line">            &#125;</span><br><span class="line">            i *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44 数字序列中某一位的数字"></a>44 <a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">数字序列中某一位的数字</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。<br>请写一个函数，求任意第n位对应的数字。<br>0 &lt;= n &lt; 2^31</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>转成字符串处理。由于数字范围较大，内存会溢出。<br>找规律，判断数字出现的范围。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    		<span class="comment">// 1～9 9位  10～99 90位。100～999 900位。以此类推。</span></span><br><span class="line">        <span class="keyword">long</span> cnt = <span class="number">9</span>, start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; cnt) &#123;</span><br><span class="line">            n -= cnt;</span><br><span class="line">            digit++;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            cnt = start * digit * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断数位在哪个数字中</span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit;</span><br><span class="line">        <span class="comment">// 判断在数字的哪一位</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48 最长不含重复字符的子字符串"></a>48 <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>动态规划。记录当前字符在字符串中上一次出现的下标，与当前长度对比更新最大值。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] lastIdx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 初始化下标为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) lastIdx[i] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = lastIdx[(<span class="keyword">int</span>) s.charAt(i)];</span><br><span class="line">            <span class="comment">// 如果当前字符未出现过或者出现的距离大于当前子串长度，长度+1</span></span><br><span class="line">            <span class="comment">// 否则将当前子串长度设为出现的位置下标之差以保证不含重复字符</span></span><br><span class="line">            <span class="keyword">if</span> (last == -<span class="number">1</span> || i - last &gt; cur) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = i - last;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, cur);</span><br><span class="line">            <span class="comment">// 更新最后出现当前字符的下标</span></span><br><span class="line">            lastIdx[(<span class="keyword">int</span>) s.charAt(i)] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(5)</title>
    <url>/2020/06/07/%E5%89%91%E6%8C%87offer-5/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(5)</p>
<a id="more"></a>
<h4 id="59-i-滑动窗口的最大值"><a href="#59-i-滑动窗口的最大值" class="headerlink" title="59-i 滑动窗口的最大值"></a>59-i <a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">滑动窗口的最大值</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>维护一个队列，首元素为当前窗口的最大值。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化前k位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        		<span class="comment">// 当前元素和队列里的元素进行比较，大的话就删除队列里的元素</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) deque.pollLast();</span><br><span class="line">            deque.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = deque.peek();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">        		<span class="comment">// 如果队列里的最大元素等于nums[i-k]，说明此最大值已不再当前窗口</span></span><br><span class="line">            <span class="keyword">if</span> (deque.peek() == nums[i-k]) deque.poll();</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) deque.pollLast();</span><br><span class="line">            deque.offer(nums[i]);</span><br><span class="line">            <span class="comment">// 当前窗口的最大值为队列首元素</span></span><br><span class="line">            ans[i-k+<span class="number">1</span>] = deque.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60 n个骰子的点数"></a>60 <a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">n个骰子的点数</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。<br>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>动态规划。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] twoSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    		<span class="comment">// dp[i][j]表示扔了i个骰子后和为j的排列情况总数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">6</span>*n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 结果数组长度为6n-n+1</span></span><br><span class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>*n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 第一个骰子，总和只能为1～6，每种出现一次。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// n个骰子，每个1～6点数，总共6^n种排列情况。</span></span><br><span class="line">        <span class="keyword">double</span> all = Math.pow(<span class="number">6</span>, n);</span><br><span class="line">        <span class="comment">// n个骰子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        		<span class="comment">// i个骰子可能出现的点数总和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= <span class="number">6</span> * i; j++) &#123;</span><br><span class="line">            		<span class="comment">// 每个骰子1～6点数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span>; k++) &#123;</span><br><span class="line">                    <span class="comment">// i个骰子总和为j的情况总数等于</span></span><br><span class="line">                    <span class="comment">// i-1个骰子总和为j-k的情况总数，k为当前着个骰子扔的点数。</span></span><br><span class="line">                    dp[i][j] += j &gt;= k ? dp[i-<span class="number">1</span>][j-k] : <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// i == n，说明已经扔到了最后一个骰子，可以开始添加结果。</span></span><br><span class="line">                    <span class="keyword">if</span> (i == n) ans[j-i] = dp[i][j] / all;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 <a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">不用加减乘除做加法</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。<br>a, b 均可能是负数或 0，结果不会溢出 32 位整数。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>既然不能用加减乘除，那就用位运算。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123; <span class="comment">// 进位为0退出</span></span><br><span class="line">        		<span class="comment">// 非进位和(相当于异或)</span></span><br><span class="line">            <span class="keyword">int</span> sum = a ^ b;</span><br><span class="line">            <span class="comment">// 进位和(位与再左移一位，这样当某一位上两个数都是1时就会进位)</span></span><br><span class="line">            <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>原码、反码、补码</title>
    <url>/2020/05/28/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<p> 之前不了解机器为何要使用补码进行存储，学习之后记录一下。</p>
<a id="more"></a>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>原码就是符号位加上真值的绝对值，即最高位用<code>1</code>表示负数，<code>0</code>表示正数，其余位表示数值。<br>例如8位二进制：</p>
<blockquote>
<p>[+1]原：00000001<br>[-1]原：10000001</p>
</blockquote>
<p>可见8位二进制表示数字的范围为<code>[-127, 127]</code>。</p>
<hr>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>反码的表示形式是：</p>
<ul>
<li>正数的反码是其本身</li>
<li>负数的反码是在其原码的基础上，符号位不变，其余各个位取反</li>
</ul>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反<br>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>如果一个用反码表示的负数，人脑需要将其转成原码才比较好计算。</p>
<hr>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>反码的表示形式是：</p>
<ul>
<li>正数的补码是其本身</li>
<li>负数的补码是在其反码的基础上+1</li>
</ul>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补<br>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>如果一个用补码表示的负数，人脑依然很难直接看出数值。</p>
<hr>
<h3 id="为何要发明反码和补码"><a href="#为何要发明反码和补码" class="headerlink" title="为何要发明反码和补码"></a>为何要发明反码和补码</h3><p>首先，人脑可以很容易地根据最高位分辨出一个数是正数还是负数，但对于计算机来说，肯定要设计得尽量简单，让计算机判断符号位会使计算机的电路设计显得很复杂。于是计算机会将符号位也参与计算。比如对于<code>1-1</code>这个运算，计算机会将运算变成<code>1+(-1)</code>，这时如果用原码进行计算，就会出现问题。</p>
<blockquote>
<p>1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>
</blockquote>
<p>结果并不等于0。所以计算机并不使用原码表示一个数。</p>
<p>因此出现了反码。用反码进行计算。</p>
<blockquote>
<p>1 + (-1) = [00000001]反 + [11111110]反 = [11111111]反 = [10000000]原 = -0</p>
</blockquote>
<p>这时结果为-0，已经能得到正确结果。这时唯一的问题就是0。因为0带符号是没有意义的，而且原码的<code>[10000000]</code>和<code>[00000000]</code>都表示0，这显然不够完美。</p>
<p>于是补码应运而生，它完美的解决了这个问题。</p>
<blockquote>
<p>1 + (-1) = [00000001]补 + [11111111]补 = [00000000]补 = [00000000]原 = 0</p>
</blockquote>
<p>这时0只用一个编码来表示了，而-0则可以用来表示-128。</p>
<blockquote>
<p>(-1) + (-127) = [11111111]补 + [10000001]补 = [10000000]补</p>
</blockquote>
<p>所以在补码运算的结果中<code>[10000000]补</code>就是-128。但由于其实是用以前的-0的补码来表示-128，所以-128并没有反码和原码来表示。<br>这也是为什么对于8位二进制数，原码和反码表示的范围是<code>[-127, 127]</code>，而补码表示的是<code>[-128, 127]</code>。而对于常见的int32也是如此。由于机器是使用补码存储，所以int32表示的范围是<code>[-2^31, 2^31-1]</code>。</p>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/05/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>最近闲在家里没事，就用hexo搭建了一个博客。不过不知道写点啥，先开个头吧～</p>
<a id="more"></a>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(4)</title>
    <url>/2020/06/06/%E5%89%91%E6%8C%87offer-4/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(4)</p>
<a id="more"></a>
<h4 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49 丑数"></a>49 <a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>三指针。第一个丑数是1，以后的丑数都是基于前面的小丑数分别乘2，3，5构成的。每次添加当前计算出的最小的丑数，更新相应的指针。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">6</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 第一个丑数是1</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx2 = <span class="number">0</span>, idx3 = <span class="number">0</span>, idx5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        		<span class="comment">// 计算出当前最小丑数</span></span><br><span class="line">            dp[i] = Math.min(dp[idx2] * <span class="number">2</span>, Math.min(dp[idx3] * <span class="number">3</span>, dp[idx5] * <span class="number">5</span>));</span><br><span class="line">            <span class="comment">// 更新指针。由于可能出现相等的情况，这时多个指针都要更新，所以不用else if。</span></span><br><span class="line">            <span class="keyword">if</span> (dp[idx2] * <span class="number">2</span> == dp[i]) idx2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[idx3] * <span class="number">3</span> == dp[i]) idx3++;</span><br><span class="line">            <span class="keyword">if</span> (dp[idx5] * <span class="number">5</span> == dp[i]) idx5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51 数组中的逆序对"></a>51 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>归并排序。每次归并时统计有多少逆序对。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        mergeSort(nums, start, mid);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// 归并并找逆序对</span></span><br><span class="line">        merge(nums, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    		<span class="comment">// 临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = start, r = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= nums[r]) &#123;</span><br><span class="line">                tmp[k++] = nums[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果左半边的数比右边大，存在逆序</span></span><br><span class="line">                <span class="comment">// 2, 3, 4, 5      1, 3, 6, 7</span></span><br><span class="line">                <span class="comment">// 2比1大，说明2到mid的数全大于1，存在4个逆序对</span></span><br><span class="line">                cnt += mid - l + <span class="number">1</span>;</span><br><span class="line">                tmp[k++] = nums[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">            tmp[k++] = nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= end) &#123;</span><br><span class="line">            tmp[k++] = nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 赋给源数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            nums[i] = tmp[i - start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53 在排序数组中查找数字"></a>53 <a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">在排序数组中查找数字</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>统计一个数字在排序数组中出现的次数。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>有序数组，使用两次二分法分别找出数字的左右边界。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左边界</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 小的话target左边界只可能在另一边</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 大的话target左边界只可能在左边</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 相等的话左边界可能是这个或者在左边</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右下标即为左边界</span></span><br><span class="line">        <span class="keyword">int</span> left = r;</span><br><span class="line">        l = <span class="number">0</span>; r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右边界</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左下标为右边界</span></span><br><span class="line">        <span class="keyword">return</span> l - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="56-数组中数字出现的次数-i"><a href="#56-数组中数字出现的次数-i" class="headerlink" title="56 数组中数字出现的次数 i"></a>56 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">数组中数字出现的次数 i</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。<br>要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>循环数组取异或，结果为这两个数字的异或。判断这个数最低位的1的位置，对数组中的元素根据此位是否为1划分为两部分。<br>再次异或即可得到其中一个数，由<code>a ^ b ^ a = b</code>得到另一个数。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        		<span class="comment">// n最终为两个出现了一次的数的异或</span></span><br><span class="line">            n ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找出最低位的1</span></span><br><span class="line">        <span class="keyword">while</span> ((n &amp; (<span class="number">1</span> &lt;&lt; idx)) == <span class="number">0</span>) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 筛选idx位为0的数，得到其中一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; idx)) == <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再异或得到另一个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;a, n ^ a&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="56-数组中数字出现的次数-ii"><a href="#56-数组中数字出现的次数-ii" class="headerlink" title="56 数组中数字出现的次数 ii"></a>56 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">数组中数字出现的次数 ii</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>如果一个数出现了三次，它的二进制表示的每一位也出现三次，即每一位的和可以被3整除。<br>将所有数字的每一位相加，最后如果某一位能被3整除，说明出现一次的数字的这一位是0，否则是1。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">// 计算每一位的和，对3取模。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                arr[i] += (n &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">                arr[i] %= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 得到出现一次的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            ans += arr[i] == <span class="number">1</span> ? <span class="number">1</span> &lt;&lt; i : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/05/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>记录一下常规的排序算法</p>
<a id="more"></a>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h4><p>常见的排序算法可分为以下两大类：</p>
<ul>
<li>比较类排序：通过比较来决定元素间的相对顺序，由于其时间复杂度不能突破<code>O(nlogn)</code>，因此也称为非线性时间比较类排序。</li>
<li>非比较类排序：不通过比较来决定元素间的相对顺序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li>
</ul>
<p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png" alt=""></p>
<h4 id="时间、空间复杂度分析"><a href="#时间、空间复杂度分析" class="headerlink" title="时间、空间复杂度分析"></a>时间、空间复杂度分析</h4><p><img src="%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt=""></p>
<hr>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="算法逻辑"><a href="#算法逻辑" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>循环数组中的每一对元素，比较二者大小，逆序就交换位置。这样循环一轮后最大的数会在数组末尾。重复即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123; <span class="comment">// 除了最后一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123; <span class="comment">// 后面已经排好序无需再比</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="算法逻辑-1"><a href="#算法逻辑-1" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>个人认为选择排序是最直观、最好理解的排序算法。从第1个数开始循环数组，每次循环都把当前最小值放到数组前面。重复即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 保存最小值对应的索引</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[min];</span><br><span class="line">        arr[min] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="算法逻辑-2"><a href="#算法逻辑-2" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>从第1个数开始循环数组，取出当前元素，从后到前分别与每一个元素进行比较，直到遇到第一个比当前元素小的数字，将当前元素插入此数字后面即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prei = i - <span class="number">1</span>, cur = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (prei &gt;= <span class="number">0</span> &amp;&amp; arr[prei] &gt; cur) &#123; <span class="comment">// 遇到第一个比当前小的就退出</span></span><br><span class="line">            arr[prei+<span class="number">1</span>] = arr[prei];</span><br><span class="line">            prei--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[prei+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="算法逻辑-3"><a href="#算法逻辑-3" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>选出一个元素作为<code>pivot</code>，通过一次循环将<code>pivot</code>直接放到最终结果的正确位置，即<code>pivot</code>左边的元素均比它小，右边均比它大。将左右两个子数组<strong>递归</strong>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">int</span> pivot = partition(arr, start, end); <span class="comment">// 获取基准值对应的索引</span></span><br><span class="line">    <span class="comment">// 对两部分数组递归</span></span><br><span class="line">    quickSort(arr, start, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivot + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = end, counter = start; <span class="comment">// counter: 记录小于基准值的数的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="comment">// 比基准值小就放到前面</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, counter, i);</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, counter, pivot); <span class="comment">// 使基准值位于最终结果的正确位置</span></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="算法逻辑-4"><a href="#算法逻辑-4" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>算法采用<strong>分治</strong>的思想。先将数组分成长度为<code>n/2</code>的两个数组，再对这两个子数组递归进行归并排序，最后将子数组合并成有序数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>; <span class="comment">// 长度小于2退出递归</span></span><br><span class="line">    <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 递归到最小单元</span></span><br><span class="line">    mergeSort(arr, start, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">    merge(arr, start, mid, end); <span class="comment">// 合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>]; <span class="comment">// 中间数组</span></span><br><span class="line">    <span class="keyword">int</span> i = start, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 双指针归并</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">        tmp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= end) tmp[k++] = arr[j++];</span><br><span class="line">    <span class="comment">// 赋给源数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; end - start + <span class="number">1</span>; idx++) &#123;</span><br><span class="line">        arr[idx+start] = tmp[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="算法逻辑-5"><a href="#算法逻辑-5" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>用堆维护一个大顶堆或小顶堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue; <span class="comment">// java中的优先队列底层数据结构就是堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(); <span class="comment">// 默认升序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) pq.offer(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) arr[i] = pq.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>上述几个排序算法都是比较排序，还有几种非比较排序算法，主要逻辑就是利用额外数组根据下标存储，缺点是源数组的元素只能是<strong>整数</strong>。本文不做多记录。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(1)</title>
    <url>/2020/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1/</url>
    <content><![CDATA[<p>记录常见的设计模式(1)。</p>
<a id="more"></a>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><a href="http://irvlin.xyz/2020/06/22/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/#more">单例模式</a></p>
<hr>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.gif" alt=""></p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductImpl</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"产品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryImpl</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory f = <span class="keyword">new</span> FactoryImpl();</span><br><span class="line">        Product p = f.createProduct();</span><br><span class="line">        p.productMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四要素"><a href="#四要素" class="headerlink" title="四要素"></a>四要素</h4><ol>
<li>工厂接口。工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。在实际编程中，有时候也会使用一个抽象类来作为与调用者交互的接口，其本质上是一样的。</li>
<li>工厂实现。在编程中，工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。</li>
<li>产品接口。产品接口的主要目的是定义产品的规范，所有的产品实现都必须遵循产品接口定义的规范。产品接口是调用者最为关心的，产品接口定义的优劣直接决定了调用者代码的稳定性。同样，产品接口也可以用抽象类来代替，但要注意最好不要违反<a href="https://baike.baidu.com/item/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">里氏替换原则</a>。</li>
<li>产品实现。实现产品接口的具体类，决定了产品在客户端中的具体行为。<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4></li>
<li>可以使代码结构清晰，有效地封装变化。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需依赖工厂即可得到自己想要的产品。</li>
<li>对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。即使变更了具体的实现，对调用者来说没有任何影响。</li>
<li>降低耦合度。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4>首先，作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。<br>其次，工厂模式是一种典型的解耦模式，<a href="https://baike.baidu.com/item/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99" target="_blank" rel="noopener">迪米特法则</a>在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度。<br>再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。</li>
</ol>
<h4 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h4><p>以组装汽车为例。场景如下：汽车由发动机、轮、底盘组成，现在需要组装一辆车交给调用者。<br>如果没有用工厂模式，代码大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStyle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是汽车的发动机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Underpan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStyle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是汽车的底盘"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStyle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是汽车的轮胎"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Engine engine = <span class="keyword">new</span> Engine();</span><br><span class="line">        Underpan underpan = <span class="keyword">new</span> Underpan();</span><br><span class="line">        Wheel wheel = <span class="keyword">new</span> Wheel();</span><br><span class="line">        ICar car = <span class="keyword">new</span> Car(underpan, wheel, engine);</span><br><span class="line">        car.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，调用者为了得到汽车，还需要自己实例化发动机、轮和底盘。这严重违反了迪米特法则，耦合度太高。并且非常不利于扩展。<br>另外，这个例子中发动机、轮和底盘还是比较具体的，在实际应用中，可能这些产品的组件也都是抽象的，调用者根本不知道怎样组装产品。所以，就需要用到工厂模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICar <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Engine engine = <span class="keyword">new</span> Engine();</span><br><span class="line">        Underpan underpan = <span class="keyword">new</span> Underpan();</span><br><span class="line">        Wheel wheel = <span class="keyword">new</span> Wheel();</span><br><span class="line">        ICar car = <span class="keyword">new</span> Car(underpan, wheel, engine);</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IFactory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">        ICar car = factory.createCar();</span><br><span class="line">        car.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了工厂模式之后，调用端的耦合度大大降低。对于工厂类，可扩展性也大大增加。并且调用者不需要关心底层是如何组装汽车的，只需要实例化工厂类，调用其方法就行了。</p>
<hr>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</p>
<h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><p><img src="%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.jpg" alt=""></p>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prototype = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"原型模式实现类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcretePrototype cp = <span class="keyword">new</span> ConcretePrototype();</span><br><span class="line">        ConcretePrototype clonecp = (ConcretePrototype) cp.clone();</span><br><span class="line">        clonecp.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。</li>
<li>使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。</li>
</ol>
<p>所以，如果需要重复创建相似对象时，可以考虑使用原型模式。假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。还记得单例模式吗？单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。</li>
<li>深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。</li>
</ol>
<hr>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。</p>
<h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h4><p><img src="%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg" alt=""></p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>模板方法是编程中经常用到的模式。例如，有一个程序员A拿到了一个任务，要对一个整型数组进行排序并打印出来。这个任务可以分成两部分，排序和打印输出。程序员A首先很快地完成了打印的任务，由于排序的部分比较麻烦，于是A把排序的任务交给了B。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showResult</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sort(arr);</span><br><span class="line">        System.out.print(<span class="string">"排序结果："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B拿到任务后很快完成了排序的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSort</span> <span class="keyword">extends</span> <span class="title">AbstractSort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            xxxSort(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">xxxSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，A再进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortAndShow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        AbstractSort as = <span class="keyword">new</span> ConcreteSort();</span><br><span class="line">        as.showResult(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成。<br>这种某些人先完成其中一部分功能，并将其它功能声明为抽象方法再交由其他人完成的模式就叫做模板方法模式。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>模板方法模式由一个抽象类和一个（或一组）实现类通过继承结构组成，抽象类中的方法分为三种：</p>
<ol>
<li>抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。</li>
<li>模板方法：由抽象类声明并加以实现。一般来说，模板方法调用抽象方法来完成主要的逻辑功能，并且，模板方法大多会定义为final类型，指明<strong>主要的逻辑功能在子类中不能被重写</strong>。</li>
<li>钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模板方法的逻辑。</li>
<li>抽象类的任务是搭建逻辑的框架，通常由经验丰富的人员编写，因为抽象类的好坏直接决定了程序是否稳定性。实现类用来实现细节。抽象类中的模板方法正是通过实现类扩展的方法来完成业务逻辑。只要实现类中的扩展方法通过了单元测试，在模板方法正确的前提下，整体功能一般不会出现大的错误。<h4 id="优点及适用场景"><a href="#优点及适用场景" class="headerlink" title="优点及适用场景"></a>优点及适用场景</h4></li>
<li>容易扩展。一般来说，抽象类中的模板方法是不易反生改变的部分，而抽象方法是容易反生变化的部分，因此通过增加实现类一般可以很容易实现功能的扩展，符合<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">开闭原则</a>。</li>
<li>便于维护。对于模板方法模式来说，正是由于他们的主要逻辑相同，才使用了模板方法，假如不使用模板方法，任由这些相同的代码散乱的分布在不同的类中，维护起来是非常不方便的。</li>
<li>比较灵活。因为有钩子方法，因此，子类的实现也可以影响父类中主逻辑的运行。但是，在灵活的同时，由于子类影响到了父类，违反了里氏替换原则，也会给程序带来风险。这就对抽象类的设计有了更高的要求。</li>
<li>在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模板方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。</li>
</ol>
<hr>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p>
<h4 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h4><p><img src="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt=""><br>在软件系统中经常会有这样的需求：如果一个对象的状态发生改变，某些与它相关的对象也要随之做出相应的变化。能实现这一个点的方案很多，但无疑观察者模式是主流的一个选择。</p>
<h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p>在基础的观察者模式中，包含以下四种角色：</p>
<ol>
<li><strong>被观察者</strong>：从类图中可以看到，类中有一个用来存放观察者对象的Vector容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。</li>
<li><strong>观察者</strong>：观察者角色一般是一个接口，它只有一个update方法，在被观察者状态发生变化时，这个方法就会被触发调用。</li>
<li><strong>具体的被观察者</strong>：使用这个角色是为了便于扩展，可以在此角色中定义具体的业务逻辑。</li>
<li><strong>具体的观察者</strong>：观察者接口的具体实现，在这个角色中，将定义被观察者对象状态发生变化时所要处理的逻辑。<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Vector obs = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer obs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obs.add(obs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delObserver</span><span class="params">(Observer obs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obs.remove(obs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer o : obs) &#123;</span><br><span class="line">            o.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"被观察者事件反生"</span>);</span><br><span class="line">        <span class="keyword">this</span>.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"观察者1收到信息，并进行处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"观察者2收到信息，并进行处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject sub = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        sub.addObserver(<span class="keyword">new</span> ConcreteObserver1()); <span class="comment">//添加观察者1</span></span><br><span class="line">        sub.addObserver(<span class="keyword">new</span> ConcreteObserver2()); <span class="comment">//添加观察者2</span></span><br><span class="line">        sub.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行的结果：<blockquote>
<p>被观察者事件反生<br>观察者1收到信息，并进行处理。<br>观察者2收到信息，并进行处理。</p>
</blockquote>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4></li>
<li>观察者与被观察者之间是属于轻度的关联关系，并且是抽象耦合的，这样，对于两者来说都比较容易进行扩展。</li>
<li>观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理。但同时，这也算是观察者模式一个缺点，由于是链式触发，当观察者比较多的时候，性能问题是比较令人担忧的。并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>java语言中，有一个接口Observer，以及它的实现类Observable，对观察者角色常进行了实现。我们可以在jdk的api文档具体查看这两个类的使用方法。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2020/08/09/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>记录Java线程池相关知识。</p>
<a id="more"></a>
<h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><p>随着计算机行业的飞速发展，多核CPU逐渐成为主流。多线程成为了提升服务器性能的必备武器。<br>线程池是一种<code>池化技术</code>，用于管理多线程，经常出现在多线程服务器中，例如MySQL。</p>
<hr>
<h3 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h3><p>线程过多会带来额外的开销，包括线程的创建和调度以及销毁，导致系统性能的降低，最终有可能导致系统内存耗尽。而使用线程池则可以避免这些问题：</p>
<ol>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li><strong>提高响应速度</strong>：无需等待创建线程即可立即执行任务。</li>
<li><strong>提高线程的可管理性</strong>：对线程进行进行统一的分配、调优和监控。</li>
<li><strong>提供额外功能</strong>：线程池还有许多拓展的功能，例如延时定时线程池，可对任务延期执行或者定期执行。</li>
</ol>
<hr>
<h3 id="线程池核心设计"><a href="#线程池核心设计" class="headerlink" title="线程池核心设计"></a>线程池核心设计</h3><p>Java线程池的核心实现类是<code>ThreadPoolExecutor</code>，其类图如下:<br><img src="ThreadPoolExecutor%E7%B1%BB%E5%9B%BE.png" alt=""><br>ThreadPoolExecutor的顶层接口是<code>Executor</code>，它提供了一种思想，将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，只需提供<code>Runnable</code>对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。<br>而<code>ExecutorService</code>接口则拓展了一些功能：</p>
<ol>
<li>扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法。</li>
<li>提供了管控线程池的方法，比如停止线程池的运行。</li>
</ol>
<p><code>AbstractExecutorService</code>则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。<br>最下层的实现类<code>ThreadPoolExecutor</code>实现最复杂的运行部分。一方面维护自身的生命周期，另一方面管理线程和任务，使两者良好的结合从而执行并行任务。<br><code>ThreadPoolExecutor</code>运行流程如下：<br><img src="ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""><br>线程池内部构建了一个生产者消费者模型，将线程与任务解耦，并不直接关联，从而良好的缓冲任务，复用线程。<br>任务管理充当生产者，任务提交后，线程池会进行后续的判断：是直接申请线程执行任务，还是将其加入到阻塞队列进行等待，亦或是直接拒绝该任务。<br>线程管理则充当消费者，根据任务的请求进行线程的分配，执行完任务又会继续获取新的任务，直到任务全部获取完成，对线程进行回收。</p>
<hr>
<h3 id="线程池生命周期"><a href="#线程池生命周期" class="headerlink" title="线程池生命周期"></a>线程池生命周期</h3><p><code>ThreadPoolExecutor</code>的运行状态有5种：<br><img src="ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81.png" alt=""><br>生命周期转换图如下：<br><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p>
<hr>
<h3 id="任务执行机制"><a href="#任务执行机制" class="headerlink" title="任务执行机制"></a>任务执行机制</h3><p>前面提到了任务提交后线程会进行判断如何处理任务，其主要执行机制如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是<code>RUNNING</code>，则直接拒绝，线程池要保证在<code>RUNNING</code>的状态下执行任务。</li>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中，该任务会等到线程空闲时执行。</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据<strong>拒绝策略</strong>来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>流程图如下：<br><img src="%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt=""></p>
<hr>
<h3 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h3><p>任务缓冲模块是线程池管理任务的核心部分。线程池的作用是将任务与线程解耦，再对任务进行分配。线程池是通过<strong>阻塞队列</strong>来实现的。阻塞队列对任务进行缓存，线程则从阻塞队列取出任务执行。<br>阻塞队列是一个双端队列，生产者往队列添加元素，消费者从队列取出元素。使用不同的队列可以实现不同的任务存取策略：<br><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%88%90%E5%91%98.png" alt=""></p>
<hr>
<h3 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h3><p>任务进行提交后，执行的情况有两种：一种是线程池直接创建一个线程执行该任务，另一个是从阻塞队列中获取任务并执行，该线程执行完任务会继续从阻塞队列中获取任务执行。前者这种情况仅出现在线程初始创建的时候，后者是大多数情况。<br>这部分策略由<code>getTask</code>方法实现，其执行流程如下图：<br><img src="%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt=""></p>
<hr>
<h3 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h3><p>任务拒绝模块是线程池的保护策略，当阻塞队列已满，且线程池中的线程数目已达到<code>maximumPoolSize</code>时，线程池就会根据拒绝策略处理新的任务。<br>用户可以自定义拒绝策略，也可以选择JDK提供的4中拒绝策略：<br><img src="%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png" alt=""></p>
<hr>
<h3 id="worker线程"><a href="#worker线程" class="headerlink" title="worker线程"></a>worker线程</h3><p>…</p>
<hr>
<h3 id="线程池几个重要的方法"><a href="#线程池几个重要的方法" class="headerlink" title="线程池几个重要的方法"></a>线程池几个重要的方法</h3><ul>
<li>execute()</li>
<li>submit()</li>
<li>shutdown()</li>
<li>shutdownNow()<h4 id="execute-和-submit-区别"><a href="#execute-和-submit-区别" class="headerlink" title="execute() 和 submit() 区别"></a>execute() 和 submit() 区别</h4><code>submit()</code>有返回值，<code>execute()</code>无返回值。<h4 id="shutdown-和-shutdownNow-区别"><a href="#shutdown-和-shutdownNow-区别" class="headerlink" title="shutdown() 和 shutdownNow() 区别"></a>shutdown() 和 shutdownNow() 区别</h4><code>shutdown()</code>和<code>shutdownNow()</code>是用来关闭线程池的。<br><code>shutdown()</code>: 此方法执行后不得向线程池再提交任务，如果有空闲线程则销毁空闲线程，等待所有正在执行的任务及位于阻塞队列中的任务执行结束，然后销毁所有线程。<br><code>shutdownNow()</code>: 此方法执行后不得向线程池再提交任务，如果有空闲线程则销毁空闲线程，取消所有位于阻塞队列中的任务，并将其放入List容器，作为返回值。取消正在执行的线程(设置正在执行线程的中断标志位,调用线程的<code>interrupt</code>方法来中断线程)。</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(2)</title>
    <url>/2020/08/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2/</url>
    <content><![CDATA[<p>记录常见的设计模式(2)。</p>
<a id="more"></a>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.gif" alt=""><br>责任链模式涉及的角色如下：</p>
<ol>
<li><strong>抽象处理类</strong>：定义了处理请求的接口或者抽象类，提供了处理请求的的方法和设置下一个处理者的方法。</li>
<li><strong>具体处理类</strong>：实现或者继承抽象类角色，处理具体逻辑。<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h4 id="抽象处理类代码"><a href="#抽象处理类代码" class="headerlink" title="抽象处理类代码"></a>抽象处理类代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求传递，注意final，子类不可重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Demand demand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &gt;= demand.demandLevel()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.report(demand);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.nextHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"事情太严重，需报告上一级"</span>);</span><br><span class="line">                <span class="keyword">this</span>.nextHandler.handleMessage(demand);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"我就是boss，没有上头"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(Demand demand)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
抽象类定义了下一级传递的对象以及自身的等级。如果当前对象等级达到了要求，会执行<code>report()</code>方法，具体逻辑由子类实现，否则就会将需求交由下一级对象处理。<h4 id="具体处理类代码"><a href="#具体处理类代码" class="headerlink" title="具体处理类代码"></a>具体处理类代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 技术经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TechnicalManager</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TechnicalManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(Demand demand)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"需求："</span> + demand.detail());</span><br><span class="line">        System.out.println(getClass().getSimpleName() + <span class="string">"：小猿我挺你，这个需求不干"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// boss</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(Demand demand)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"需求："</span> + demand.detail());</span><br><span class="line">        System.out.println(getClass().getSimpleName() + <span class="string">"：你们打一架吧，打赢的做决定"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
具体处理类代码很少，主要就是设置自身的等级以及重写<code>report()</code>方法。接下来实例化类：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demand demandA = <span class="keyword">new</span> DemandA(); <span class="comment">// 请求等级低</span></span><br><span class="line">        Demand demandB = <span class="keyword">new</span> DemandB(); <span class="comment">// 请求等级高</span></span><br><span class="line"></span><br><span class="line">        Boss boss = <span class="keyword">new</span> Boss();</span><br><span class="line">        TechnicalManager technicalManager = <span class="keyword">new</span> TechnicalManager();</span><br><span class="line">        technicalManager.setNextHandler(boss); <span class="comment">// 设置下一级传递的对象</span></span><br><span class="line"></span><br><span class="line">        technicalManager.handleMessage(demandA);</span><br><span class="line">        System.out.println(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">        technicalManager.handleMessage(demandB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里创建了两个需求，设置了技术经理的下一级传递对象为老板，并将两个需求交给了技术经理处理。输出：<blockquote>
<p>需求：加一张露一点点的图<br>TechnicalManager：小猿我挺你，这个需求不干<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>需求：加一张露一点点的图<br>TechnicalManager：事情太严重，需报告上一级<br>Boss：你们打一架吧，打赢的做决定</p>
</blockquote>
</li>
</ol>
<p>可以看到，级别较低的需求技术经理自己处理了，级别较高的需求技术经理交由老板处理。这样就形成了一条链。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li><strong>降低耦合度</strong>：客户端不需要知道需求最后由哪个处理者处理，处理者也不需要知道处理者之间的传递关系，处理类可以灵活地组织与分配。</li>
<li><strong>良好拓展性</strong>：具体处理类的代码很简单，只需要重写当前处理者的具体业务逻辑即可，容易拓展。<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5>当责任链比较长时，出现了错误比较不好排查，而且也会影响系统的性能。<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>如果<code>if...else...</code>语句很长逻辑看起来很乱时，就可以使用责任链模式，可以使代码逻辑清晰，但编写逻辑时要注意不要出现循环链的情况。</li>
</ol>
<hr>
<h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>门面模式（Facade Pattern），也称之为外观模式，其核心为：外部与一个子系统的通信必须通过一个统一的外观对象进行，使得子系统更易于使用。</p>
<h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><p><img src="%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fridge</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们现在有这几样电器，如果我们想把它们全部关掉，就需要这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> TV().turnOff();</span><br><span class="line">    <span class="keyword">new</span> Fridge().turnOff();</span><br><span class="line">    <span class="keyword">new</span> Light().turnOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时如果有一个电闸</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Brake</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TV tv = <span class="keyword">new</span> TV();</span><br><span class="line">    <span class="keyword">private</span> Fridge fridge = <span class="keyword">new</span> Fridge();</span><br><span class="line">    <span class="keyword">private</span> Light light = <span class="keyword">new</span> Light();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOffAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv.turnOff();</span><br><span class="line">        fridge.turnOff();</span><br><span class="line">        light.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以一次性全部关掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Brake().turnOffAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是门面模式。通过加一层封装使得客户端的调用变得简单。即使底层逻辑发生了变化，上层调用也不会发生变化。</p>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p>Java日志模块的开发就是利用了门面模式。<br>常见的Java日志框架有<code>J.U.L</code>, <code>Log4j</code>, <code>LogBack</code>, <code>Log4j2</code>等等。在《阿里巴巴Java开发手册》中明确指出<br><img src="%E6%97%A5%E5%BF%97%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.png" alt=""></p>
<p>那么为什么需要门面模式呢？其实就是为了屏蔽底层日志框架的具体实现。这样即使有天要更换日志框架，只需要更换jar包，修改一下相关的配置文件就可以了。而不用大费周章将整个日志实现都进行更换。</p>
<hr>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
<h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h4><ul>
<li>类适配器模式<br><img src="%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.gif" alt=""></li>
<li>对象适配器模式<br><img src="%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.gif" alt=""><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4>例如我们买了一台电脑想要上网，由于现在很多电脑已经没有了网线的接口，如果想要连接网线上网，就需要一个适配器将二者连接起来实现上网的功能。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待适配的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"上网"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转接头</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetToUsb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
接下来是转接头的具体实现，本例实现的是上网的功能。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类适配器模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">NetToUsb</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象适配器模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">NetToUsb</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看出，由于Java的<strong>单继承</strong>特性，类适配器模式有较大局限性。而对象适配器模式则更灵活，可以根据传入的不同的<code>Adaptee</code>对象实现适配多个不同的被适配类的功能。因此推荐使用对象适配器模式。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 联网，由适配器完成功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">net</span><span class="params">(NetToUsb adapter)</span> </span>&#123;</span><br><span class="line">        adapter.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter(adaptee);</span><br><span class="line">        computer.net(adapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4>当系统需要使用一些现有的类，而这些类的接口并不符合系统的需要，甚至没有这些类的源码，这时就可以使用适配器模式将两者进行适配。</li>
</ul>
<hr>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<h4 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h4><p><img src="%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.gif" alt=""></p>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>例如我们需要新建一些电脑，这些电脑拥有两个属性，品牌和样式。例如品牌有苹果、联想等等，而样式有台式机、手提等等。这时就可以利用桥接模式将这两个独立的属性组合在一起，完成实例的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 品牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 苹果和联想，两个品牌的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"苹果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lenovo</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"联想"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Brand brand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入电脑品牌进行桥接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        brand.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体样式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desktop</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Desktop</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.info();</span><br><span class="line">        System.out.println(<span class="string">"台式机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.info();</span><br><span class="line">        System.out.println(<span class="string">"笔记本"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们通过组合的方式代替多继承的形式将两个维度联系在一起，完成实例的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer apple = <span class="keyword">new</span> Laptop(<span class="keyword">new</span> Apple());</span><br><span class="line">        apple.info(); <span class="comment">// 打印 "苹果笔记本"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优点及应用场景"><a href="#优点及应用场景" class="headerlink" title="优点及应用场景"></a>优点及应用场景</h4><p>由于最直接的多继承方式违背了<strong>单一职责原则</strong>，桥接模式利用组合的方式将多维度进行解耦，极大减少了子类的个数，降低了维护的成本。<br>因此，当一个类内部具备两种以上的变化维度时，使用桥接模式就可以解耦这些变化的维度，使高层代码的架构更加稳定，也更方便管理和维护。</p>
<hr>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<h4 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h4><p><img src="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.gif" alt=""><br>代理模式主要有以下几个角色：</p>
<ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。<br>而代理模式根据代理的创建时机又可以分为<strong>静态代理模式</strong>和<strong>动态代理模式</strong>。</li>
</ol>
<ul>
<li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li>
<li>动态：在程序运行时，运用反射机制动态创建而成。<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4>假设我们要租房，很多情况下都会通过中介进行交易。中介此时就相当于代理类代理了房东出租房子，同时中介还会进行一些其他的操作，例如带看房子、收取中介费等等。</li>
</ul>
<p>首先我们需要一个抽象主题类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此类通过接口声明了真实的主题和代理对象实现的业务方法，也就是租房子。</p>
<p>接下来我们需要一个被代理的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"房东要出租房子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例中房东即为被代理的对象，他想要实现的业务是租房子。这时代理类出场了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        host.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，代理类通过传入被代理的对象、实现相同的抽象接口，帮助被代理类完成了相同的功能。我们还可以在代理类新增一些方法以进行拓展。最后我们在客户端进行调用即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(host);</span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上即为静态代理的一个例子。可以看出，静态代理的代理类在编译时已经写死，如果代理类需要为多个目标进行服务，则需要写很多代理类，这是很不方便的。于是便有了动态代理模式，它可以在运行时通过<strong>反射</strong>动态地生成代理类，为不同的目标进行服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rent rent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(), rent.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(rent, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在动态代理模式中，在程序运行之前并不存在真正的代理类，我们只需要实现<code>InvocationHandler</code>接口，通过传入抽象主题类以及重写<code>invoke</code>方法，并且实现一个通过反射获取代理的方法即可实现代理模式。最后我们在客户端进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DynamicProxy dp = <span class="keyword">new</span> DynamicProxy();</span><br><span class="line">        dp.setRent(<span class="keyword">new</span> Host());</span><br><span class="line">      	<span class="comment">// 动态生成代理类</span></span><br><span class="line">        Rent dProxy = (Rent) dp.getProxy();</span><br><span class="line">        dProxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态代理和动态代理的优缺点"><a href="#静态代理和动态代理的优缺点" class="headerlink" title="静态代理和动态代理的优缺点"></a>静态代理和动态代理的优缺点</h4><ol>
<li><p>静态代理实现简单，但一个代理类只能为一个目标进行服务，而动态代理则可以动态地为多个目标进行服务。</p>
</li>
<li><p>静态代理在编译时就生成了class字节码文件，可以直接使用，效率较高；为动态代理通过反射的方法，比较消耗系统性能，但同时也比较灵活。</p>
</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>使用代理模式主要有两个目的：<strong>保护目标对象</strong>和<strong>增强目标对象</strong>。代理模式大量应用在框架当中，例如<code>spring</code>中的<code>AOP(面向切面编程)</code>就是利用了动态代理模式增强了目标对象。</p>
<hr>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>访问者模式是一种操作一组对象的操作，目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。</p>
<h4 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h4><p><img src="%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>原始的访问者模式比较复杂，实现了“双重分派”，设计了一个回调再回调的机制。这里记录简化版的访问者模式。</p>
<p>假设要递归遍历某个文件夹的所有子文件夹和文件，找出<code>.java</code>类型的文件，普通的做法是递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(File dir, List&lt;File&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (File file : Objects.requireNonNull(dir.listFiles())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(<span class="string">".java"</span>)) &#123;</span><br><span class="line">            list.add(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            scan(file, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述做法的缺陷在于，扫描目录和处理<code>.java</code>文件的逻辑混在了一起，如果要新添一个清理<code>.class</code>文件的功能，就需要再写一个扫描的逻辑。因此，访问者模式把数据结构和对其的操作分开，如果要新添功能，只要新增访问者即可，不必修改现有的逻辑。</p>
<p>首先定义访问者接口，包含了访问者能做的事。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitDir</span><span class="params">(File dir)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitFile</span><span class="params">(File file)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，定义数据结构，它能同时持有文件夹和文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Structure</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根目录</span></span><br><span class="line">    <span class="keyword">private</span> File path;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Structure</span><span class="params">(File path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给数据结构增加一个<code>handle</code>方法，传入访问者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Structure</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根目录</span></span><br><span class="line">    <span class="keyword">private</span> File path;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Structure</span><span class="params">(File path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        scan(<span class="keyword">this</span>.path, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(File file, Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            visitor.visitDir(file);</span><br><span class="line">            <span class="keyword">for</span> (File f : file.listFiles()) &#123;</span><br><span class="line">                scan(f, visitor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            visitor.visitFile(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于把访问者的行为抽象出来了。如果要查找出所有<code>.java</code>文件，就传入一个<code>JavaFileVisitor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Structure s = <span class="keyword">new</span> Structure(<span class="keyword">new</span> File(<span class="string">"根目录位置"</span>));</span><br><span class="line">s.handle(<span class="keyword">new</span> JavaFileVisitor());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaFileVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"visit dir: "</span> + dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"visit file: "</span> + file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要添加其他功能，就传入相应的访问者就行了，每个访问者都有自己的实现。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程(1)</title>
    <url>/2020/12/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/</url>
    <content><![CDATA[<p>记录多线程相关知识(1) –&gt; synchronized</p>
<a id="more"></a>

<h3 id="synchronized作用"><a href="#synchronized作用" class="headerlink" title="synchronized作用"></a>synchronized作用</h3><p>保证同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。</p>
<p>如果不使用<code>synchronized</code>，在多线程情况下，代码的执行可能会出现问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 等待两个线程执行完毕</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这段代码，可以发现<code>i</code>的值几乎每次都不一样，但基本上都小于我们想要的值<code>20000</code>。这是由于<code>i++</code>并不是一个原子操作，它包含了以下三个步骤：</p>
<ol>
<li>读取<code>i</code></li>
<li>将<code>i</code>加一</li>
<li>将<code>i</code>的值写到内存中</li>
</ol>
<p>此时如果某一个线程执行到了步骤1或2，还未来得及将新数据写会到内存中，又有一个新线程执行到了步骤1，那么新线程读取到的值将不是最新的值。这也导致了最后的结果会比<code>20000</code>小。</p>
<hr>
<h3 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h3><p>synchronized分为两大类：</p>
<ol>
<li><p><strong>对象锁</strong>：包括<strong>方法锁</strong>(默认锁对象为<code>this</code>当前实例对象)和<strong>同步代码块锁</strong>(自己指定锁对象)。</p>
</li>
<li><p><strong>类锁</strong>：指<code>synchronized</code>修饰<strong>静态</strong>的方法或指定锁为<strong>Class对象</strong>。</p>
</li>
</ol>
<h4 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h4><ol>
<li>代码块形式</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，无论运行多少次，结果都为<code>20000</code>。我们利用对象锁保证了同一时刻只有一个线程进入被锁住的代码块中，这样每个线程每次读取到的<code>i</code>值都是最新的了。</p>
<ol start="2">
<li><p>方法修饰符形式</p>
<p>与对象锁类似，只不过<code>synchronized</code>作用的范围改为了方法，粒度变粗了。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Test instance = <span class="keyword">new</span> Test();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 传入的Runnable对象必须是同一个，否则两个线程仍有可能同时进入addTask()方法中</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addTask();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; ++j) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一样可以得到<code>20000</code>的正确值。</p>
<h4 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h4><p>类锁同样有两种形式：</p>
<ol>
<li>作用于<code>static</code>方法</li>
</ol>
<p>由于对象锁的方法锁默认锁的是当前的实例对象，所以我们必须传入同一个实例。如果我们想传入不同的实例同时使方法锁生效，就需要将方法声明为<code>static</code>类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 无需传入同一个实例对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addTask();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; ++j) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时依然可以得到正确答案。</p>
<ol start="2">
<li><code>synchronized(*.class)</code>作用于代码块</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类的Class对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Test<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; ++j) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于两个线程传入的实例都为<code>Test</code>类的对象，所以使用<code>Test.class</code>亦可达到效果。</p>
<hr>
<h3 id="synchronized性质"><a href="#synchronized性质" class="headerlink" title="synchronized性质"></a>synchronized性质</h3><h4 id="可重入性质"><a href="#可重入性质" class="headerlink" title="可重入性质"></a>可重入性质</h4><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p>可重入指的是同一线程的外层函数获得锁后，内层函数可以直接再次获取该锁。</p>
<h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><p>可重入性质可以避免死锁，提升封装性。</p>
<h5 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h5><ol>
<li>同一方法是可重入的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.method();</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt++ == <span class="number">0</span>) method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码打印的结果是<code>2</code>，证明了<code>synchronized</code>可重入性质是适用于同一方法的。</p>
<ol start="2">
<li>同一个类中的不同方法是可重入的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.method1();</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的结果依然是<code>2</code>，证明了同一个类中的不同方法也是可重入的。</p>
<ol start="3">
<li>不同类中的方法是可重入的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubTest subTest = <span class="keyword">new</span> SubTest();</span><br><span class="line">        subTest.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是父类方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTest</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类方法"</span>);</span><br><span class="line">        <span class="keyword">super</span>.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果打印的是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是子类方法</span><br><span class="line">我是父类方法</span><br></pre></td></tr></table></figure>

<p>证明了即使不是同类的方法依然可以重入。</p>
<h4 id="不可中断性质"><a href="#不可中断性质" class="headerlink" title="不可中断性质"></a>不可中断性质</h4><p>一旦锁被别的线程获得了，如果本线程还想获得，就得一直等待下去，直到别的线程释放了锁。</p>
<hr>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="获取锁和释放锁的时机"><a href="#获取锁和释放锁的时机" class="headerlink" title="获取锁和释放锁的时机"></a>获取锁和释放锁的时机</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.m1();</span><br><span class="line">        test.m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是synchronized形式的锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"我是lock形式的锁"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中，<code>m1</code>和<code>m2</code>方法是等价的。也就是说，线程进入<code>m1</code>方法后，会获取一把内置锁，当方法结束或抛出异常时都会释放锁，相当于<code>m2</code>中<code>finally</code>块内执行的<code>unlock</code>方法。</p>
<h4 id="加锁和释放锁的原理"><a href="#加锁和释放锁的原理" class="headerlink" title="加锁和释放锁的原理"></a>加锁和释放锁的原理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单写一个对象锁，然后利用<code>javac</code>命令对以上代码进行编译，得到<code>Test.class</code>字节码文件。</p>
<p>接下来，我们利用<code>javap -verbose Test.class</code>命令对字节码文件进行反汇编，我们在控制台关注以下几条输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;5, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #2                  &#x2F;&#x2F; Field object:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">         3: dup</span><br><span class="line">         4: astore_1</span><br><span class="line">         5: monitorenter</span><br><span class="line">         6: getstatic     #2                  &#x2F;&#x2F; Field object:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">         9: dup</span><br><span class="line">        10: astore_2</span><br><span class="line">        11: monitorenter</span><br><span class="line">        12: aload_2</span><br><span class="line">        13: monitorexit</span><br><span class="line">        14: goto          22</span><br><span class="line">        17: astore_3</span><br><span class="line">        18: aload_2</span><br><span class="line">        19: monitorexit</span><br><span class="line">        20: aload_3</span><br><span class="line">        21: athrow</span><br><span class="line">        22: aload_1</span><br><span class="line">        23: monitorexit</span><br><span class="line">        24: goto          34</span><br><span class="line">        27: astore        4</span><br><span class="line">        29: aload_1</span><br><span class="line">        30: monitorexit</span><br><span class="line">        31: aload         4</span><br><span class="line">        33: athrow</span><br><span class="line">        34: return</span><br></pre></td></tr></table></figure>

<p>可以看到，线程在第5和11步获取到了两把<code>moniterenter</code>锁，这是由于<code>synchronized</code>锁的可重入性质。而后在第13或19步、23或30步获取了<code>monitorexit</code>锁，这是由于线程有可能在代码执行完毕或者抛出异常这两种情况释放锁，只有当当前线程释放了所有获得到的锁，才算真正释放了锁。</p>
<h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><p>可重入性质利用了<strong>加锁次数计数器</strong>。JVM负责跟踪对象被加锁的次数，每当相同的线程获取了锁，计数器就加一，释放了锁就减一。当计数器为0时，就可以认定锁已经被完全释放了。</p>
<h4 id="可见性原理"><a href="#可见性原理" class="headerlink" title="可见性原理"></a>可见性原理</h4><p>可见性原理涉及到了<strong>Java内存模型</strong>。详情可见<a href="http://irvlin.xyz/2020/06/24/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E6%A8%A1%E5%9E%8B/#more">Java内存模型</a>。</p>
<p>线程在进入<code>synchronized</code>修饰的代码中，将会从主存中获取最新的值，并且在释放锁之前，会强行将最新的值刷回主存，以保证<strong>可见性</strong>。</p>
<hr>
<h3 id="synchronized缺陷"><a href="#synchronized缺陷" class="headerlink" title="synchronized缺陷"></a>synchronized缺陷</h3><ol>
<li><p>效率低</p>
<p><code>synchronized</code>锁释放的情况少、获得锁时不能设定超时时间、也不能中断一个正在试图获得锁的线程。而<code>lock</code>锁就可以弥补这些缺陷。</p>
</li>
<li><p>不灵活</p>
<p><code>synchronized</code>锁加解锁的时机单一，每个锁只有单一的条件。而<strong>读写锁</strong>就可以在写的时候加锁，读的时候不加锁。</p>
</li>
<li><p>无法知道是否成功获得了锁</p>
<p><code>synchronized</code>锁无法像其他锁一样获取锁的状态。</p>
</li>
</ol>
<hr>
<h3 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h3><ol>
<li><p>使用注意点</p>
<p>锁对象不能为空、作用域不得过大、避免死锁。</p>
</li>
<li><p>如何选择锁</p>
<p>优先使用<code>J.U.C</code>包下的类，尽量避免自己写，减少出错的可能。能用<code>synchronized</code>就尽量用，因为代码量较小、使用较简单，出错的几率也就小了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
        <category>synchronized</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发知识笔记</title>
    <url>/2020/12/05/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Java并发知识体系精讲笔记</p>
<a id="more"></a>

<h4 id="实现多线程的种类"><a href="#实现多线程的种类" class="headerlink" title="实现多线程的种类"></a>实现多线程的种类</h4><p>根据<code>Oracle</code>官方文档，实现多线程一共有两种方法：</p>
<ol>
<li>实现<code>Runnable</code>接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Runnable实现多线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>继承<code>Thread</code>类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread实现多线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们进入<code>Thread</code>类源码，可以看到它的<code>run</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>target</code>是<code>Thread</code>类中定义的一个成员变量：<code>private Runnable target;</code>。于是乎我们便知道了：</p>
<ul>
<li>使用第一种方法，其实就是传入了<code>target</code>对象，执行了<code>Thread</code>类中的<code>run</code>方法；而第二种方法则是直接重写了<code>Thread</code>类的<code>run</code>方法。</li>
<li>对比两种方法，实现<code>Runnable</code>接口是更好的。首先<code>Java</code>类是单继承的，如果我们继承了<code>Thread</code>类，就无法再继承其他类，这极大限制了编程。其次，线程具体执行的任务应该与线程的创建解耦，而方法二重写了启动线程的方法，这是不太合理的。最后，如果我们想要多次创建任务，如果是方法二的话每次都要创建线程，这是非常浪费资源的；而方法一则可以通过线程池等手段降低创建、运行、销毁线程的开销。</li>
</ul>
<hr>
<h4 id="线程池创建线程"><a href="#线程池创建线程" class="headerlink" title="线程池创建线程"></a>线程池创建线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            service.submit(<span class="keyword">new</span> Test());</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>Executors</code>类源码，可以看到有这样一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                          namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                          <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">        t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出其实线程池也是通过传入<code>Runnable</code>对象新建线程实现多线程。</p>
<p>对于<code>Callable</code>和<code>Future</code>，底层也都是通过传入<code>Runnable</code>对象实现的多线程。</p>
<hr>
<h4 id="启动线程正确方法"><a href="#启动线程正确方法" class="headerlink" title="启动线程正确方法"></a>启动线程正确方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test().run();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">Thread-0</span><br></pre></td></tr></table></figure>

<p>说明，调用<code>Runnable</code>的<code>run</code>方法并不会启动一个新线程。进入<code>Thread</code>类源码，查看<code>start</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 如果不是0，说明当前线程已启动</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，代码会通过<code>threadStatus</code>检测当前线程是否已经启动，如果调用两次<code>start</code>方法，将会抛出异常。然后将会调用<code>start0</code>方法启动一个新线程。<code>start0</code>方法是一个本地方法：<code>private native void start0();</code>。</p>
<hr>
<h4 id="停止线程正确方法"><a href="#停止线程正确方法" class="headerlink" title="停止线程正确方法"></a>停止线程正确方法</h4><p>原理：使用<code>interrupt</code>来通知，而不是强制。</p>
<ol>
<li><code>run</code>方法中没有<code>sleep</code>或<code>wait</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">while</span> (num &lt;= Integer.MAX_VALUE / <span class="number">2</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(num + <span class="string">"是10000的倍数"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>run</code>方法中有<code>sleep</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">300</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(num + <span class="string">"是100的倍数"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0是100的倍数</span><br><span class="line">100是100的倍数</span><br><span class="line">200是100的倍数</span><br><span class="line">300是100的倍数</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at test.Test.run(Test.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>说明<code>sleep</code>可以响应中断。</p>
<hr>
<h4 id="sleep自动清除中断信号"><a href="#sleep自动清除中断信号" class="headerlink" title="sleep自动清除中断信号"></a>sleep自动清除中断信号</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= <span class="number">10000</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(num + <span class="string">"是100的倍数"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程在休眠5秒后打断了<code>thread</code>，但是通过打印的结果显示，<code>thread</code>在响应了中断后并没有停止，而是继续打印出100的倍数。这是因为<code>sleep</code>在响应了中断后，会<strong>将中断信号清除</strong>，此时<code>!Thread.currentThread().isInterrupted()</code>将会一直判定为<code>true</code>。</p>
<p>因此，如果想要响应中断并停止程序，需要在响应中断后再次去打断，恢复中断信号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &lt;= <span class="number">10000</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(num + <span class="string">"是100的倍数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 恢复中断信号</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="错误停止线程的方法"><a href="#错误停止线程的方法" class="headerlink" title="错误停止线程的方法"></a>错误停止线程的方法</h4><ol>
<li><code>Thread</code>的<code>stop</code>方法，会解锁已锁定的所有监视器，是不安全的。</li>
<li><code>Thread</code>的<code>suspend</code>方法，将会挂起当前线程并不释放锁，如果它没有被及时唤醒，或者其他线程需要获取当前锁，就很容易造成死锁。</li>
<li><code>volatile</code>设置<code>boolean</code>标记位。线程陷入阻塞状态时将无法被中断。</li>
</ol>
<hr>
<h4 id="interrupt原理"><a href="#interrupt原理" class="headerlink" title="interrupt原理"></a>interrupt原理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>interrupt0</code>为本地方法。</p>
<hr>
<h4 id="interrupted、isInterrupted"><a href="#interrupted、isInterrupted" class="headerlink" title="interrupted、isInterrupted"></a>interrupted、isInterrupted</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"isInterrupted: "</span> + thread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"interrupted: "</span> + thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">"isInterrupted: "</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">"isInterrupted: "</span> + thread.isInterrupted());</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">"Main thread is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isInterrupted: true</span><br><span class="line">interrupted: false</span><br><span class="line">isInterrupted: false</span><br><span class="line">isInterrupted: true</span><br></pre></td></tr></table></figure>

<p>这说明，<code>isInterrupted</code>方法用于获取中断标志，而<code>interrupted</code>方法用于获取中断标志并重置状态，且只与当前线程有关，与调用其的对象无关。</p>
<p>程序在第8行中断了<code>thread</code>线程，第9行获取<code>thread</code>线程状态为被打断状态；第10行获取中断标志并重置状态，但由于调用该方法的是主线程，所以打印<code>false</code>；11行与第10行一样；由于<code>isInterrupted</code>不会重置状态，所以12行获取的也是<code>true</code>。</p>
<hr>
<h4 id="线程六种状态"><a href="#线程六种状态" class="headerlink" title="线程六种状态"></a>线程六种状态</h4><ol>
<li>New</li>
<li>Runnable</li>
<li>Blocked</li>
<li>Waiting</li>
<li>Timed Waiting</li>
<li>Terminated</li>
</ol>
<p><img src="%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpeg" alt=""></p>
<p>若线程处于<code>Blocked</code>、<code>Waiting</code>或<code>Timed_waiting</code>三种状态，一般统称为<strong>阻塞状态</strong>。</p>
<hr>
<h4 id="wait、notify、notifyAll"><a href="#wait、notify、notifyAll" class="headerlink" title="wait、notify、notifyAll"></a>wait、notify、notifyAll</h4><ol>
<li>这三个方法都属于<code>Object</code>类，需要在被<code>synchronized</code>修饰的代码内执行。</li>
<li><code>wait</code>方法会立即释放当前锁资源；而<code>notify</code>需要等待对应线程执行完<code>synchronized</code>块中所有代码才会释放这把锁。</li>
<li><code>notify</code>方法随机唤醒一个正在该对象的监视器上等待的线程，具体逻辑根据不同的<code>JDK</code>版本而定；而<code>notifyAll</code>则唤醒所有。</li>
<li>一个线程刚被唤醒时，通常不能立刻抢到<code>monitor</code>锁，这时会从<code>Waiting</code>状态进入<code>Blocked</code>状态，抢到锁之后再进入<code>Runnable</code>状态。</li>
</ol>
<hr>
<h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h4><ol>
<li>使用阻塞队列</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Date&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(), <span class="string">"生产者"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(), <span class="string">"消费者"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">                    blockingQueue.put(date);</span><br><span class="line">                    System.out.println(<span class="string">"put: "</span> + date + <span class="string">", "</span> + blockingQueue.size() + <span class="string">"left"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"take: "</span> + blockingQueue.take() + <span class="string">", "</span> + blockingQueue.size() + <span class="string">"left"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>wait</code>和<code>notify</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Storage storage = <span class="keyword">new</span> Storage();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Storage storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Storage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            storage.put();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Storage storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Storage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            storage.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Date&gt; storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Storage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">this</span>.storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (storage.size() == maxSize) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        storage.add(date);</span><br><span class="line">        System.out.println(<span class="string">"put: "</span> + date + <span class="string">", "</span> + storage.size() + <span class="string">"left"</span>);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (storage.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"take "</span> + storage.poll() + <span class="string">", "</span> + storage.size() + <span class="string">"left"</span>);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="两个线程交替打印0-100奇偶数"><a href="#两个线程交替打印0-100奇偶数" class="headerlink" title="两个线程交替打印0-100奇偶数"></a>两个线程交替打印0-100奇偶数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(), <span class="string">"偶数"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(), <span class="string">"奇数"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i++);</span><br><span class="line">                    <span class="comment">// 唤醒其他线程</span></span><br><span class="line">                    o.notify();</span><br><span class="line">                    <span class="keyword">if</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 等待其他线程唤醒</span></span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h4><ol>
<li>ID</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<p>可以看出，主线程ID为1，而<code>JVM</code>在后台又帮我们创建了很多子线程用于监控管理等等，所以我们自己创建的子线程ID已经排到了11。</p>
<ol start="2">
<li>名字</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若我们没有指定名字，线程默认名从<code>Thread-0</code>递增。</p>
<p>若我们修改了名字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        setNativeName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，线程有两个名字，其中一个是在<code>native</code>层面的本地名字，一旦线程启动了，这个名字便不可修改。</p>
<ol start="3">
<li><p>守护线程</p>
<p>与普通线程不同，守护线程不影响<code>JVM</code>的退出，且普通线程执行我们的逻辑，而守护线程是为我们服务的。<code>JVM</code>默认创建的线程除了主线程都是守护线程。我们不应该手动将自己创建的线程设置为守护线程。</p>
</li>
<li><p>优先级</p>
<ul>
<li>优先级从1-10，默认为5，子线程继承父线程的优先级。</li>
<li>我们设计程序不应依赖优先级。代码运行时会将优先级映射到操作系统的优先级，由于不同的操作系统的优先级是不同的，因此可能造成程序出错，且优先级可能被操作系统修改。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="UncaughtException处理"><a href="#UncaughtException处理" class="headerlink" title="UncaughtException处理"></a>UncaughtException处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这段代码，虽然控制台会输出异常信息，但由于主线程输出了大量信息，我们很难发现子线程打印出的异常信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Exception()).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Exception()).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Exception()).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Exception()).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"caught exception"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Exception</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码并没有按我们的预期输出<code>caught exception</code>，而是在每一个线程都输出了异常信息。这说明<code>try-catch</code>无法捕获其他线程的异常。</p>
<p>基于以上情况，我们需要一个异常处理器以捕获不同线程中的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置异常处理器</span></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler((t, e) -&gt; System.out.println(<span class="string">"线程"</span> + t.getName() + <span class="string">"异常: "</span> + e));</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，对于四个子线程，程序都可以捕获到异常并输出在控制台中。</p>
<hr>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p>
<h5 id="必然死锁"><a href="#必然死锁" class="headerlink" title="必然死锁"></a>必然死锁</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test()).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        flag++;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了o1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了o2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了o2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了o1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码将引发死锁，两个线程永远处于阻塞状态。</p>
<h5 id="a-问题"><a href="#a-问题" class="headerlink" title="a++问题"></a>a++问题</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">            i.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用原子类<code>AtomicInteger</code>即可解决问题。</p>
<h5 id="逸出"><a href="#逸出" class="headerlink" title="逸出"></a>逸出</h5><ol>
<li>返回一个<code>private</code>对象</li>
<li>还未完成初始化就把对象提供给外界</li>
<li>构造函数中未初始化完毕就<code>this</code>赋值</li>
<li>隐式逸出：注册监听事件</li>
<li>构造函数中运行新线程</li>
</ol>
<hr>
<h4 id="多线程带来的性能问题"><a href="#多线程带来的性能问题" class="headerlink" title="多线程带来的性能问题"></a>多线程带来的性能问题</h4><ol>
<li><p>上下文切换</p>
<p>上下文切换可以认为是内核在CPU上对于进程进行以下的活动：</p>
<ol>
<li>挂起一个进程，将这个进程在CPU中的状态存储于内存中的某处。</li>
<li>在内存中检索下一个进程的上下文并将其在寄存器中恢复。</li>
<li>跳转到程序计数器所指向的位置，以恢复该进程。</li>
</ol>
</li>
<li><p>内存同步</p>
<p>为了数据的正确性，同步手段会使用禁止编译器优化，使CPU内的缓存失效。</p>
</li>
</ol>
<hr>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁发生在并发中。当两个或更多的线程(或进程)相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁。</p>
<h5 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h5><ol>
<li>互斥条件。进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li>请求与保持条件。当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件。进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li>循环等待条件。在发生死锁时，必然存在一个<strong>进程—资源</strong>的环形链。</li>
</ol>
<p>只要以上四个条件有一个不满足，就不会发生死锁。</p>
<h5 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h5><p>首先运行一个导致死锁的程序。在命令行输入<code>jsp</code>命令，找到运行的类对应的进程ID。接着运行<code>jstack 进程ID</code>命令并查看输出，可以看到有这几行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007fe57f814f58 (object 0x00000007956f3440, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007fe57f813ab8 (object 0x00000007956f3450, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">	at test.Test.run(Test.java:47)</span><br><span class="line">	- waiting to lock &lt;0x00000007956f3440&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x00000007956f3450&gt; (a java.lang.Object)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">	at test.Test.run(Test.java:35)</span><br><span class="line">	- waiting to lock &lt;0x00000007956f3450&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x00000007956f3440&gt; (a java.lang.Object)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p><code>jstack</code>命令帮我们定位了死锁的位置。</p>
<p>我们还可以使用<code>ThreadMXBean</code>类在代码中获取死锁相关的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test()).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        flag++;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="keyword">long</span>[] deadlockedThreads = threadMXBean.findDeadlockedThreads();</span><br><span class="line">        <span class="keyword">if</span> (deadlockedThreads != <span class="keyword">null</span> &amp;&amp; deadlockedThreads.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> deadlockedThread : deadlockedThreads) &#123;</span><br><span class="line">                ThreadInfo threadInfo = threadMXBean.getThreadInfo(deadlockedThread);</span><br><span class="line">                System.out.println(<span class="string">"发现死锁啦: "</span> + threadInfo.getThreadName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了o1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了o2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了o2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了o1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，控制台会输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-0拿到了o1</span><br><span class="line">Thread-1拿到了o2</span><br><span class="line">发现死锁啦: Thread-1</span><br><span class="line">发现死锁啦: Thread-0</span><br></pre></td></tr></table></figure>

<p>我们已经定位死锁了。</p>
<h5 id="修复死锁"><a href="#修复死锁" class="headerlink" title="修复死锁"></a>修复死锁</h5><h6 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosophers</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object leftChopstick;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object rightChopstick;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosophers</span><span class="params">(Object leftChopstick, Object rightChopstick)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftChopstick = leftChopstick;</span><br><span class="line">        <span class="keyword">this</span>.rightChopstick = rightChopstick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Philosophers[] tests = <span class="keyword">new</span> Philosophers[<span class="number">5</span>];</span><br><span class="line">        Object[] chopsticks = <span class="keyword">new</span> Object[tests.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chopsticks.length; i++) &#123;</span><br><span class="line">            chopsticks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tests.length; i++) &#123;</span><br><span class="line">            Object leftChopsticks = chopsticks[i];</span><br><span class="line">            Object rightChopsticks = chopsticks[(i+<span class="number">1</span>) % chopsticks.length];</span><br><span class="line">            tests[i] = <span class="keyword">new</span> Philosophers(leftChopsticks, rightChopsticks);</span><br><span class="line">            <span class="keyword">new</span> Thread(tests[i], <span class="string">"哲学家"</span> + (i + <span class="number">1</span>) + <span class="string">"号"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                doAction(<span class="string">"thinking"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (leftChopstick) &#123;</span><br><span class="line">                    doAction(<span class="string">"picked up left chopstick"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (rightChopstick) &#123;</span><br><span class="line">                        doAction(<span class="string">"picked up right chopstick - eating"</span>);</span><br><span class="line">                        doAction(<span class="string">"put down right chopstick"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    doAction(<span class="string">"put down left chopstick"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(String action)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + action);</span><br><span class="line">        Thread.sleep(((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一段时间，程序将陷入死锁，这时所有哲学家都拿起了左筷子，并且都在等待右筷子。</p>
<p>解决方案：</p>
<ol>
<li>改变其中一个哲学家拿筷子的顺序。将第20行代码改为<code>tests[i] = i == tests.length - 1 ? new Philosophers(rightChopsticks, leftChopsticks) : new Philosophers(leftChopsticks, rightChopsticks);</code>，这样永远都不会出现所有哲学家一起拿着左筷子的情况，也就不会发生死锁了。</li>
<li>服务员检查。每当一个哲学家要拿起筷子吃饭，就让服务员检查这是否会让程序陷入死锁，如果会就不让其拿起筷子。</li>
<li>餐票。提供<strong>比哲学家人数少一</strong>张餐票。如果餐票已经用完，哲学家就不能拿起筷子，直到其他哲学家用餐完毕归还餐票。</li>
<li>领导调节。首先先让哲学家正常吃饭，领导定期巡视。如果发现程序陷入死锁，就让其中一个哲学家放下筷子以解决死锁问题。可以终止其线程或让其回退。</li>
</ol>
<h5 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h5><ol>
<li>使用<code>Lock</code>的<code>tryLock</code>方法在指定的时间内获取锁，如果获取失败便不再尝试。</li>
<li>多使用并发类而不自己设计锁。</li>
<li>尽量降低锁的使用粒度。</li>
<li>尽量使用同步代码块。</li>
<li>分配资源之前先看能不能收回来，例如<a href="https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">银行家算法</a>。</li>
<li>尽量不要多个功能使用同一把锁。</li>
<li>避免锁的嵌套。</li>
</ol>
<hr>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>定义：虽然线程没有阻塞，也始终在运行，但是程序却得不到进展，因为线程始终重复做同样的事。有些类似于自旋锁。</p>
<hr>
<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>定义：当线程需要某些资源，但是却始终得不到，便处于饥饿的状态。</p>
<p>如果把线程的优先级设置得过低，或者某线程持有锁同时又永远不释放锁，或者某线程始终占有某文件的写锁等等，都有可能造成线程的饥饿。</p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常体系</title>
    <url>/2020/12/07/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>Java异常体系</p>
<a id="more"></a>

<p><img src="Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" alt=""></p>
<p><code>Throwable</code>为所有异常的父类。子类<code>Error</code>表示错误、<code>Exception</code>表示异常。</p>
<ol>
<li><p><code>Error</code></p>
<p><code>Error</code>是程序无法处理的错误，由<code>JVM</code>产生并抛出。发生这些异常时，<code>JVM</code>一般会终止线程。</p>
</li>
<li><p><code>Exception</code></p>
<p><code>Exception</code>是程序可以处理的异常，又分为<code>Unchecked Exception</code>和<code>Checked Exception</code>。<code>Unchecked Exception</code>为运行时异常，这类异常可以通过编译，在程序运行时抛出异常。一般是由于程序逻辑的错误引起，比如<code>NullPointerException</code>、<code>IndexOutOfBoundException</code>等。<code>Checked Exception</code>为非运行时异常，在编写代码是就要处理这类异常，比如<code>IOException</code>、<code>SQLException</code>等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java异常</category>
      </categories>
      <tags>
        <tag>Java异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发工具</title>
    <url>/2020/12/07/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>玩转Java并发工具笔记</p>
<a id="more"></a>

<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol>
<li><p>每个线程需要一个独享的对象。</p>
<p>假设有一段程序想要在多线程中打印日期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> finalI = i;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                String date = <span class="keyword">new</span> Test().date(finalI);</span><br><span class="line">                System.out.println(date);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">date</span><span class="params">(<span class="keyword">long</span> seconds)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span> * seconds);</span><br><span class="line">        <span class="keyword">return</span> format.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>SimpleDateFormat</code>不是线程安全的，将其设置为<code>static</code>将会发生线程安全问题。所以，更好的解决方案是利用<code>ThreadLocal</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> finalI = i;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                String date = <span class="keyword">new</span> Test().date(finalI);</span><br><span class="line">                System.out.println(date);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">date</span><span class="params">(<span class="keyword">long</span> seconds)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span> * seconds);</span><br><span class="line">        SimpleDateFormat format = ThreadSafeFormatter.sdf.get();</span><br><span class="line">        <span class="keyword">return</span> format.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeFormatter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; sdf = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，每个线程都有自己独享的<code>SimpleDateFormat</code>对象，就不存在线程安全问题了。</p>
</li>
<li><p>每个线程内需要保存全局变量</p>
<p>假设每个线程都要保存对应的用户信息时，就可以使用<code>ThreadLocal</code>类，例如<code>Spring Security</code>中的<code>SecurityContextHolder</code>组件，就是利用了<code>ThreadLocal</code>来保存每个使用者的上下文，这样就避免了在各个方法之间都以参数的形式传递用户上下文的麻烦。</p>
</li>
</ol>
<h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ol>
<li>线程安全</li>
<li>无需加锁，提高执行效率</li>
<li>免去传参的繁琐</li>
</ol>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>每个线程都有自己的<code>ThreadLocalMap</code>去保存每个<code>ThreadLocal</code>。</p>
<h5 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h5><ol>
<li><p>initialValue()</p>
<p>该方法返回当前线程对应的初始值。这是一个<strong>延迟加载</strong>的方法，只有在调用了<code>get</code>方法时，才会触发。</p>
</li>
<li><p>get</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 如果线程之前已经调用了set方法，map就不为空，直接返回值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则才调用setInitialValue方法</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>set</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>remove</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>remove</code>方法可以看到，<code>ThreadLocalMap</code>底层数据结构是一个键值对数组，通过传入key并哈希得到下标，最终在返回相应的值。</p>
<p><code>ThreadLocalMap</code>处理哈希冲突的办法与<code>HashMap</code>有所不同，当发生哈希冲突时，它会往后找到第一个空位置并将值填入而不是使用拉链法。</p>
<h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p>定义：某个对象不再有用，但是却占有的内存不能被回收。</p>
<p><code>ThreadLocalMap</code>中的<code>Entry</code>数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>Entry</code>数组的key是一个<strong>弱引用</strong>。弱引用的特点是，如果这个对象只被弱引用关联，那么这个对象就可以被回收。而<code>Entry</code>数组的value是一个强引用，JVM直到内存溢出都不会回收强引用对象。这将有可能导致key已经被回收，value却还存在的情况。然而JDK已经考虑到了这个问题，在<code>set</code>、<code>remove</code>、<code>rehash</code>等方法中会扫描key为<code>null</code>的<code>Entry</code>，并将对应的value也设置为<code>null</code>，这样value也可以被回收了。所以我们在用完<code>ThreadLocal</code>对象后应该主动调用<code>remove</code>方法以避免内存泄漏的发生。</p>
<hr>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ol>
<li>修饰类防止被继承，方法防止被重写，变量防止被修改。</li>
<li>线程安全，不需要额外的同步开销。</li>
<li><code>final</code>不能修饰构造方法。</li>
<li><code>final</code>修饰的对象，其引用不可变，但对象本身的属性是可以改变的。</li>
<li>被<code>final</code>修饰的变量为常量，在程序编译期间就确定了值，被放入方法区中的常量池。</li>
</ol>
<hr>
<h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><h5 id="Vector、Hashtable、Collections-synchronized"><a href="#Vector、Hashtable、Collections-synchronized" class="headerlink" title="Vector、Hashtable、Collections.synchronized*"></a>Vector、Hashtable、Collections.synchronized*</h5><p>利用<code>synchronized</code>保障线程安全。在高并发场景下效率低。</p>
<h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><p><code>CopyOnWriteArrayList</code>利用<code>Lock</code>的可重入锁保障线程安全。与<code>ArrayList</code>不同，它可以在迭代的过程中对数据进行修改。当要对数据进行修改时，会将原有数据拷贝一份并在这份副本上进行修改，不会影响到原有的数据，达到了读写分离的效果。虽然读到的数据可能不是最新的，但却大大提高了效率，适用于读多写少的场景。</p>
<h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p><code>ConcurrentHashMap</code>在JDK 1.8之前使用分段锁，而1.8之后的结构与<code>HashMap</code>非常类似，使用<code>CAS</code> + <code>synchronized</code>保障线程安全，对于<code>put</code>方法：</p>
<ol>
<li>首先判断<code>key</code>、<code>value</code>是否为空</li>
<li>计算<code>hash</code>值</li>
<li>根据对应位置的结点的类型来赋值，或者<code>helpTransfer</code>，或增长链表，或者给红黑树增加结点</li>
<li>检查链表长度是否已经达到阈值，达到了就将链表红黑树化</li>
<li>最后返回<code>oldVal</code></li>
</ol>
<p>然而，并非使用了<code>ConcurrentHashMap</code>就一定是线程安全了。例如使用了一些组合操作，仍有可能造成线程安全问题。我们应该利用<code>ConcurrentHashMap</code>提供的一些方法去替代组合操作以保证线程安全，例如<code>replace</code>代替<code>get put</code>，<code>putIfAbsent</code>代替<code>contains put</code>。</p>
<h5 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h5><p>基于JDK 1.8</p>
<ol>
<li><p>ArrayBlockingQueue</p>
<p><code>ArrayBlockingQueue</code>底层是一个数组，通过<code>ReentrantLock</code>保障线程安全，其大小是有界的，需要在初始化的时候指定。</p>
</li>
<li><p>LinkedBlockingQueue</p>
<p><code>LinkedBlockingQueue</code>底层是一个链表，同样通过<code>ReentrantLock</code>保障线程安全，其大小无界，为整数的最大值。</p>
</li>
<li><p>PriorityBlockingQueue</p>
<p><code>PriorityBlockingQueue</code>底层是一个数组，支持优先级，通过<code>ReentrantLock</code>保障线程安全，初始默认大小为11，最大为<code>Integer.MAX_VALUE - 8</code>，当数组大小不够时根据<code>oldCap = oldCap + ((oldCap &lt; 64) ? (oldCap + 2) : (oldCap &gt;&gt; 1));</code>扩容。</p>
</li>
<li><p>SynchronousQueue</p>
<p>容量为0。是一个用来直接传递的并发数据结构。<code>Executors.newCachedThreadPool</code>正是使用这种队列。</p>
</li>
<li><p>DelayQueue</p>
<p>无界队列，根据延时时间排序，元素需要实现<code>Delayed</code>接口，规定排序规则。</p>
</li>
</ol>
<hr>
<h4 id="控制并发流程"><a href="#控制并发流程" class="headerlink" title="控制并发流程"></a>控制并发流程</h4><h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><p>一个线程等待多个线程都执行完毕，再继续自己的工作。或者多个线程等待某一个线程的信号，再同步开始执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch begin = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch run = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i + <span class="number">1</span>;</span><br><span class="line">            Runnable runnable = () -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">"No."</span> + no + <span class="string">"准备完毕，等待发令枪响。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    begin.await();</span><br><span class="line">                    System.out.println(<span class="string">"No."</span> + no + <span class="string">"开始跑步。"</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (<span class="number">5000</span> + Math.random() * <span class="number">5000</span>));</span><br><span class="line">                    System.out.println(<span class="string">"No."</span> + no + <span class="string">"到达终点。"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    run.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            service.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"发令枪响，比赛开始！"</span>);</span><br><span class="line">        begin.countDown();</span><br><span class="line">        run.await();</span><br><span class="line">        System.out.println(<span class="string">"比赛结束。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码模拟了运动员赛跑的场景。首先五个运动员模拟五个线程等待裁判员线程发枪，裁判员线程等待五个线程都跑完步，然后结束比赛。</p>
<p><code>CountDownLatch</code>不能重用，无法重置倒数次数。</p>
<h5 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">true</span>);</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Runnable runnable = () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了许可证。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"释放了许可证。"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;;</span><br><span class="line">            service.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Semaphore semaphore = new Semaphore(3, true)</code>设置了三个许可证，并且等待的线程是公平的，不存在插队的情况。<code>semaphore.acquire()</code>用于获取许可证，传入的参数代表一次获取几个，不传参默认获取一个。如果许可证已用完或者不够一次性获取，线程会陷入阻塞，等待其他线程执行<code>semaphore.release()</code>直到许可证数量够用。<code>semaphore.release()</code>同样可以传参，表示一次释放几个。信号量的获取和释放应保持一致。</p>
<h5 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h5><p>用<code>Condition</code>实现<strong>生产者-消费者</strong>模型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Date&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">new</span> Thread(test.<span class="keyword">new</span> Producer()).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(test.<span class="keyword">new</span> Consumer()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"队列空，等待数据"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notEmpty.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    notFull.signal();</span><br><span class="line">                    System.out.println(<span class="string">"从对列取出一个数据，剩余"</span> + queue.size() + <span class="string">"个数据"</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == size) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"队列满，等待取出数据"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notFull.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Date());</span><br><span class="line">                    notEmpty.signal();</span><br><span class="line">                    System.out.println(<span class="string">"向对列放入一个数据，剩余"</span> + (size - queue.size()) + <span class="string">"个空间"</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Condition</code>需要先持有锁，调用<code>await</code>方法会自动释放锁。</p>
<h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"所有人都到场了，出发吧！"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            service.submit(<span class="keyword">new</span> Task(i + <span class="number">1</span>, cyclicBarrier));</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> id, CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + id + <span class="string">"正在前往集合地点"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + id + <span class="string">"到达集合地点，开始等待其他人"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + id + <span class="string">"出发了"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CyclicBarrier</code>与<code>CountDownLatch</code>有些类似，不同之处在于：</p>
<ol>
<li>作用不同：<code>CyclicBarrier</code>要等固定数量的线程都到达了栅栏位置才能继续执行，而<code>CountDownLatch</code>只需等待数字到0，也就是说，<code>CountDownLatch</code>用于事件，而<code>CyclicBarrier</code>用于线程。</li>
<li>可重用性不同：<code>CountDownLatch</code>在倒数到0并触发门闩打开后，就不能再使用了，而<code>CyclicBarrier</code>可以重复使用。</li>
</ol>
<hr>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p>定义：<code>AQS</code>是一个用于构建锁、同步器、协作工具类的工具类。有了<code>AQS</code>以后，更多的协作工具类都可以很方便得被写出来。以上提到的几个控制并发流程的工具类都用到了<code>AQS</code>，源码中都存在一个<code>Sync</code>的抽象静态内部类，继承了<code>AbstractQueuedSynchronizer</code>。</p>
<p><code>AQS</code>内部维护了一个<code>state</code>状态位，尝试加锁时通过<code>CAS</code>修改值，如果成功设置为1，并且把当前线程ID赋值，说明加锁成功。一旦获取到锁，其他线程将会阻塞进入阻塞队列自旋，等待获取锁的线程唤醒。释放锁的时候会把<code>state</code>重置为0，同时把线程ID置空。</p>
<p>利用<code>AQS</code>DIY一个简单的线程协作器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneShotLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 返回1代表获取latch成功</span></span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        OneShotLatch oneShotLatch = <span class="keyword">new</span> OneShotLatch();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"尝试获取latch，获取失败就等待"</span>);</span><br><span class="line">                oneShotLatch.await();</span><br><span class="line">                System.out.println(<span class="string">"开闸放行"</span> + Thread.currentThread().getName() + <span class="string">"继续运行"</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        oneShotLatch.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>十个线程分别执行<code>oneShotLatch.await()</code>方法，调用<code>sync.acquireShared(0)</code>，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重写了<code>tryAcquireShared</code>方法，由于初始时<code>getState()</code>返回0，所以满足<code>tryAcquireShared(arg) &lt; 0</code>，执行<code>doAcquireShared(arg)</code>，将线程包装为一个结点放入队列中等待，此时线程处于阻塞状态。过了5秒后，执行<code>oneShotLatch.signal()</code>，调用<code>sync.releaseShared(0)</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用我们重写的<code>tryReleaseShared(arg)</code>方法，将<code>state</code>设置为1，调用<code>doReleaseShared()</code>，从队列中唤醒等待的线程，所有线程得以继续运行。</p>
<hr>
<h4 id="Future、Callable"><a href="#Future、Callable" class="headerlink" title="Future、Callable"></a>Future、Callable</h4><p><code>Runnable</code>有两个缺陷：一是不能返回一个返回值，二是无法抛出异常。针对这两个缺陷，我们可以使用<code>Callable</code>抛出异常，同时使用<code>Future</code>获取子线程的运行结果。</p>
<ol>
<li><p>Callable</p>
<p><code>Callable</code>是类似于<code>Runnable</code>的接口，实现<code>Callable</code>接口的类和实现<code>Runnable</code>接口的类都是可以被其他线程执行的任务。<code>Callable</code>中的<code>call()</code>方法，返回的结果是<code>Object</code>。</p>
</li>
<li><p>Future</p>
<p><code>Future</code>的核心思想是：一个方法的计算过程可能非常耗时，一直在原地等待方法返回显然不明智。于是将其放到子线程执行，通过<code>Future</code>控制方法的计算过程，并直接得到计算出的结果。其主要方法有：</p>
<ol>
<li><code>get()</code>：获取结果。如果任务抛出了异常，该异常将被封装为<code>ExecutionException</code>返回。</li>
<li><code>get(long timeout, TimeUnit unit)</code>：限时获取结果，超时将抛出<code>TimeoutException</code>异常。</li>
<li><code>cancel(boolean mayInterruptIfRunning)</code>：取消任务的执行，参数的含义是是否去中断正在运行的任务。</li>
<li><code>isDone()</code>：判断线程是否执行完毕。</li>
<li><code>isCancelled</code>：判断任务是否被取消。</li>
</ol>
<p><code>Future</code>的注意点：</p>
<ol>
<li>用<code>for</code>循环批量获取<code>future</code>的结果时，容易发生一部分线程很慢的情况，<code>get()</code>方法调用时应使用<code>timeout</code>限制。</li>
<li><code>Future</code>生命周期不能后退。一旦任务完全完成，就不能重头再来。</li>
</ol>
</li>
<li><p>Callable与Future关系</p>
<p>我们可以利用<code>future.get()</code>获取<code>Callable</code>接口返回的执行结果，还可以通过<code>future.isDone()</code>来判断任务是否已经执行完了，以及取消这个任务，限时获取任务的结果等等。如果任务没有执行完，<code>future.get()</code>会阻塞调用的线程直到任务执行完毕返回结果。</p>
</li>
<li><p>FutureTask</p>
<p>把<code>Callable</code>实例当作参数，生成<code>FutureTask</code>对象，然后把这个对象当作<code>Runnable</code>对象，用线程池或子线程去执行这个对象，最后通过<code>FutureTask</code>获取执行的结果。</p>
</li>
</ol>
<hr>
<h4 id="DIY缓存"><a href="#DIY缓存" class="headerlink" title="DIY缓存"></a>DIY缓存</h4><p>首先定义一个计算的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个类实现这个接口，自定义<code>compute</code>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着写缓存类，并测试高并发的情况下该缓存的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Future避免重复计算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cache</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入缓存机制"</span>);</span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Callable&lt;V&gt; callable = () -&gt; c.compute(arg);</span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">            f = cache.putIfAbsent(arg, ft);</span><br><span class="line">            <span class="comment">// 避免重复计算</span></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                f = ft;</span><br><span class="line">                System.out.println(<span class="string">"从FutureTask调用了计算函数"</span>);</span><br><span class="line">                ft.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            cache.remove(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置缓存超时时间，到时清除缓存，加入随机数避免服务雪崩</span></span><br><span class="line">        <span class="keyword">if</span> (expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            exec.schedule(() -&gt; &#123;</span><br><span class="line">                expire(arg);</span><br><span class="line">            &#125;, expire + (<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">        <span class="keyword">return</span> compute(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(A key)</span> </span>&#123;</span><br><span class="line">        Future&lt;V&gt; future = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果缓存时间到了，任务还未执行完，直接取消任务</span></span><br><span class="line">            <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Future任务被取消"</span>);</span><br><span class="line">                future.cancel(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"过期时间到，缓存被清除"</span>);</span><br><span class="line">            cache.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cache&lt;String, Integer&gt; cache = <span class="keyword">new</span> Cache&lt;&gt;(<span class="keyword">new</span> ExpensiveFunction());</span><br><span class="line">        <span class="comment">// 模拟高并发的场景进行压测</span></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"开始等待"</span>);</span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"拿到结果: "</span> + cache.compute(<span class="string">"123"</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        service.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!service.isTerminated()) &#123;&#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"耗时: "</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果显示总共耗时<code>2012</code>毫秒。</p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql笔记</title>
    <url>/2020/12/09/Mysql%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>mysql学习笔记</p>
<a id="more"></a>

<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p><strong>结构化查询语言</strong>(Structured Query Language)简称<code>SQL</code>，是一种数据库查询语言。主要分为以下几类：</p>
<ul>
<li><strong>数据定义语言(DDL)</strong>：<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code></li>
<li><strong>数据查询语言(DQL)</strong>：<code>SELECT</code></li>
<li><strong>数据操纵语言(DML)</strong>：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code></li>
<li><strong>数据控制语言(DCL)</strong>：<code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>、<code>ROLLBACK</code></li>
</ul>
<hr>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p><code>MySQL</code>是一个<strong>关系型数据库管理系统</strong>，属于<code>Oracle</code>旗下产品。</p>
<hr>
<h4 id="MySQL的binlog"><a href="#MySQL的binlog" class="headerlink" title="MySQL的binlog"></a>MySQL的binlog</h4><p>有三种格式：<code>statement</code>、<code>row</code>和<code>mixed</code>。</p>
<ul>
<li><code>statement</code>模式，每一条会修改数据的<code>sql</code>都会保存到<code>binlog</code>中。无需记录每一行的变化，减少了<code>binlog</code>日志量，节约了<code>IO</code>，提高性能。在保存时会保存<code>sql</code>的上下文。</li>
<li><code>row</code>模式，不记录<code>sql</code>的上下文，仅保存哪条记录被修改。记录单元为每一行的改动。</li>
<li><code>mixed</code>模式，普通操作使用<code>statement</code>模式，<code>statement</code>无法完成主从复制的操作，则使用<code>row</code>格式保存<code>binlog</code>。</li>
</ul>
<p><code>binlog</code>主要有两个作用：复制和恢复数据。<code>MySQL</code>在实际生产环境中往往采用一主多从的架构，服务器之间的数据要保持一致，就是通过<code>binlog</code>实现的。</p>
<hr>
<h4 id="MySQL的redo-log"><a href="#MySQL的redo-log" class="headerlink" title="MySQL的redo log"></a>MySQL的redo log</h4><p>假设有这样一条<code>sql</code>：<code>UPDATE user SET name = &quot;test&quot; WHERE id = 1</code>。<code>MysQL</code>执行的时候首先会找到<code>id = 1</code>这条记录所在的页查出来，把该页的内容加载到内存，然后对对应的数据进行更改。那么问题来了，如果在内存中把数据更改了还没来得及写到磁盘上，这时候数据库挂了咋办？<code>MySQL</code>引入了<code>redo log</code>，内存中的数据修改了，就会写一份<code>redo log</code>，这份<code>redo log</code>记载了本次在哪页做了什么修改。</p>
<p>其实写<code>redo log</code>的时候，也会有<code>buffer</code>，先写到<code>buffer</code>，再写到磁盘上。至于<code>buffer</code>什么时候写到磁盘，是可以配置的。</p>
<p>所以，<code>redo log</code>主要是针对修改数据的时候还未落磁盘时数据库挂了的场景。我们可以使用<code>redo log</code>对数据进行恢复。因为<code>redo log</code>是顺序<code>IO</code>，所以写入的顺序很快。</p>
<p>这样看来<code>binlog</code>和<code>redo log</code>好像很相似，都是为了恢复数据。但其实是有很大不同的：</p>
<ul>
<li>首先存储的内容不同。<code>binlog</code>记载的是修改语句（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>），而<code>redo log</code>记载的是物理修改的内容（某页修改了某内容）。</li>
<li><code>redo log</code>主要是为了持久化而生的；而<code>binlog</code>是为了复制和恢复而生的。</li>
</ul>
<hr>
<h4 id="MySQL的undo-log"><a href="#MySQL的undo-log" class="headerlink" title="MySQL的undo log"></a>MySQL的undo log</h4><p><code>undo log</code>主要有两个作用：回滚以及多版本控制（<code>MVCC</code>）。</p>
<p>在进行数据修改时，不仅记录了<code>redo log</code>，还记录了<code>undo log</code>，如果因为某些原因导致事务失败或者回滚了，就可以用<code>undo log</code>进行回滚。</p>
<p><code>undo log</code>存储的也是逻辑变化，比如我们要插入一条数据，那么<code>undo log</code>就会记录一条对应的<code>DELETE</code>日志；我们要<code>UPDATE</code>一条数据，它就会记录一条相反的<code>UPDATE</code>记录。</p>
<p>因为<code>undo log</code>存储的是修改之前的数据，相当于前一个版本，<code>MVCC</code>实现的事读写不阻塞，读的时候只要返回前一个版本的数据就行了。</p>
<hr>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ol>
<li><p>整数类型</p>
<p><code>tinyint(1 byte)</code>、<code>smallint(2 bytes)</code>、<code>mediumint(3 bytes)</code>、<code>int(4 bytes)</code>、<code>bigint(8 bytes)</code></p>
<p>整数类型可以被指定长度，不影响值的合法范围，只影响字符的显示个数。</p>
</li>
<li><p>小数类型</p>
<p><code>float(32 bits)</code>、<code>double(64 bits)</code>、<code>decimal</code></p>
<p><code>decimal</code>可用于存储比<code>bigint</code>还大的整数，能存储精确的小数，计算时效率较低。</p>
</li>
<li><p>字符串类型</p>
<p><code>varchar</code>、<code>char</code>、<code>text</code>、<code>blob</code></p>
<p><code>varchar</code>存储可变长度字符串，使用额外1或2个字节存储长度。长度小于255字节时使用1字节表示，否则使用2字节。其存储的内容超过设置的长度时，内容会被截断。</p>
<p>使用策略：</p>
<ol>
<li>对于经常变更的数据来说，<code>char</code>更好，因为它不容易产生碎片。</li>
<li>对于很短的数据，<code>char</code>在存储空间上更有效率。</li>
<li>应尽量避免使用<code>text/blob</code>类型，查询时会使用临时表，消耗性能。</li>
</ol>
</li>
<li><p>枚举类型<code>(enum)</code></p>
<p>把不重复的数据存储为一个预定义的集合。其存储非常紧凑，会把列表值压缩到1或2个字节，存储的其实是整数，所以排序也是按照存储的整数。应尽量避免使用数字导致混乱。</p>
</li>
<li><p>日期和时间类型</p>
<p><code>year(1901-2155)</code>、<code>time(-838:59:59~838:59:59)</code>、<code>date(1000-01-01~9999-12-3)</code>、<code>datetime(1000-01-01 00:00:00~ 9999-12-31 23:59:59)</code>、<code>timestamp(1970-01-01 00:00:01 UTC~2038-01-19 03:14:07UTC)</code></p>
<p><code>timestamp</code>空间效率高于<code>datetime</code>。</p>
</li>
</ol>
<hr>
<h4 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h4><p><code>MyISAM</code>和<code>InnoDB</code>区别</p>
<ol>
<li><code>MyISAM</code>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件；<code>InnoDB</code>所有表存在同一个文件内（也可能是多个文件，或者是独立的表空间文件），表的大小受限于操作系统文件的大小，一般为2GB。</li>
<li><code>MyISAM</code>可被压缩，存储空间小；<code>InnoDB</code>需要更多的内存和存储，会在主内存中建立专用的缓冲池用于高速缓冲数据和索引。</li>
<li><code>MyISAM</code>的数据和索引是分开存储的，数据为<code>.MYD</code>，索引为<code>.MYI</code>；<code>InnoDB</code>的数据和索引是集中存储的，为<code>.IBD</code>。</li>
<li><code>MyISAM</code>按记录插入的顺序存储记录；<code>InnoDB</code>按主键大小有序插入。</li>
<li><code>MyISAM</code>不支持外键；<code>InnoDB</code>支持。</li>
<li><code>MyISAM</code>不支持事务；<code>InnoDB</code>支持。</li>
<li><code>MyISAM</code>表锁；<code>InnoDB</code>支持表锁、行锁，默认行锁。</li>
<li><code>MyISAM</code>索引是B+树索引，使用的是<strong>堆组织表(HOT)</strong>，显示的是随机顺序；<code>InnoDB</code>也是B+树索引，使用的是<strong>索引组织表(IOT)</strong>，主键按顺序存储。</li>
<li><code>MyISAM</code>索引是非聚簇索引；<code>InnoDB</code>索引是聚簇索引。</li>
<li><code>MyISAM</code>允许表没有主键；<code>InnoDB</code>不允许。如果没有设置主键，<code>InnoDB</code>会自动生成一个6字节的主键。</li>
</ol>
<hr>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是一种特殊的文件（<code>InnoDB</code>数据表上的索引是表空间的一个组成部分），会占据物理空间，包含对数据表里所有记录的引用指针。</p>
<p>索引可以大大加快数据的检索速度，但同时创建索引和维护索引要耗费时间。对表中的数据进行增删改时，索引也需要动态维护，所以会降低数据增删改的效率。</p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol>
<li><code>where</code>后的字段。</li>
<li><code>order by</code>的字段。由于索引本身是有序的，可以直接从索引表内的索引对应的数据，大大降低了将数据从磁盘读取到内存再排序所消耗的性能。</li>
<li><code>join</code>语句<code>on</code>之后涉及的字段。</li>
</ol>
<h5 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h5><p>如果要查询的字段都建立了索引，那么引擎会直接在索引表中查询而不访问原始数据资源，这叫做索引覆盖。因此写<code>select</code>语句应该尽量只写必要的字段，增加索引覆盖的几率。</p>
<h5 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h5><ol>
<li><strong>主键索引</strong>：数据列无重复，不允许为<code>NULL</code>，一个表只有一个主键。</li>
<li><strong>唯一索引</strong>：数据列无重复，允许为<code>NULL</code>，一个表可以有多个列创建唯一索引。<code>ALTER TABLE table_name ADD UNIQUE(column1, ...)</code>创建。</li>
<li><strong>普通索引</strong>：没有唯一性的限制，也允许为<code>NULL</code>。<code>ALTER TABLE table_name ADD INDEX index_name(column1, ...)</code>创建。</li>
<li><strong>全文索引</strong>：<code>ALTER TABLE table_name ADD FULLTEXT(column)</code>创建。</li>
</ol>
<h5 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h5><p><code>MySQL</code>使用较多的索引有<strong>Hash索引</strong>、<strong>B+树索引</strong>。<code>InnoDB</code>默认使用的索引实现为B+树索引。</p>
<ol>
<li><p>Hash索引</p>
<p>底层为哈希表，用Hash算法将数据库字段转换为定长的Hash值，与这条数据的行指针一并存入Hash表对应的位置。如果发生了Hash碰撞，则利用链表存储。</p>
</li>
<li><p>B树索引</p>
<p>底层为B+树，其性质为：</p>
<ol>
<li>非叶子结点的子树指针与关键字个数相同。</li>
<li>非叶子结点的子树指针<code>p[i]</code>,指向关键字值属于<code>[k[i], k[i+1]]</code>的子树。</li>
<li>所有叶子结点拥有一个链指针。</li>
<li>所有关键字只出现在叶子结点。</li>
<li>非叶子结点相当于叶子结点的索引，叶子结点存储数据。</li>
<li>B+树适用于文件系统的存储。</li>
</ol>
</li>
</ol>
<p>B+树比B树更适合数据库索引，主要有以下几个原因：</p>
<ol>
<li><strong>B+树的磁盘读写代价更低</strong>。B+树内部结点没有指向关键字具体信息的指针，因此内部结点相对于B树更小，因此同一盘块所能容纳的关键字就越多，一次性能够读入内存的关键字也越多，IO读写次数也就降低了。</li>
<li><strong>B+树的查询效率更加稳定</strong>。任何关键字的查找必须走从根结点到叶子结点的路，所以每个数据查询的效率是相当的。</li>
<li>B+树的数据都存储在叶子结点中，而B树的非叶子结点也存有数据，我们要找到具体的数据需要中序遍历，所以B+树的效率更高，更适合区间查询，适用于数据库索引。</li>
<li>增删文件时，由于B+树的叶子结点包含所有关键字，且以有序的链表存储，所以其增删效率更高。</li>
</ol>
<p><img src="B+%E6%A0%91%E3%80%81B%E6%A0%91.jpeg" alt=""></p>
<h5 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h5><p>索引用来快速寻找具有特定值的记录。如果没有索引，查询时需要遍历整张表。</p>
<p>索引的原理就是把无序的数据变为有序的查询。</p>
<ol>
<li>将创建了索引的列排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上加上数据地址链</li>
<li>查询时，先获取倒排表，取出数据地址链，从而获取具体的数据。</li>
</ol>
<h5 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h5><ol>
<li>最左前缀匹配原则。<code>MySQL</code>执行查询语句会一直向右匹配直到遇到范围查询。例如<code>a = 1 AND b &gt; 2 AND c = 3</code>，如果a、b、c都建立了索引，这时c是用不到索引的。改成<code>a = 1 AND c = 3 AND b &gt; 2</code>即可。</li>
<li>只为频繁作为查询条件的字段建立索引。</li>
<li>频繁更新的字段不宜建立索引。</li>
<li>不能有效区分数据的列不建立索引。</li>
<li>定义有外键的数据列建立索引，可以加快表之间的连接。</li>
<li>定义为<code>text/image/bit</code>类型的列不建立索引，因为这些数据类型的列的数据量要么很大，要么很小，不利于使用索引。</li>
</ol>
<h5 id="百万级别以上的数据如何删除"><a href="#百万级别以上的数据如何删除" class="headerlink" title="百万级别以上的数据如何删除"></a>百万级别以上的数据如何删除</h5><p>当我们对数据进行增删改的时候，都会产生对索引文件的操作，额外消耗IO，影响增删改的效率。所以当删除的数据量大时：</p>
<ol>
<li>应该先删除索引。</li>
<li>然后删除数据。</li>
<li>删除完重新建立索引。</li>
</ol>
<p>这样比直接删除内容快很多。</p>
<h5 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h5><p><code>INDEX(FIELD(10))</code>，表示使用字段前10个字符建立索引。</p>
<h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h5><p><code>MySQL</code>可以使用多个字段同时建立一个索引，称为联合索引。如果想要命中索引，需要按照建立索引时的字段顺序查找，否则无法命中索引。</p>
<hr>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位。其执行的结果必须使数据库从一种一致性状态变为另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<h5 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h5><p>关系型数据库必须遵循ACID规则：</p>
<ol>
<li><strong>原子性</strong>：事务是最小的执行单位，不允许分割。事务的原子性保证了事务要么都执行，要么都不执行。</li>
<li><strong>一致性</strong>：实行事务前后，数据应保持一致，多个事务对同一个数据读取的结果是相同的。</li>
<li><strong>隔离性</strong>：并发访问数据库时，一个用户的事务不被其他事务所干扰，各个并发事务之间数据库是独立的。</li>
<li><strong>持久性</strong>：一个事务被提交之后，它对数据库数据的改变是永久的，即使数据库发生故障也不会对其有影响。</li>
</ol>
<h5 id="幻读、脏读、不可重复读"><a href="#幻读、脏读、不可重复读" class="headerlink" title="幻读、脏读、不可重复读"></a>幻读、脏读、不可重复读</h5><ul>
<li>幻读：事务A查询了某数据的总量，此时事务B对数据执行了插入或删除的操作，事务A再次执行查询发现数据总量已经发生了变化。</li>
<li>脏读：事务A访问到了事务B未提交的数据，此时事务B进行了回滚，事务A读到的就是脏数据。</li>
<li>不可重复读：事务A查询到某数据，此时事务B对这部分数据进行了更新，事务A再次查询发现数据已经变了。</li>
</ul>
<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ-UNCOMMITTED</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">READ_COMMITTED</td>
<td align="center">✗</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">REPEATABLE_READ</td>
<td align="center">✗</td>
<td align="center">✗</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">SERIALIZABLE</td>
<td align="center">✗</td>
<td align="center">✗</td>
<td align="center">✗</td>
</tr>
</tbody></table>
<p><code>MySQL</code>默认采用<strong>REPEATABLE_READ</strong>。</p>
<hr>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h5 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h5><ul>
<li>READ_UNCOMMITTED：读取数据无需加共享锁。</li>
<li>READ_COMMITTED：读操作加共享锁，执行完语句释放共享锁。</li>
<li>REPEATABLE_READ：读操作加共享锁，在事务提交之前不释放锁。</li>
<li>SERIALIZABLE：该级别锁定整个范围的键，一直持有锁知道事务完完成。</li>
</ul>
<h5 id="行锁实现"><a href="#行锁实现" class="headerlink" title="行锁实现"></a>行锁实现</h5><p><code>InnoDB</code>是基于索引实现的行锁。</p>
<p><code>SELECT * FROM tab_with_index WHERE id = 1 FOR UPDATE;</code>。<code>FOR UPDATE</code>可以根据条件完成行锁，且<code>id</code>是有索引键的列，如果<code>id</code>不是索引键<code>InnoDB</code>将完成表锁。</p>
<hr>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>为了提高复杂SQL语句的复用性和表操作的安全性，<code>MySQL</code>提供了视图。视图是一种虚拟表。</p>
<h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>重用SQL语句</li>
<li>简化复杂的SQL操作</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表。</li>
</ul>
<p>使用视图会影响性能。</p>
<p>基本使用：</p>
<ul>
<li>创建视图：<code>CREATE VIEW &#39;view_name&#39; AS SELECT 查询语句</code>。</li>
<li>修改视图：<code>ALTER VIEW view_name AS SELECT 查询语句</code>。</li>
<li>删除视图：<code>DROP VIEW view_name</code>。</li>
</ul>
<hr>
<h4 id="SQL约束"><a href="#SQL约束" class="headerlink" title="SQL约束"></a>SQL约束</h4><ul>
<li><strong>NOT NULL</strong>：控制字段内容不能为空。</li>
<li><strong>UNIQUE</strong>：控制字段内容不能重复，一个表可以有多个<code>UNIQUE</code>约束。</li>
<li><strong>PRIMARY KEY</strong>：控制字段不能重复，一个表只能出现一次。</li>
<li><strong>FOREIGN KEY</strong>：预防破坏表之间连接的动作，防止非法数据插入外键列。</li>
<li><strong>CHECK</strong>：控制字段的值的范围。</li>
</ul>
<hr>
<h4 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h4><ul>
<li>交叉查询(CROSS JOIN)：返回<strong>笛卡尔乘积</strong>，没有关联条件。</li>
<li>内连接(INNER JOIN)</li>
<li>外连接(LEFT JOIN、RIGHT JOIN)</li>
<li>联合查询(UNION、UNION ALL)：联合查询的列数要相等，<code>UNION</code>会合并相同记录行，<code>UNION ALL</code>不合并。</li>
<li>全连接(FULL JOIN)：<code>MySQL</code>不支持。</li>
</ul>
<hr>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>一条SQL语句的查询结果作为另一条查询语句的条件或查询结果。</p>
<hr>
<h4 id="drop、delete、truncate"><a href="#drop、delete、truncate" class="headerlink" title="drop、delete、truncate"></a>drop、delete、truncate</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">delete</th>
<th align="center">truncate</th>
<th align="center">drop</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">DML</td>
<td align="center">DDL</td>
<td align="center">DDL</td>
</tr>
<tr>
<td align="center">回滚</td>
<td align="center">支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">删除内容</td>
<td align="center">不删除表结构，删除表的全部或部分数据</td>
<td align="center">不删除表结构，删除表的所有数据</td>
<td align="center">删除表的全部，包括数据、索引、权限</td>
</tr>
<tr>
<td align="center">删除速度</td>
<td align="center">慢，需要逐行删除</td>
<td align="center">快</td>
<td align="center">最快</td>
</tr>
</tbody></table>
<hr>
<h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><p>对于低性能SQL语句的定位，可使用<strong>执行计划</strong>。执行计划用于显示数据库引擎对于SQL语句执行的详细情况，包含了是否使用索引、使用什么索引等等。</p>
<p>执行计划包含的信息id由一组数字组成，表示一个查询中各个子查询的执行效率：</p>
<ul>
<li>id相同执行顺序由上至下</li>
<li>id不同，则id越大优先级越高，越先执行</li>
<li>id为<code>NULL</code>，说明不需要使用它查询</li>
</ul>
<p><code>select_type</code>表示每个子查询的查询类型：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">不包含任何子查询或<code>union</code>等查询</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">PRIMARY</td>
<td align="center">包含子查询最外层查询就显示为<code>PRIMARY</code></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">SUBQUERY</td>
<td align="center">在<code>select</code>或<code>where</code>字句中包含的查询</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">DERIVED</td>
<td align="center"><code>from</code>子句中包含的查询</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">UNION</td>
<td align="center">出现在<code>union</code>后的查询语句中</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">UNION RESULT</td>
<td align="center">从<code>UNION</code>中获取结果集</td>
</tr>
</tbody></table>
<p><code>table</code>表示查询的数据表。</p>
<p><code>type</code>表示访问的类型：</p>
<ul>
<li>ALL 扫描全表</li>
<li>index 遍历索引</li>
<li>range 索引范围查找</li>
<li>index_subquery 在子查询中使用<code>ref</code></li>
<li>unique_subquery 在子查询中使用<code>eq_ref</code></li>
<li>ref_or_null 对<code>null</code>进行索引优化的<code>ref</code></li>
<li>fulltext 使用全文索引</li>
<li>ref 使用非唯一索引查询数据</li>
<li>eq_ref 在<code>join</code>查询中使用<code>PRIMARY KEY</code>或者<code>UNIQUE NOT NULL</code>索引关联</li>
</ul>
<p><code>possible_keys</code>表示可能使用的索引</p>
<p><code>keys</code>表示<code>MySQL</code>在查询中实际使用到的索引</p>
<p><code>key_length</code>表示索引长度</p>
<p><code>ref</code>表示连接匹配条件</p>
<p><code>rows</code>表示估算的结果集数量</p>
<p><code>extra</code>表示额外的信息</p>
<hr>
<h4 id="SQL生命周期"><a href="#SQL生命周期" class="headerlink" title="SQL生命周期"></a>SQL生命周期</h4><ol>
<li>应用服务器与数据库服务器建立连接</li>
<li>数据库进程获取SQL</li>
<li>解析生成执行计划，执行</li>
<li>读取数据到内存进行逻辑处理</li>
<li>通过1建立的连接将结果返回给客户端</li>
<li>关闭连接，释放资源</li>
</ol>
<hr>
<h4 id="大数据查询优化"><a href="#大数据查询优化" class="headerlink" title="大数据查询优化"></a>大数据查询优化</h4><ol>
<li>优化<code>schema</code>、<code>sql</code>语句+索引</li>
<li>加缓存，例如<code>redis</code></li>
<li>主从复制、读写分离</li>
<li>垂直拆分</li>
<li>水平拆分</li>
</ol>
<hr>
<h4 id="大数据分页"><a href="#大数据分页" class="headerlink" title="大数据分页"></a>大数据分页</h4><p>假设在<code>id</code>列建立了索引。现在执行查询语句<code>SELECT * FROM table WHERE age &lt; 60 LIMIT 1000000, 100</code>。这条SQL语句需要加载1000000条数据然后丢弃，只取后面的100条，这样是很慢的。可以改成<code>SELECT * FROM table WHERE id IN (SELECT id FROM table WHERE age &lt; 60 LIMIT 1000000, 100)</code>。虽然这条语句也加载了1000000条数据，但是由于索引覆盖，所查询的字段都在索引中，速度会很快。如果<code>id</code>是连续的，用<code>SELECT * FROM table WHERE id &gt; 1000000 LIMIT 100</code>就更快了。总之就是尽可能减少加载数据的数量。</p>
<p>利用缓存当然是更好的。</p>
<hr>
<h4 id="慢SQL"><a href="#慢SQL" class="headerlink" title="慢SQL"></a>慢SQL</h4><p><code>SHOW VARIABLES LIKE &#39;slow_query_log&#39;</code>查看慢查询是否开启。可通过<code>SET GLOBAL slow_query_log = ON</code>开启。</p>
<p><code>SHOW VARIABLES LIKE &#39;long_query_time&#39;</code>查看临界时间。可通过<code>SET long_query_time=临界时间</code>修改。一旦SQL执行时间超过设置的临界值，就会被记录到<code>datadir</code>目录下的<code>xxx-slow.log</code>文件中。</p>
<h5 id="解决慢SQL"><a href="#解决慢SQL" class="headerlink" title="解决慢SQL"></a>解决慢SQL</h5><ul>
<li>尽量减少加载语句的数量。</li>
<li>分析语句执行计划，尽量使语句命中索引。</li>
<li>有可能是数据量过大，可以考虑分表。</li>
</ul>
<hr>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>原理：将主数据库的<code>DDL</code>和<code>DML</code>操作通过二进制日志<code>(binlog)</code>传输到数据库上，重新执行这些日志，使得主从数据库数据一致。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>redis笔记</title>
    <url>/2020/12/12/redis%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>redis 学习笔记</p>
<a id="more"></a>

<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p><code>redis(remote dictionary server)</code>是一个C语言编写的，开源的高性能非关系型的键值对数据库。</p>
<p><code>redis</code>的值有5种不同类型：字符串、列表、集合、散列表、有序集合。键只能为字符串。</p>
<p><code>redis</code>是单线程的，但其数据是存在于内存中的，所以读写数据很快，每秒可处理超过10万次读写。</p>
<hr>
<h3 id="redis优缺点"><a href="#redis优缺点" class="headerlink" title="redis优缺点"></a>redis优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>读写快，读的速度为110000次/s，写的速度是81000次/s。</li>
<li>支持数据持久化，有<code>AOF</code>、<code>RDB</code>两种方式。</li>
<li>支持事务。支持对多个操作合并后的原子性操作。</li>
<li>数据结构丰富。</li>
<li>支持主从复制，主机自动同步数据到从机。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><code>redis</code>数据存在于内存中，难以用于海量数据的读写。</li>
<li><code>redis</code>不具备自动容错和恢复机制，需等待重启或手动切换IP才能恢复。</li>
<li>主机宕机，如果数据未及时同步到从机，切换IP后会出现数据不一致问题。</li>
</ul>
<hr>
<h3 id="redis技术特点"><a href="#redis技术特点" class="headerlink" title="redis技术特点"></a>redis技术特点</h3><ol>
<li>基于内存，绝大部分请求都是基于内存的操作。</li>
<li>单线程，避免了多线程的上下文切换与竞争，减少了CPU的消耗。</li>
<li>采用I/O多路复用模型，非阻塞IO。</li>
<li>使用VM机制将不经常访问的数据从内存交换到磁盘中，腾出空间用于其他需要访问的数据。这样可以一定程度上避免内存不足造成数据访问速度下降的问题。</li>
</ol>
<hr>
<h3 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h3><ul>
<li><strong>STRING</strong>：可存储字符串、整数或浮点数。对整数或浮点数执行自增或自减操作。</li>
<li><strong>LIST</strong>：存储列表，从两端压入或者弹出元素。</li>
<li><strong>SET</strong>：存储无序集合。</li>
<li><strong>HASH</strong>：存储包含键值对的无序散列表。</li>
<li><strong>ZSET</strong>：有序集合。</li>
</ul>
<p><code>redis</code>还包括一些高级的数据结构，例如<code>HyperLogLog</code>、<code>BloomFilter</code>等等。</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组已使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf数组未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 字节数组，保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h5><ul>
<li><code>set</code>：给一个<code>key</code>赋值。</li>
<li><code>append</code>：如果一个<code>key</code>已经存在，直接在对应的<code>value</code>追加值，否则创建新的键值对。</li>
<li><code>decr</code>：对<code>value</code>减 1，如果<code>value</code>不是数字，会报<code>(error) ERR value is not an integer or out of range</code>错误。如果<code>key</code>不存在，会给一个默认值0，再减1得到-1。</li>
<li><code>decrby</code>：和<code>decr</code>类似，可以设置步长。</li>
<li><code>get</code>：获取一个<code>key</code>的<code>value</code>。</li>
<li><code>getrange</code>：返回一个<code>key</code>的<code>value</code>的子串。命令的第二和第三个参数表示截取子串的起始位置和结束位置。可以像<code>python</code>一样用负数来表示位置。</li>
<li><code>getset</code>：获取并更新某个<code>key</code>对应的<code>value</code>。</li>
<li><code>incr</code>：对应<code>decr</code>。</li>
<li><code>incrby</code>：对应<code>decrby</code>。</li>
<li><code>incrbyfloat</code>：自增，可以设置步长并且步长可以是浮点数。</li>
<li><code>mget</code>、<code>mset</code>：批量获取、批量存储。</li>
<li><code>ttl</code>：查看<code>key</code>的有效期。</li>
<li><code>setex</code>：给<code>key</code>设置<code>value</code>时添加过期时间。</li>
<li><code>psetex</code>：和<code>setex</code>类似，只不过过期时间的单位是毫秒。</li>
<li><code>setnx</code>：如果<code>key</code>不存在才会设置值。</li>
<li><code>msetnx</code>：批量<code>setnx</code>。</li>
<li><code>setrange</code>：如果<code>key</code>存在，覆盖对应的<code>value</code>，且带有偏移量。例如<code>k</code>的<code>value</code>为<code>abc</code>，命令<code>setrange k 1 def</code>，<code>value</code>变为<code>adef</code>。如果<code>key</code>不存在且命令带有偏移量，<code>redis</code>会用零字节<code>\x00</code>弥补空白。</li>
<li><code>strlen</code>：查看字符串长度。</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">value</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常见操作-1"><a href="#常见操作-1" class="headerlink" title="常见操作"></a>常见操作</h5><ul>
<li><code>lpush</code>：将所有指定的值存入<code>key</code>的列表的头部。如果<code>key</code>不存在会先创建一个空列表，如果<code>key</code>对应的值不是列表会报错。</li>
<li><code>lrange</code>：返回列表指定区间内的元素。</li>
<li><code>rpush</code>：对应<code>lpush</code>，将元素存入列表的尾部。</li>
<li><code>lpop</code>：移除并返回列表的头元素。</li>
<li><code>rpop</code>：移除并返回列表的尾元素。</li>
<li><code>lindex</code>：返回列表中下标为<code>index</code>的元素。</li>
<li><code>ltrim</code>：对列表进行修剪。</li>
<li><code>blpop</code>：阻塞式<code>lpop</code>。</li>
<li><code>brpop</code>：阻塞式<code>rpop</code>。</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码格式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 数组包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<h5 id="常见操作-2"><a href="#常见操作-2" class="headerlink" title="常见操作"></a>常见操作</h5><ul>
<li><code>sadd</code>：添加一个元素到<code>key</code>对应的值中。<code>key</code>不存在就新创建一个<code>set</code>。如果<code>value</code>不是<code>set</code>会报错。</li>
<li><code>smembers</code>：获取一个<code>key</code>下对应的所有元素。</li>
<li><code>srem</code>：移除指定的元素。</li>
<li><code>sismember</code>：返回一个元素是否在集合中。</li>
<li><code>scard</code>：返回一个集合中元素的数量。</li>
<li><code>srandmember</code>：在指定集合中随机返回一个元素。</li>
<li><code>spop</code>：在指定集合中随机返回并出栈一个元素。</li>
<li><code>smove</code>：把一个元素从一个集合移动到另一个集合中。</li>
<li><code>sdiff</code>：返回集合的差集。</li>
<li><code>sinter</code>：返回集合的交集。</li>
<li><code>sunion</code>：返回集合的并集。</li>
<li><code>sdiffstore</code>：类似于<code>sdiff</code>，计算出的结果会保存在一个新的集合中。</li>
<li><code>sinterstore</code>：类似于<code>sinter</code>，计算出的结果会保存在一个新的集合中。</li>
<li><code>sunionstore</code>：类似于<code>sunion</code>，计算出的结果会保存在一个新的集合中。</li>
</ul>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><h5 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h5><p><code>dictht</code>是一个散列表结构，使用<strong>拉链法</strong>解决哈希冲突的问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>redis</code>的字典<code>dict</code>包含两个哈希表<code>dictht</code>，这是为了方便<code>rehash</code>。扩容时，将其中一个<code>dictht</code>上的键值对<code>rehash</code>到另一个<code>dictht</code>上，完成之后释放空间并交换两个<code>dictht</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 两个hash表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash的索引，如果为-1表示没有进行rehash</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;</span><br><span class="line">    <span class="comment">// 目前正在运行的迭代器数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p><code>rehash</code>的操作不是一次性完成的，而是逐步完成的，为的就是不给服务器造成太多的负担。这时<code>rehashidx</code>就派上了用场。它是从0开始的，每执行一次<code>rehash</code>，比如把<code>ht[0]</code>的<code>table[rehashidx]</code>的键值对<code>rehash</code>到<code>ht[1]</code>上，<code>ht[0]</code>的<code>table[rehashidx]</code>指向<code>null</code>，并把<code>rehashidx</code>加一。每当对字典进行增删改查都会执行一次<code>rehash</code>。这样会导致数据分布在不同的<code>ht</code>上，于是对字典的操作也会在两个<code>ht</code>上进行，先对第一个哈希表进行操作，如果没有数据再去找第二个。</p>
<h5 id="常见操作-3"><a href="#常见操作-3" class="headerlink" title="常见操作"></a>常见操作</h5><ul>
<li><code>hset</code>：向指定散列表设置一个键值对。</li>
<li><code>hget</code>：获取指定散列表上一个指定的键对应的值。</li>
<li><code>hmset</code>：批量设置<code>hset</code>。</li>
<li><code>hmget</code>：批量获取<code>hget</code>。</li>
<li><code>hdel</code>：删除一个指定散列表上的指定键值对。</li>
<li><code>hsetnx</code>：和<code>setnx</code>类似。</li>
<li><code>hvals</code>：获取指定散列表上的所有<code>value</code>。</li>
<li><code>hkeys</code>：获取指定散列表上的所有<code>key</code>。</li>
<li><code>hgetall</code>：获取指定散列表上的所有<code>key</code>和<code>value</code>。</li>
<li><code>hexists</code>：返回<code>field</code>是否存在与指定的散列表中。</li>
<li><code>hincrby</code>：使指定的<code>value</code>自增。</li>
<li><code>hincrbyfloat</code>：使指定的<code>value</code>自增，可以为浮点数。</li>
<li><code>hlen</code>：返回某个<code>key</code>中<code>value</code>的数量。</li>
<li><code>hstrlen</code>：返回某个<code>key</code>中的某个<code>field</code>的值的字符串的长度。</li>
</ul>
<h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><h5 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h5><p><code>ZSet</code>的编码可以是<code>ziplist</code>或者<code>skiplist</code>。如果同时满足以下条件的话使用<code>ziplist</code>。</p>
<ul>
<li>元素数量小于128个。</li>
<li>所有成员的长度都小于64字节。</li>
</ul>
<p>以上两个条件的阈值可以通过<code>zset-max-ziplist-entries</code>和<code>zset-max-ziplist-value</code>来修改。</p>
<p><code>ziplist</code>编码的有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存<code>member</code>，第二个节点保存<code>score</code>。<code>ziplist</code>内的集合元素按照<code>score</code>从小到大排序。由于<code>ziplist</code>的节点指针只能线性移动，因此增删改查这些操作的时间复杂度都不低于<code>O(N)</code>。</p>
<p><code>skiplist</code>编码的有序集合底层是一个<code>zset</code>的结构体，<code>zset</code>结构体又包含一个<code>dict</code>和一个<code>skiplist</code>。<code>skiplist</code>存储按照<code>score</code>从小到大保存的所有元素，<code>dict</code>保存从<code>member</code>到<code>score</code>的映射。这样的话就可以在<code>O(1)</code>的时间复杂度内查找<code>member</code>对应的<code>score</code>。虽然使用了两种数据结构，但是它们会共享相同元素的<code>member</code>和<code>score</code>，不会浪费额外的内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分数值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点、表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<h6 id="redis-的-skiplist-和经典的有何不同？"><a href="#redis-的-skiplist-和经典的有何不同？" class="headerlink" title="redis 的 skiplist 和经典的有何不同？"></a>redis 的 skiplist 和经典的有何不同？</h6><ul>
<li><code>skiplist</code>的<code>score</code>允许重复，也就是跳表的<code>key</code>允许重复。</li>
<li>比较时不仅比较<code>score</code>，还比较数据本身。当元素分数相同时，根据数据内容字典排序。</li>
<li>第一层链表不是单向链表，而是双向链表，为了方便以倒序的方式获取范围内的元素。</li>
<li>在<code>skiplist</code>中可以很方便地计算出每个元素的排名。</li>
</ul>
<h6 id="为什么使用skiplist而不是其他平衡树？"><a href="#为什么使用skiplist而不是其他平衡树？" class="headerlink" title="为什么使用skiplist而不是其他平衡树？"></a>为什么使用<code>skiplist</code>而不是其他平衡树？</h6><p>这个问题<code>redis</code>的作者有回答。</p>
<blockquote>
<p>There are a few reasons:</p>
<p>1) They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then <em>less</em> memory intensive than btrees.</p>
<p>2) A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</p>
<p>3) They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</p>
<p>About the Append Only durability &amp; speed, I don’t think it is a good idea to optimize Redis at cost of more code and more complexity for a use case that IMHO should be rare for the Redis target (fsync() at every command). Almost no one is using this feature even with ACID SQL databases, as the performance hint is big anyway.</p>
<p>About threads: our experience shows that Redis is mostly I/O bound. I’m using threads to serve things from Virtual Memory. The long term solution to exploit all the cores, assuming your link is so fast that you can saturate a single core, is running multiple instances of Redis (no locks, almost fully scalable linearly with number of cores), and using the “Redis Cluster” solution that I plan to develop in the future.</p>
</blockquote>
<p>主要就是：</p>
<ul>
<li>实现简单。</li>
<li>内存不是密集的。</li>
<li>对于范围查找的支持比较好，首先找到区间起始位置，用跳表的时间复杂度是<code>log(n)</code>的，然后按顺序往后遍历即可。</li>
</ul>
<h5 id="常见操作-4"><a href="#常见操作-4" class="headerlink" title="常见操作"></a>常见操作</h5><ul>
<li><p><code>zadd</code>：将指定元素添加到有序集合中。</p>
</li>
<li><p><code>zscore</code>：返回<code>member</code>的<code>score</code>值。</p>
</li>
<li><p><code>zrange</code>：通过指定起始位置和结束位置返回集合中某一范围内的元素，可以通过参数<code>WITHSCORES</code>选择是否同时显示<code>score</code>。</p>
</li>
<li><p><code>zrevrange</code>：返回倒序的<code>zrange</code>。</p>
</li>
<li><p><code>zcard</code>：返回指定集合内元素的个数。</p>
</li>
<li><p><code>zcount</code>：返回指定集合内<code>score</code>在指定区间内的元素个数。</p>
</li>
<li><p><code>zrangebyscore</code>：返回指定集合内<code>score</code>在指定区间内的元素。</p>
</li>
<li><p><code>zrank</code>：返回指定集合内元素的排名（按照<code>score</code>从小到大，从0开始）。</p>
</li>
<li><p><code>zrevrank</code>：返回倒序的<code>zrank</code>。</p>
</li>
<li><p><code>zincrby</code>：增加指定集合内指定元素的<code>score</code>，需要指定增加的大小。</p>
</li>
<li><p><code>zinterstore</code>：根据<code>member</code>求两个集合的交集，并存到新的集合中，两个<code>member</code>的<code>score</code>会相加。</p>
</li>
<li><p><code>zrem</code>：移除指定集合中的元素。</p>
</li>
<li><p><code>zlexcount</code>：返回指定集合内指定字典区间内的元素数量。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD set 0 a 1 b 2 c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT set - +</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT set [a [c</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>zrangebylex</code>：返回指定集合内指定字典区间内的元素，可以指定偏移量。</p>
</li>
</ul>
<h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p>假设要统计<code>UV</code>，需要用到去重功能，同一个用户一天之内的多次访问只能计一次。首先想到的是<code>set</code>，把每一个请求都带上用户的ID，用<code>SADD</code>将ID放入集合，再调用<code>SCARD</code>就可以算出集合的大小。但是如果页面的访问量很大，这时集合的空间也会变得很大。于是便有了<code>HyperLogLog</code>这样的数据结构，它提供了<code>PFADD</code>、<code>PFCOUNT</code>两个指令，相当于<code>set</code>的<code>SADD</code>和<code>SCARD</code>。它的特点是，不存储元素本身，占用空间特别小，但数据可能不太准确。对于统计<code>UV</code>这样的数据再合适不过了。</p>
<h4 id="BloomFilter"><a href="#BloomFilter" class="headerlink" title="BloomFilter"></a>BloomFilter</h4><p>如果我们想知道一个元素是否存在于某集合里，那么<code>HyperLogLog</code>就无能为力了，但使用<code>BloomFilter</code>就可以很高效地解决这个问题。<code>BloomFilter</code>最常见的使用场景就是消息推送了。比如我们在看新闻时，网页会不断推送给我们新内容，每次推送都需要去重增加用户体验，这时就可以用到<code>BloomFilter</code>。</p>
<p><code>BloomFilter</code>的核心实现是一个超大的位数组以及几个哈希函数。假设位数组长度为m，哈希函数个数为k。</p>
<p><img src="%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt=""></p>
<p>以上图为例，集合里有 x、y、z 三个元素，哈希函数的个数为3。首先初始化位数组，将元素全部置为0。对于 x、y、z 三个元素挨个通过3个哈希函数进行映射，每个映射都会生成一个哈希值，对应位数组上的一个位置，将这个位置的值置为1。对于要查询的元素w，同样通过这3个哈希函数获取映射，依次与位数组上对应位置的值进行比较，如果都为1，<code>BloomFilter</code>则判定w存在于集合中，否则则不存在。可以看出，<code>BloomFilter</code>并不能准确判定一个元素是否存在于集合中，因为位数组某个位置上的值为1，也有可能是其他元素通过哈希函数设置的；但很明显<code>BloomFilter</code>可以准确判定一个元素不存在于集合中。</p>
<p>在<code>redis</code>中可以通过<code>BF.ADD</code>和<code>BF.EXISTS</code>添加元素和判断元素是否存在。</p>
<p><code>BloomFilter</code>的<code>initial_size</code>如果过大，会浪费空间；如果过小，会影响准确率，所以需要尽可能精确估计好元素的数量。而<code>error_rate</code>设置得越小，需要的存储空间就越大，对于不需要太精确的场合，设置得大一些也没关系。</p>
<hr>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>缓存。缓存是<code>redis</code>最常用的功能了。可以设置缓存的最大使用量以及淘汰策略以保证缓存的命中率。</li>
<li>计数器。可以对<code>STRING</code>进行自增减操作，实现计数器的功能。由于<code>redis</code>是基于内存的，读写速度快，适合存储频繁读写的技术量。</li>
<li>消息队列。<code>LIST</code>是一个双向链表，可以通过<code>lpush</code>、<code>rpop</code>写入和读取信息。</li>
<li>分布式锁。在分布式场景下，无法使用单机环境下的锁完成对多个节点上的进程进行同步。这时可以使用<code>redis</code>自带的<code>SETNX</code>命令完成分布式锁。还可以使用<code>redlock</code>实现。</li>
</ul>
<hr>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>持久化就是把数据从内存写入到磁盘中，以免服务宕机或重启之后内存数据丢失。</p>
<p><code>redis</code>支持<code>RDB(默认)</code>和<code>AOF</code>两种持久化机制。</p>
<h4 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h4><p><code>RDB</code>是<code>redis</code>默认的持久化方式，按照一定的时间将内存中的数据以快照的形式保存到磁盘中，生成数据文件<code>dump.rdb</code>。可以通过配置文件中的<code>save</code>参数设置快照周期。</p>
<p>优点：</p>
<ol>
<li>方便持久化，只有一个文件。</li>
<li>容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>性能最大化。<code>fork</code>子线程完成写的操作，让主线程继续处理命令，使得IO最大化。使用单独子线程进行数据持久化，主线程不进行IO操作，保证了<code>redis</code>高性能。</li>
<li>数据较大时，比<code>AOF</code>启动效率更高。</li>
</ol>
<p>缺点：</p>
<ol>
<li>数据安全性低。由于<code>RDB</code>持久化是有时间间隔的，如果在这期间<code>redis</code>发生故障，数据会丢失。</li>
</ol>
<h4 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h4><p><code>AOF</code>是将<code>redis</code>执行的每条命令记录到单独的日志文件中。当<code>redis</code>重启时，会重新将日志文件恢复数据。</p>
<p>如果同时开启了两种持久化模式，<code>redis</code>会优先使用<code>AOF</code>。</p>
<p>优点：</p>
<ol>
<li>数据安全性高。<code>AOF</code>可以配置<code>appendfsync</code>属性，设置为<code>always</code>则每执行一次命令操作就记录到文件中一次。</li>
<li>通过<code>append</code>模式写文件，即使中途服务宕机，也可以通过<code>redis-check-aof</code>工具解决数据的一次性问题。</li>
<li><code>AOF</code>机制的<code>rewrite</code>模式。<code>AOF</code>文件没有被<code>rewrite</code>之前，可以删除某些指令(例如误操作的<code>FLUSHALL</code>)。</li>
</ol>
<p>缺点：</p>
<ol>
<li><code>AOF</code>文件比<code>RDB</code>文件大，恢复速度慢。</li>
<li>数据较大时，<code>AOF</code>比<code>RDB</code>启动效率低。</li>
</ol>
<hr>
<h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><p>我们可以设置<code>redis</code>中<code>key</code>的过期时间。针对过期的<code>key</code>，主要有以下三种处理策略：</p>
<ol>
<li>定时过期：每个设置过期时间的<code>key</code>都需要创建一个定时器，到了过期时间就立即删除，释放内存。但同时又会占用大量CPU资源去处理过期的数据，影响性能。</li>
<li>惰性过期：只有当访问了一个<code>key</code>时，才会去判断它是否已过期，过期则删除。该策略造成的问题与定时过期相反。</li>
<li>定期过期：每隔一段时间，会扫描一定数量的数据库的<code>expire</code>字典中一定数量的<code>key</code>，并清除已过期的。<code>expire</code>字典会保存所有设置了过期时间的<code>key</code>的过期时间数据。</li>
</ol>
<p><code>redis</code>中可以通过<code>EXPIRE</code>和<code>PERSIST</code>命令分别设置<code>key</code>的过期时间与永不过期。</p>
<hr>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>内存淘汰策略是指<code>redis</code>内存不足时，如何处理新数据。</p>
<h4 id="全局的键空间选择性移除"><a href="#全局的键空间选择性移除" class="headerlink" title="全局的键空间选择性移除"></a>全局的键空间选择性移除</h4><ul>
<li><code>noeviction</code>：内存不足以容纳新数据时，新写入的操作会报错。</li>
<li><code>allkeys-lru</code>：内存不足以容纳新数据时，在键空间中移除最近最少使用的<code>key</code>。（常用）</li>
<li><code>allkeys-random</code>：内存不足以容纳新数据时，在键空间随机移除某个<code>key</code>。</li>
</ul>
<h4 id="设置过期时间的键空间选择性移除"><a href="#设置过期时间的键空间选择性移除" class="headerlink" title="设置过期时间的键空间选择性移除"></a>设置过期时间的键空间选择性移除</h4><ul>
<li><code>volatile-lru</code>：内存不足以容纳新数据时，在设置了过期时间的键空间中移除最近最少使用的<code>key</code>。</li>
<li><code>volatile-random</code>：内存不足以容纳新数据时，在设置了过期时间的键空间中随机移除某个<code>key</code>。</li>
<li><code>volatile-ttl</code>：内存不足以容纳新数据时，在设置了过期时间的键空间中优先移除过期时间更早的<code>key</code>。</li>
</ul>
<hr>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p><code>redis</code>基于<code>reactor</code>模式开发了网络事件处理器，被称为<strong>文件事件处理器</strong>。它的组成分为四部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。由于文件时间分派器对类的消费是单线程的，所以<code>redis</code>才是单线程模型。</p>
<ul>
<li>文件事件处理器使用I/O多路复用程序同时监听多个套接字，根据套接字目前执行的任务为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器会调用套接字之前关联好的事件处理器来处理事件。</li>
</ul>
<hr>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p><code>redis</code>的通信协议使用的是比较费流量的文本协议，这是因为<code>redis</code>的作者认为数据库的瓶颈不在于网络的流量， 而是在于内部的逻辑。这个文本协议叫做<code>Redis Serialization Protocol</code>，简称<code>RESP</code>。</p>
<p><code>redis</code>协议将传输的数据结构分为5种最小单元，单元结束时，加上换行符<code>\r\n</code>。</p>
<ol>
<li>单行字符串以<code>+</code>开始，例如<code>+irvlin\r\n</code>。</li>
<li>多行字符串以<code>$</code>开始，例如<code>$irv\r\nlin\r\n</code>。</li>
<li>整数以<code>:</code>开始，例如<code>:1024\r\n</code>。</li>
<li>错误消息以<code>-</code>开始。</li>
<li>数组以<code>*</code>开始，后面加上数组的长度。</li>
</ol>
<p>如果使用客户端连接服务器的话，只能使用第5种。</p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>通过<code>socket + RESP</code>来实现<code>redis</code>的<code>set</code>和<code>get</code>命令。</p>
<p>首先把配置文件中的<code>requirepass</code>注释掉，方便客户端连接服务器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6379</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"redis连接失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"*3"</span>)</span><br><span class="line">                .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                .append(<span class="string">"$"</span>)</span><br><span class="line">                .append(<span class="string">"set"</span>.length())</span><br><span class="line">                .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                .append(<span class="string">"set"</span>)</span><br><span class="line">                .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                .append(<span class="string">"$"</span>)</span><br><span class="line">                .append(key.getBytes().length)</span><br><span class="line">                .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                .append(key)</span><br><span class="line">                .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                .append(<span class="string">"$"</span>)</span><br><span class="line">                .append(value.getBytes().length)</span><br><span class="line">                .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                .append(value)</span><br><span class="line">                .append(<span class="string">"\r\n"</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        socket.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> read = socket.getInputStream().read(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"*2"</span>)</span><br><span class="line">                .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                .append(<span class="string">"$"</span>)</span><br><span class="line">                .append(<span class="string">"get"</span>.length())</span><br><span class="line">                .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                .append(<span class="string">"get"</span>)</span><br><span class="line">                .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                .append(<span class="string">"$"</span>)</span><br><span class="line">                .append(key.getBytes().length)</span><br><span class="line">                .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                .append(key)</span><br><span class="line">                .append(<span class="string">"\r\n"</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        socket.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> read = socket.getInputStream().read(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> RedisClient().set(<span class="string">"a"</span>, <span class="string">"123"</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> RedisClient().get(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果，<code>set</code>返回<code>+OK</code>，<code>get</code>返回<code>$3 123</code>。</p>
<hr>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><code>redis</code>事务是一次性、顺序性、排他性地执行队列中的一系列命令。</p>
<h4 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h4><ol>
<li>事务开始<code>MULTI</code></li>
<li>命令入队</li>
<li>事务执行<code>EXEC</code></li>
</ol>
<p><code>redis</code>会将一个事务中的所有命令序列化，按顺序执行。</p>
<h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul>
<li><code>MULTI</code>：开启一个事务，总是返回<code>OK</code>。<code>MULTI</code>执行之后，客户端仍可以向服务器发送任意多条命令，这些命令会被放入一个队列中，当<code>EXEC</code>命令被调用后，这些队列中的命令才会被执行。</li>
<li><code>WATCH</code>：乐观锁，可以为所有<code>redis</code>事务提供<code>CAS</code>行为。可以监控任意多个键，一旦其中一个键被修改或移除，之后的事务就不会执行，监控一直持续到<code>EXEC</code>命令被调用。</li>
<li><code>UNWATCH</code>：取消所有对<code>key</code>的监控。</li>
<li><code>DISCARD</code>：客户端可以清空事务队列，放弃执行事务，并且客户端会从事务状态中退出。</li>
<li><code>EXEC</code>：执行事务中的所有命令。返回所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回<code>nil</code>。</li>
</ul>
<p><code>redis</code>事务支持一致性和隔离性。当持久化模式为<code>AOF</code>，且<code>appendfsync</code>的值为<code>always</code>时，<code>redis</code>事务也支持持久性。</p>
<p><code>redis</code>事务的单条命令是原子性的，但事务不保证原子性，没有回滚。事务中的任意命令执行失败，其他命令仍可以被执行。</p>
<p>使用<code>lua</code>脚本可以保证脚本内的命令一次性、顺序性的被执行，但其仍然不支持回滚，如果部分命令执行失败，其他命令还是会被执行。</p>
<hr>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p><img src="%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>哨兵是<code>redis</code>集群中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控<code>redis</code> <code>master</code>与<code>slave</code>是否正常工作。</li>
<li>消息通知：如果某个<code>redis</code>实例有故障，哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果<code>master node</code>挂了，会自动转移到<code>slave node</code>上。</li>
<li>配置中心：如果故障转移发生了，会通知<code>client</code>新的<code>master</code>地址。</li>
</ul>
<p>哨兵模式主要用于实现<code>redis</code>集群的高可用。判断一个<code>master node</code>是否挂了，需要大部分哨兵认同才算，这涉及到了分布式选举的问题。哨兵模式至少需要3个实例。</p>
<h4 id="集群模式工作原理"><a href="#集群模式工作原理" class="headerlink" title="集群模式工作原理"></a>集群模式工作原理</h4><p>在<code>redis3.0</code>版本提供了<code>redis cluster</code>技术，采用<code>slot</code>的概念，一共16384个槽。将请求发向任意节点，接受到请求的节点将会查询请求发送到正确的节点上。</p>
<p>在<code>redis cluster</code>架构下，每个<code>redis</code>需要开放两个端口，例如6379以及16379。16379主要用于节点之间的通信，也就是<code>cluster bus</code>，主要利用了一种二进制的通信协议：<code>gosip</code>协议，用于节点之间高效的数据交换，占用更少的带宽和处理时间。</p>
<h4 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h4><p>对于缓存来说，是需要支持高并发场景的，所以架构一般做成主从架构，一主多从，主负责写，从负责读。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>当启动一个<code>slave node</code>时，会发送一个<code>PSYNC</code>命令给<code>master node</code>。如果这是第一次连接，则会触发一次<strong>全量复制</strong>。<code>master</code>会启动一个后台线程生成一份<code>RDB</code>快照文件，同时将从<code>client</code>新收到的所有写命令缓存于内存中。<code>RDB</code>文件生成完成后，<code>master</code>会将这个文件发送给<code>slave</code>，<code>slave</code>先将这个文件写入本地磁盘，再加载到内存中。接着<code>master</code>将之前内存中的命令发送给<code>slave</code>，<code>slave</code>开始同步这部分数据。</p>
<p>之后如果<code>slave node</code>与<code>master node</code>断开了连接，重连之后不再进行全量复制，只将<code>slave</code>缺失的数据复制给它。</p>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>分区是分割数据到多个<code>redis</code>实例的过程。每个实例只保存<code>key</code>的一个子集。</p>
<hr>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>通过<code>SETNX</code>命令获取锁。返回1说明获取成功，0说明获取失败。获取到锁之后，通过<code>EXPIRE</code>命令给<code>key</code>设置一个过期时间防止死锁。释放锁时通过<code>DEL</code>命令删除锁。</p>
<p>但如果<code>SETNX</code>执行成功，<code>EXPIRE</code>执行失败那咋办？在<code>redis2.6.12</code>之后作者对<code>SET</code>命令进行了拓展，加了一系列参数：</p>
<p><code>SET key value [EX seconds][PX milliseconds][NX|XX]</code>。例如<code>SET k v EX 5 NX</code>可将键<code>k</code>的值设置为<code>v</code>，5秒后超时，且仅当键不存在时才进行设置。仅当<code>SET</code>命令设置成功才返回<code>OK</code>，否则将返回空批量回复(NULL Bulk Reply)。</p>
<p>但这时又有一个新问题了。如果业务代码比较耗时，超过了设置的过期时间怎么办？可以从两个角度入手：</p>
<ul>
<li>尽量避免获取锁之后执行一些耗时的操作。</li>
<li>可以将锁的<code>value</code>设置为一个随机字符串，每次释放锁都比较随机字符串是否一致，如果一致才释放。</li>
</ul>
<p>对于第二种方案，很明显不是原子操作。为了解决这个问题，在<code>redis 2.6</code>引入了<code>lua</code>脚本。</p>
<h4 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h4><p><code>lua</code>脚本的优势：</p>
<ul>
<li>使用方便，<code>reis</code>内置了对<code>lua</code>脚本的支持。</li>
<li><code>lua</code>脚本可以在<code>redis</code>服务端原子的执行多个<code>redis</code>命令。</li>
<li>由于网络在很大程度上会影响<code>redis</code>的性能，而使用<code>lua</code>脚本可以让命令一次执行，可以有效解决网络给<code>redis</code>带来的性能问题。</li>
</ul>
<p>在<code>redis</code>中使用<code>lua</code>脚本有两种方式：</p>
<ul>
<li>在<code>redis</code>服务端写好<code>lua</code>脚本，在<code>Java</code>客户端调用脚本。（推荐）</li>
<li>直接在<code>Java</code>客户端写好<code>lua</code>脚本，需要执行时将脚本发送到<code>redis</code>执行。</li>
</ul>
<h5 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h5><p>首先在<code>redis</code>服务端创建<code>lua</code>脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>然后给这个脚本求一个<code>SHA1</code>和：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat test.lua | redis-cli -a passwd script load --pipe</span><br></pre></td></tr></table></figure>

<p>接着在<code>Java</code>客户端调用这个脚本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CallWithJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Jedis jedis)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JedisPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Redis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GenericObjectPoolConfig&lt;?&gt; config = <span class="keyword">new</span> GenericObjectPoolConfig&lt;&gt;();</span><br><span class="line">        <span class="comment">// 连接池最大空闲数</span></span><br><span class="line">        config.setMaxIdle(<span class="number">300</span>);</span><br><span class="line">        <span class="comment">// 最大连接数</span></span><br><span class="line">        config.setMaxTotal(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 连接最大等待时间，如果是 -1 表示没有限制</span></span><br><span class="line">        config.setMaxWaitMillis(<span class="number">30000</span>);</span><br><span class="line">        <span class="comment">// 在空闲时检查有效性</span></span><br><span class="line">        config.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1. Redis 地址</span></span><br><span class="line"><span class="comment">         * 2. Redis 端口</span></span><br><span class="line"><span class="comment">         * 3. 连接超时时间</span></span><br><span class="line"><span class="comment">         * 4. 密码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pool = <span class="keyword">new</span> JedisPool(config, <span class="string">"localhost"</span>, <span class="number">6379</span>, <span class="number">30000</span>, <span class="string">"passwd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(CallWithJedis callWithJedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Jedis jedis = pool.getResource()) &#123;</span><br><span class="line">            callWithJedis.call(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Redis().execute(jedis -&gt; &#123;</span><br><span class="line">                <span class="comment">// 随机字符串</span></span><br><span class="line">                String value = UUID.randomUUID().toString();</span><br><span class="line">                <span class="comment">// 获取锁</span></span><br><span class="line">                String k1 = jedis.set(<span class="string">"k1"</span>, value, <span class="keyword">new</span> SetParams().nx().ex(<span class="number">5</span>));</span><br><span class="line">                <span class="comment">// 如果拿到锁</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"OK"</span>.equals(k1)) &#123;</span><br><span class="line">                    <span class="comment">// 具体业务</span></span><br><span class="line">                    jedis.set(<span class="string">"website"</span>, <span class="string">"http://irvlin.xyz"</span>);</span><br><span class="line">                    String website = jedis.get(<span class="string">"website"</span>);</span><br><span class="line">                    System.out.println(website);</span><br><span class="line">                    <span class="comment">// 执行lua脚本，当value一致才会释放锁</span></span><br><span class="line">                    jedis.evalsha(SHA1值, Collections.singletonList(<span class="string">"k1"</span>), Collections.singletonList(value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"获取锁失败"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就不会出现由于业务耗时超过过期时间而引发的锁释放紊乱的问题了。</p>
<h4 id="redlock"><a href="#redlock" class="headerlink" title="redlock"></a>redlock</h4><p><code>redis</code>提供了一种权威的基于<code>redis</code>实现分布式锁的方式叫做<code>redlock</code>。它能保证以下特性：</p>
<ol>
<li>安全：互斥访问，永远只有一个<code>client</code>能获取到锁。</li>
<li>避免死锁。</li>
<li>容错性：只要大部分<code>redis</code>节点存活就能正常提供服务。</li>
</ol>
<hr>
<h3 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>指缓存同一时间大面积失效。所有请求都会落到数据库上，可能造成数据库短时间承受过多请求而崩掉。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>给缓存的数据的过期时间设置随机值，以免同一时间大量缓存同时过期。</li>
<li>如果并发量不是很大，可以给请求加锁排队，避免同一时间请求过多。</li>
<li>给每个缓存设置缓存标记，记录缓存是否失效，如果失效则更新数据缓存。</li>
</ol>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>指缓存和数据库中都没有的数据，还是导致所有请求都落到数据库上，可能造成数据库短时间承受过多请求而崩掉。这可能是由于恶意请求导致的，例如伪造id为-1的请求，这实际上是不存在的数据。</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>接口层增加数据校验，对请求的数据做一些基本的过滤。例如<code>id&lt;=0</code>直接拦截不走缓存和数据库。</li>
<li>缓存和数据库都没有的数据，可以将<code>key-value</code>设置为<code>key-null</code>，设置一个较短的过期时间，防止短时间内大量恶意请求攻击。</li>
<li>使用布隆过滤器，将所有可能存在的数据通过哈希放到足够大的位数组中，如果请求数据不存在会被布隆过滤器直接拦截。</li>
</ol>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>指缓存中没有数据库中有的数据（一般是缓存时间过期），这时由于并发量大，同一时间大量请求走数据库导致崩溃。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩指不同数据。</p>
<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>热点数据设置永不过期。</li>
<li>互斥锁。</li>
</ol>
<h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p>指系统上线后，将缓存的数据预先加载到系统中，避免一开始的请求先查询数据库再将数据缓存。</p>
<h5 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>项目启动时手动加载缓存。</li>
<li>定时刷新缓存。</li>
</ol>
<hr>
<h3 id="redis与memcached区别"><a href="#redis与memcached区别" class="headerlink" title="redis与memcached区别"></a>redis与memcached区别</h3><p>两者都是非关系型数据库，基于内存。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">redis</th>
<th align="center">memcached</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据类型</td>
<td align="center">String、List、Set、Hash、ZSet</td>
<td align="center">文本型、二进制类型</td>
</tr>
<tr>
<td align="center">查询类型</td>
<td align="center">批量操作、支持事务、不同类型的操作指令不同</td>
<td align="center">常用CRUD指令</td>
</tr>
<tr>
<td align="center">附加功能</td>
<td align="center">发布/订阅模式、主从架构、数据分区、支持脚本</td>
<td align="center">支持多线程</td>
</tr>
<tr>
<td align="center">网络IO模型</td>
<td align="center">单线程多路IO复用模型</td>
<td align="center">多线程非阻塞IO模式</td>
</tr>
<tr>
<td align="center">事件库</td>
<td align="center">AeEvent</td>
<td align="center">LibEvent</td>
</tr>
<tr>
<td align="center">持久化</td>
<td align="center">RDB、AOF</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">集群模式</td>
<td align="center">原生支持cluster模式，可以实现主从复制、读写分离</td>
<td align="center">没有原生支持，依赖客户端实现</td>
</tr>
<tr>
<td align="center">内存管理机制</td>
<td align="center">可以将内存中很久没用到的数据交换到磁盘</td>
<td align="center">数据永远在内存中，将内存分割成特定长度的块存储数据解决内存碎片的问题</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">数据结构复杂，需要持久化、高可用</td>
<td align="center">纯键值对，数据量大，并发量大的业务</td>
</tr>
</tbody></table>
<hr>
<h3 id="双写数据一致性"><a href="#双写数据一致性" class="headerlink" title="双写数据一致性"></a>双写数据一致性</h3><p>如果用到了缓存，就可能会涉及缓存和数据库双存储双写，只要双写就会有数据一致性的问题。如何解决一致性问题呢？</p>
<p>一般来说，如果允许缓存可以稍微和数据库偶尔有不一致的情况，那么最好不要将读请求和写请求串行化，存到内存队列中。串行化可以保证一定不会出现数据不一致的情况，但也导致了系统的吞吐量大幅度降低。可以先更新数据库，将缓存设为失效。这样再次读取数据时，如果缓存不存在就会读取数据库，这时再写入缓存。</p>
<hr>
<h3 id="一个字符串类型的值存储的最大容量"><a href="#一个字符串类型的值存储的最大容量" class="headerlink" title="一个字符串类型的值存储的最大容量"></a>一个字符串类型的值存储的最大容量</h3><p>512M</p>
<hr>
<h3 id="redis插入大量数据"><a href="#redis插入大量数据" class="headerlink" title="redis插入大量数据"></a>redis插入大量数据</h3><p><code>redis2.6</code>开始<code>redis-cli</code>支持一种新的模式<code>pip mode</code>用于执行大量数据的插入。</p>
<hr>
<h3 id="异步队列"><a href="#异步队列" class="headerlink" title="异步队列"></a>异步队列</h3><p>用<code>list</code>保存数据，<code>RPUSH</code>生产消息，<code>LPOP</code>消费信息。<code>LPOP</code>无消息时，可以使用<code>BLPOP</code>，会一直阻塞直到消息的到来。</p>
<hr>
<h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><p>使用<code>ZSet</code>，用时间戳作为<code>score</code>，消息内容作为<code>key</code>，调用<code>ZADD</code>命令生产消息，消费者使用<code>ZRANGEBYSCORE</code>获取n秒之前的数据做轮询处理。</p>
<hr>
<h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p><code>redis</code>提供的<code>Bitmaps</code>可以实现对位的操作。<code>Bitmaps</code>本身不是一种数据结构，其本质就是字符串，但可以对字符串进行位操作。其设置命令为<code>SETBIT key offset value</code>，获取值命令为<code>GETBIT key offset</code>，获取指定范围内为1的个数的指令为<code>BITCOUNT key [start] [end]</code>，这里的<code>start</code>和<code>end</code>指的是字符串的起始和结束位置。</p>
<p>假设我们要存储每个用户每个月的登录天数就可以使用<code>Bitmaps</code>。利用位操作将登录日期对应的位的值设置为1即代表当天已登录。利用<code>Bitmaps</code>的好处就是占用的空间小，操作快。</p>
<hr>
<h3 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h3><p><code>scan</code>是<code>keys</code>命令的升级版。在查询<code>key</code>时可以通过<code>keys</code>加上通配符的命令进行查询，但是<code>keys</code>命令不是异步的，如果数据量很大的话会消耗很多时间，同时也没有分页的功能。为了解决这个问题，<code>redis 2.8</code>引入了<code>scan</code>。<code>scan</code>具备<code>keys</code>的功能，且不会阻塞，还可以控制返回的结果数。</p>
<p><code>scan</code>命令一共提供了三个参数，第一个是<code>cursor</code>，第二个是<code>key</code>的正则模式，第三个是<code>limit</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match * count 1</span><br><span class="line">1) "2"</span><br><span class="line">2) 1) "a"</span><br></pre></td></tr></table></figure>

<p>表示游标从0开始，匹配所有<code>key</code>，返回的数量为1。这个命令有两个返回值，第一个是游标的下一个位置，另一个是<code>key</code>值。如果游标返回0说明遍历已结束。</p>
<p>这里返回的游标的下一个位置，并不是按照十进制+1的规律返回，而是转为二进制，例如：<code>00 -&gt; 10 -&gt; 01 -&gt; 11</code>，再转为十进制就是<code>0 -&gt; 2 -&gt; 1 -&gt; 3</code>。相当于和传统二进制加法相反的规律，从左往右加。在<code>redis</code>中实际的操作是：</p>
<ol>
<li>反转要加的数字</li>
<li>反转后的数字加一</li>
<li>再反转</li>
</ol>
<p>那么为什么要按这样的顺序遍历呢？主要是考虑到遍历时发生字典扩容和缩容的情况。假设原始的数组有4个元素，游标有两位，这时进行扩容，扩容为3位，进行<code>rehash</code>。</p>
<p><img src="scan_rehash.png" alt=""></p>
<p>原来在<code>XX</code>之下的所有元素都被分配到<code>0XX</code>和<code>1XX</code>之下。比如我们即将遍历<code>10</code>时，发生了扩容，进行<code>rehash</code>，这时<code>scan</code>会从<code>010</code>开始遍历，而原来在<code>00</code>之下的元素不会再被遍历到。</p>
<p>而缩容的情况是，假设我们即将遍历到<code>110</code>时，发生了缩容，这时<code>scan</code>会遍历<code>10</code>，这样的话<code>010</code>下的元素会被重复遍历到，但<code>010</code>之前的元素不会被重复遍历到了。所以缩容的时候还是有可能会重复遍历元素的。</p>
<h4 id="scan-相关指令"><a href="#scan-相关指令" class="headerlink" title="scan 相关指令"></a>scan 相关指令</h4><p><code>scan</code>其实是一系列的指令，还可以遍历不同类型的<code>key</code>，对应的命令有：</p>
<ul>
<li><code>zscan</code> -&gt; <code>zset</code></li>
<li><code>hscan</code> -&gt; <code>hash</code></li>
<li><code>sscan</code> -&gt; <code>set</code>    </li>
</ul>
<hr>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p><code>LRU(Least Recent Used)</code>，最近最少使用。</p>
<p>在计算机体系结构中，最大的可靠的存储是硬盘，容量大、数据可以固化，但缺点是访问的速度慢，所以使用时要把数据加载到内存中；内存的访问速度快，但是容量很有限，并且断电之后数据就丢失了。所以引入了<code>LRU</code>算法，当内存不够用时肯定要淘汰旧的数据。</p>
<p><code>LRU</code>要求数据的放入和移除都是<code>O(1)</code>的。</p>
<h4 id="Java-实现-LRU"><a href="#Java-实现-LRU" class="headerlink" title="Java 实现 LRU"></a>Java 实现 LRU</h4><p>整体设计思路是，利用<code>HashMap</code>存储<code>key</code>，可以做到存储和获取<code>key</code>都是<code>O(1)</code>的。<code>HashMap</code>的<code>value</code>指向<strong>双向链表</strong>的节点。</p>
<h5 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V val;</span><br><span class="line">    DLinkedNode&lt;K, V&gt; pre;</span><br><span class="line">    DLinkedNode&lt;K, V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// value指向双链表中的节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, DLinkedNode&lt;K, V&gt;&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 已占个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="comment">// 头尾节点，不存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DLinkedNode&lt;K, V&gt; head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"["</span>);</span><br><span class="line">        DLinkedNode&lt;K, V&gt; cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != tail) &#123;</span><br><span class="line">            sb.append(<span class="string">"["</span>).append(cur.key).append(<span class="string">", "</span>).append(cur.val).append(<span class="string">"],"</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode&lt;&gt;();</span><br><span class="line">        head.pre = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode&lt;&gt;();</span><br><span class="line">        tail.next = <span class="keyword">null</span>;</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        DLinkedNode&lt;K, V&gt; node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 访问了该节点，移到头部</span></span><br><span class="line">        <span class="keyword">this</span>.moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        DLinkedNode&lt;K, V&gt; node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            DLinkedNode&lt;K, V&gt; newNode = <span class="keyword">new</span> DLinkedNode&lt;&gt;();</span><br><span class="line">            newNode.key = key;</span><br><span class="line">            newNode.val = value;</span><br><span class="line">            <span class="keyword">this</span>.cache.put(key, newNode);</span><br><span class="line">            <span class="keyword">this</span>.addNode(newNode);</span><br><span class="line">            <span class="comment">// 如果数据量已达到阈值，删除尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (cnt == cap) &#123;</span><br><span class="line">                DLinkedNode&lt;K, V&gt; tail = <span class="keyword">this</span>.popTail();</span><br><span class="line">                <span class="keyword">this</span>.cache.remove(tail.key);</span><br><span class="line">            &#125; <span class="keyword">else</span> cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.val = value;</span><br><span class="line">            <span class="keyword">this</span>.moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(DLinkedNode&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.removeNode(node);</span><br><span class="line">        <span class="keyword">this</span>.addNode(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        node.pre = <span class="keyword">null</span>;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DLinkedNode&lt;K, V&gt; <span class="title">popTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode&lt;K, V&gt; t = tail.pre;</span><br><span class="line">        <span class="keyword">this</span>.removeNode(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache&lt;String, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        cache.set(<span class="string">"a"</span>, <span class="string">"a"</span>);</span><br><span class="line">        cache.set(<span class="string">"b"</span>, <span class="string">"b"</span>);</span><br><span class="line">        cache.set(<span class="string">"c"</span>, <span class="string">"c"</span>);</span><br><span class="line">        System.out.println(<span class="string">"a = "</span> + cache.get(<span class="string">"a"</span>));</span><br><span class="line">        cache.set(<span class="string">"d"</span>, <span class="string">"d"</span>);</span><br><span class="line">        System.out.println(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Redis-中的-LRU"><a href="#Redis-中的-LRU" class="headerlink" title="Redis 中的 LRU"></a>Redis 中的 LRU</h5><p>如果像前面一样利用<code>HashMap</code>和双向链表实现<code>LRU</code>，需要额外存储<code>pre</code>和<code>next</code>指针，这在<code>redis</code>中显然是不划算的。于是<code>redis</code>选择了折中的办法，也就是随机取出若干个<code>key</code>，然后按照访问的时间排序淘汰掉最不经常使用的。</p>
<p><code>redis</code>配置中和<code>LRU</code>有关的有三个参数：</p>
<ul>
<li><code>maxmemory</code>：指定限制的内存大小，当缓存消耗的内存超过这个数就会触发内存淘汰。如果配置为0代表无限制，64位系统的默认值为0，32位系统的默认值为3GB。</li>
<li><code>maxmemory_policy</code>：内存淘汰策略，前面已经提到过了。</li>
<li><code>maxmemory_samples</code>：随机采样的精度，也就是随机取出多少个<code>key</code>。这个数越大，则越接近实际的<code>LRU</code>算法，但是同时内存的消耗也会变大。默认值为5。</li>
</ul>
<hr>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><h4 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h4><p><code>Pipeline（管道）</code>本质上是由客户端提供的一种操作。<code>Pipeline</code>可以调整指令的读写顺序，大大节省<code>I/O</code>时间。</p>
<h4 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RateLimiter</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限流方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 限流的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 具体业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> period 限流周期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxCount 限流次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否被限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowed</span><span class="params">(String user, String action, <span class="keyword">int</span> period, <span class="keyword">int</span> maxCount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// zset存储数据</span></span><br><span class="line">        String key = user + <span class="string">"-"</span> + action;</span><br><span class="line">        <span class="comment">// 当前时间戳作为score和member</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 建立管道</span></span><br><span class="line">        Pipeline pipelined = jedis.pipelined();</span><br><span class="line">        <span class="comment">// 开启任务</span></span><br><span class="line">        pipelined.multi();</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        pipelined.zadd(key, now, String.valueOf(now));</span><br><span class="line">        <span class="comment">// 移除限流周期之外的数据</span></span><br><span class="line">        pipelined.zremrangeByScore(key, <span class="number">0</span>, now - period * <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 获取限流周期内元素的个数</span></span><br><span class="line">        Response&lt;Long&gt; response = pipelined.zcard(key);</span><br><span class="line">        <span class="comment">// 执行、关闭</span></span><br><span class="line">        pipelined.exec();</span><br><span class="line">        pipelined.close();</span><br><span class="line">        <span class="comment">// 操作数是否小于等于最大值，返回false说明当前操作不被允许</span></span><br><span class="line">        <span class="keyword">return</span> response.get() &lt;= maxCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Redis().execute(jedis1 -&gt; &#123;</span><br><span class="line">            RateLimiter rateLimiter = <span class="keyword">new</span> RateLimiter(jedis1);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 同一个用户5秒之内允许3次评论操作</span></span><br><span class="line">                System.out.println(rateLimiter.isAllowed(<span class="string">"irvlin"</span>, <span class="string">"comment"</span>, <span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后运行发现，由于循环在5秒之内可以完成，所以只有前3次的操作返回的是<code>true</code>，说明达到了限流的效果。但这只能针对数据量小的场景，如果数据量大的话，上述操作会非常耗时。例如<code>pipelined.zremrangeByScore</code>的操作，其时间复杂度为<code>O(log(N)+M)</code>，<code>N</code>是<code>zset</code>中的元素数量，<code>M</code>是要移除的数量。很明显当数据量增大时，消耗的时间也在增长。</p>
<h4 id="redis-cell"><a href="#redis-cell" class="headerlink" title="redis-cell"></a>redis-cell</h4><h5 id="漏斗算法"><a href="#漏斗算法" class="headerlink" title="漏斗算法"></a>漏斗算法</h5><p>漏斗算法的主要目的是控制数据注入网络的速率，平滑网络上的突发流量。</p>
<p><img src="%E6%BC%8F%E6%96%97%E7%AE%97%E6%B3%95" alt=""></p>
<p>漏斗有一个进水口和一个出水口，出水口有一个最大出水速率，以一定的速率出水。</p>
<p>如果漏斗中没有水：</p>
<ul>
<li>如果进水速率小于等于最大出水速率，那么出水速率等于进水速率，漏斗不积水。</li>
<li>如果进水速率大于最大出水速率，那么漏斗以最大出水速率出水，漏斗内的水会慢慢变多。</li>
</ul>
<p>如果漏斗内有水：</p>
<ul>
<li>出水口以最大速率出水。</li>
<li>如果漏斗满了，会拒绝请求。</li>
</ul>
<p>由于漏斗算法能够限制数据的传输速率，因此面对突发特性的数据传输来说缺乏效率。</p>
<h5 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h5><p>令牌桶算法是一种网络流量整形和速率限制的算法，主要用于控制发送到网络上的数据数目，允许突发数据的发送。</p>
<p><img src="%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95" alt=""></p>
<p>系统会按照一定的时间间隔：<code>1/QPS</code>往桶中加入<code>token</code>，如果满了就不加了。然后根据预设的匹配规则对发送来的报文进行分类，如果匹配不上就直接放行，否则需要令牌桶进行处理，如果桶内有足够的令牌那么报文可以被发送，桶中的令牌按报文的长度相应地减少。如果令牌不够要等到令牌够了才能发送。</p>
<p>只要桶中的令牌数量足够，令牌桶算法可以允许突发传输数据。</p>
<h5 id="实战-3"><a href="#实战-3" class="headerlink" title="实战"></a>实战</h5><p><code>redis 4.0</code>开始提供了一个<code>redis-cell</code>模块，使用漏斗算法实现了限流的功能。<code>redis</code>只提供了一个命令<code>CL.THROTTLE</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cl.throttle key 15 30 60 1</span><br><span class="line">             ▲  ▲  ▲  ▲  ▲</span><br><span class="line">             |  |  |  |  └─── 每次漏出的数量，默认为1</span><br><span class="line">             |  |  └──┴────── 每60秒可以操作30次</span><br><span class="line">             |  └──────────── 漏斗容量</span><br><span class="line">             └─────────────── key</span><br></pre></td></tr></table></figure>

<p>该方法有5个返回值：</p>
<ul>
<li>第一个参数0表示允许，1表示拒绝。</li>
<li>第二个参数是漏斗的容量。</li>
<li>第三个参数是漏斗的剩余空间。</li>
<li>第四个参数表示如果被拒绝，多久之后可以重试（秒）。</li>
<li>第五个参数表示多久之后漏斗会空（秒）。</li>
</ul>
<h6 id="使用-Lettuce"><a href="#使用-Lettuce" class="headerlink" title="使用 Lettuce"></a>使用 Lettuce</h6><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先定义一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisCommandInterface</span> <span class="keyword">extends</span> <span class="title">Commands</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cap 漏斗容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 时间窗内允许操作的次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> period 时间窗</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> quota 每次漏出的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> CL.THROTTLE返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Command</span>(<span class="string">"CL.THROTTLE ?0 ?1 ?2 ?3 ?4"</span>)</span><br><span class="line">    <span class="function">List&lt;Object&gt; <span class="title">throttle</span><span class="params">(String key, Long cap, Long count, Long period, Long quota)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrottleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RedisClient redisClient = RedisClient.create(<span class="string">"redis://passwd@localhost"</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();</span><br><span class="line">        RedisCommandFactory factory = <span class="keyword">new</span> RedisCommandFactory(connect);</span><br><span class="line">        RedisCommandInterface commands = factory.getCommands(RedisCommandInterface<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 初始容量为15，60秒内允许30次操作，每次漏出数量为1</span></span><br><span class="line">        List&lt;Object&gt; list = commands.throttle(<span class="string">"irvlin-comment"</span>, <span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">1L</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记</title>
    <url>/2020/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>计算机网络学习笔记</p>
<a id="more"></a>

<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><p>互联网的发展主要经历了以下七个阶段：</p>
<ol>
<li><strong>批处理</strong>：批处理是指事先把用户的程序数据装入卡带或者磁带，由计算机按一定的顺序进行读取处理。</li>
<li><strong>分时系统</strong>：分时系统允许多个终端同时接入计算机，这允许了多个用户同时操作计算机。</li>
<li><strong>计算机通信技术</strong>：分时系统中，两个主机互联、交互数据的过程相当繁琐，所以计算机通信技术应运而生，使得计算机之间的通信变得便捷，缩短了数据传输的速度。</li>
<li><strong>计算机网络的产生</strong>：20世纪70年代，人们开始研究基于分组交换技术的计算机网络以及不同厂商的计算机之间的通信技术。直到80年代，一种能够互联多种计算机的网络诞生了。</li>
<li><strong>互联网普及</strong>：20世纪90年代，计算机逐渐普及。各个厂商着力于让自己的网络技术兼容<strong>TCP/IP</strong>。</li>
<li><strong>互联网时代</strong>：随着互联网的普及，人们已经离不开互联网了，世界进入万物互联时代。</li>
<li><strong>网络安全时代</strong>：随着万物互联的时代到来，网络安全成了最重要的一环。</li>
</ol>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><ul>
<li>比特(bit)：<code>bit</code>是计算机中数据量的单位，来源于<code>binary digit</code>，意为二进制数字。网络的速率指的是连接到网络的主机在数字信道上传输数据的速率，也称为数据率或者比特率。</li>
<li>带宽：带宽用来表示网络的通信线路传输数据的能力。网络带宽表示单位时间内从网络的某一点到另一点所能通过的最高数据率，单位为比特/秒。</li>
<li>吞吐量：吞吐量表示单位时间内通过某个网络（或信道、接口等）的数据量，表示当前网络传输数据的能力。</li>
<li>时延：<ol>
<li>发送时延：指主机或路由器发送数据帧所需时间。</li>
<li>传播时延：指电磁波在信道中传播一定距离所需时间。</li>
</ol>
</li>
<li>往返时间：表示从发送方发送数据开始，到发送方收到来自接收方的确认总共的时间。往返时间一般会包括分组在网络中的各种时延。</li>
<li>利用率：分为<strong>信道利用率</strong>和<strong>网络利用率</strong>。信道利用率指某信道有多少百分比的时间是被利用的；网络利用率指全网络的信道利用率的加权平均值。信道利用率并非越高越好，因为信道利用率增大时，时延也会迅速增加。</li>
</ul>
<h4 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h4><ul>
<li>局域网（Local Area NetWork）：例如办公室、网吧等场所的网络。连接范围窄，用户少，连接速率高。</li>
<li>城域网（Metropolitan Area NetWork）：用于将一个城市、企业或学校等的局域网连接起来实现资源共享。</li>
<li>广域网（Wide Area NetWork）：使不同城市间的网络互连，由于距离较远，信息衰减比较严重，一般需要特殊的协议进行连接，构成网状结构。</li>
</ul>
<h4 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h4><ul>
<li>OSI七层模型</li>
</ul>
<p><img src="OSI%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<ul>
<li>五层模型</li>
</ul>
<p><img src="%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<ul>
<li>TCP/IP分层模型</li>
</ul>
<p><img src="TCP%E3%80%81IP%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<p>OSI 七层协议的结构是最完整的，但是比较复杂，也不实用，因此最广泛使用的是 TCP/IP 分层结构。在实际学习计算机网络时一般采取折中的办法，也就是五层模型。</p>
<h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><h6 id="数字信号、模拟信号"><a href="#数字信号、模拟信号" class="headerlink" title="数字信号、模拟信号"></a>数字信号、模拟信号</h6><p>自然界的信号分为数字信号和模拟信号两种。模拟信号的特点是幅度连续，波形在时间上也是连续的。但数字信号在时间域上的离散的，有 0、1 两种物理状态。</p>
<p>两者是可以相互转换的。模拟信号使用<code>PCM</code>量化并转换为数字信号；数字信号通过载波相移得到模拟信号。</p>
<h6 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h6><p>数据在物理层传输的媒介是不一样的，大致分为两类：</p>
<ol>
<li>引导型传输媒介：例如同轴电缆、双绞线、光缆等等。</li>
<li>非引导型传输媒介：指的是无线电波在空间中的传播，不同的频段可以传输不同的信号。</li>
</ol>
<h6 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h6><p>信道按照传输媒介可以分三类：</p>
<ol>
<li>有线信道：以导线为传输媒介，传输效率高，但部署不灵活。</li>
<li>无线信道：以辐射无线电波为传输方式的无线电信道和水下传播声波的水声信道。</li>
<li>存储信道：磁带、光盘、磁盘等存储介质也可以被看作是通信信道。将数据写入存储介质的过程等效于发射机将信号传输到信道的过程，将数据从存储介质读出的过程等效于接收机从信道接收信号的过程。</li>
</ol>
<p>信道是传输信息的信道，<strong>信道容量</strong>代表信道无差错传输信息的最大能力；而<strong>信噪比</strong>是指放大器输出信号的功率与同时输出的噪声功率的比值，设备的信噪比越高说明产生的噪声越小。公式为：</p>
<p><img src="%E4%BF%A1%E5%99%AA%E6%AF%94%E5%85%AC%E5%BC%8F.png" alt=""></p>
<p><code>C</code>为信道容量，<code>B</code>为带宽，<code>S/N</code>为信噪比。</p>
<h6 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h6><p>在没有数据传输的时候，信道是很空闲的。但如果网络数据请求量大的时候，信息的传播速度就会下降。信道复用就是重复利用信道的意思，主要分为以下几个方面：</p>
<ul>
<li>时分复用：把整个信道分为不同的时间，所有的用户在不同时间占有同样的频带宽度。时分复用可能造成线路资源的浪费。</li>
<li>频分复用：把信号分为不同的频率，所有用户在同样的时间占有不同的带宽资源。</li>
<li>统计时分复用：也可以称为异步的时分复用系统，它有一个缓冲的机制，当数据量到达一定量时才会转发，提高了信道的利用率。</li>
</ul>
<h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><h6 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h6><p>数据链路层接受来自网络层的 IP 数据报，经过封装使得它能够在数据链路上进行传输。像这样被封装好了的数据报被称为<strong>以太网帧</strong>，或者<strong>MAC帧</strong>，主要由以下几个部分组成：</p>
<p><img src="%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7.png" alt=""></p>
<ul>
<li>目的 MAC 地址：占6个字节，标志目标主机的地址。</li>
<li>源 MAC 地址：占6个字节，标志源主机的地址。</li>
<li>类型：占2个字节，记录上层使用的协议。</li>
<li>数据部分：包含来自上层的 IP 数据报。</li>
<li>FCS：占4个字节，用于检测差错，如果一个 MAC 帧发生了差错，就不能被发送到目标主机上。</li>
</ul>
<h6 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h6><p>现实中通信链路是不理想的，比特在传输中有可能会出现差错，1变为0，0变为1。在一段时间内传输错误的比特占所有比特总数的比率称为<strong>误码率BER（Bit Error Rate）</strong>。误码率与信噪比关系很大，在实际中不可能使得误码率降为0，所以需要各种差错检测措施保证数据传输的可靠性。</p>
<p>MAC 帧在传播过程中就会产生差错，因此我们可以根据差错检测序列 FCS 来判断是否出现了差错。</p>
<p>差错检测主要有两种：<strong>奇偶校验法（PCC）</strong>和<strong>循环冗余校验（CRC）</strong>。奇偶校验法是在每一个传输的字节加上一个奇偶校验位，在传输之前会确定是奇校验还是偶校验，如果传输时发现校验位不符，则认定传输出错。而循环冗余校验法则是一种根据传输或保存的数据而产生的固定位数校验码的方法。生成的数据在传输或者存储之前附加到数据后，然后接收端进行校验判断数据是否发生了差错。</p>
<p>通过循环校验法，就可以计算出 FCS 冗余校验码，FCS 位于 MAC 帧的尾部。通过 FCS，就可以知道 MAC 帧在传输中是否发生了差错。</p>
<h6 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h6><p>适配器在生活中很常见，例如电源适配器，插头适配器等等，起到的作用就是转换。</p>
<p><img src="%E9%80%82%E9%85%8D%E5%99%A8.png" alt=""></p>
<p>数据在外部媒介传输的方式是串行传输，而计算机内部处理指令是并行处理，这中间就用到了适配器。</p>
<h6 id="CAM-表"><a href="#CAM-表" class="headerlink" title="CAM 表"></a>CAM 表</h6><p><strong>交换机</strong>是一种多端口的网桥，在数据链路层使用 MAC 地址转发数据。交换机内部存储这一张表，叫做 CAM 表，记录了主机的 MAC 地址以及对应的接口。</p>
<p><img src="%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" alt=""></p>
<p>一开始有三台主机 A、B、C 与交换机连接。突然 A 想要给 B 发送消息，这时交换机会检查自己内部的 CAM 表是否存储了 A 的信息，如果没有，就会把 A 的信息写进 CAM 表，于是：</p>
<p><img src="%E4%BA%A4%E6%8D%A2%E6%9C%BAA.png" alt=""></p>
<p>这时 CAM 表中已经存储了 A 的信息。但 B 呢？交换机会检查 CAM 表是否有 B 的信息，如果存在，就直接发给 B。反之，交换机会把 A 发送信息给 B 的信息以广播的形式发送给所有与它相连的主机上，收到信息的主机会检查目的地址，如果与自己的地址相同，就会接受这条信息。然后交换机就会更新数据：</p>
<p><img src="%E4%BA%A4%E6%8D%A2%E6%9C%BAB.png" alt=""></p>
<p>这样一来，以后 A 想要给 B 发消息，就不需要广播了。</p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><h6 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h6><p>IP 地址，又称为互联网协议地址。当设备连接网络，将被分配一个 IP 地址用作标识。IP 地址主要有两个功能：</p>
<ol>
<li>标记主机地址，用于识别主机。</li>
<li>因为 IP 地址是唯一的，所以可以在网络上查找主机（寻址）。</li>
</ol>
<p>IP 地址主要有以下几类：</p>
<p><img src="IP%E5%9C%B0%E5%9D%80.png" alt=""></p>
<p>MAC 地址就是一台主机的“身份证”。那么为什么有了 MAC 地址，还要 IP 地址呢？或者有了 IP 地址，为啥还需要 MAC 地址呢？</p>
<p>前面说到交换机会进行广播，这会给所在的网络造成不必要的浪费，不然交换机就需要记录所有的 MAC 地址以及端口。如果规模比较小的话那是比较高效的，但如果规模是世界范围内的，交换机是无法存储那么多条记录的。因为 MAC 地址是<code>48</code>位，意味着一共有2^48个 MAC 地址，即使每条记录只需要1个字节，一共也需要 256 TB 的内存。这时就需要用到 IP 地址了。对于同一个子网内的设备，IP 前缀是一样的。这样交换机只要记住子网的地址就可以了，而不用把所有 MAC 地址都做记录。数据传输到子网下再根据 MAC 地址传输到具体的设备。而只有 IP 地址没有 MAC 地址也是不行的，因为 IP 地址要设备上线之后，根据设备进入了哪个子网才进行分配，在这之前需要 MAC 地址才能区分设备。两者互相协作，负责不同的层面。</p>
<h6 id="IP-数据报"><a href="#IP-数据报" class="headerlink" title="IP 数据报"></a>IP 数据报</h6><p>IP 数据报主要包含以下信息：</p>
<p><img src="IP%E6%95%B0%E6%8D%AE%E6%8A%A5.png" alt=""></p>
<ul>
<li>版本号：占4位二进制，表示该 IP 数据报使用的 IP 协议版本。目前使用的主要是版本号为4的 IP 协议。</li>
<li>头长度：占4位二进制，指出报头的长度，以32位二进制数为一个计数单位，接收端可以根据头长度计算出该从哪里开始读数据。</li>
<li>服务类型：占8位二进制位，规定了数据报的处理方式。</li>
<li>生存时间：占8位二进制位，指定了数据报可以在网络中传输的最长时间。</li>
<li>上层协议标识：占8位二进制位，目标端根据协议标识把收到的 IP 数据报送到 TCP 或 UDP 等处理此报文的上层协议。</li>
</ul>
<h6 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h6><p>常见的 IP 地址是由网络地址和主机地址组成的。网络号就是计算机当前所在网络的名字，相当于一个前缀，在这个网络下有许多的主机。这时子网掩码就派上了用场。</p>
<p>子网掩码前面通常是连续的1，后面部分是连续的0，不会出现0和1交替的情况，例如<code>255.255.0.0</code>，不会出现<code>255.255.1.0</code>的情况。由于这样设计粒度较粗，后面又出现像<code>255.255.252.0</code>这样的子网掩码，相当于有<code>2^6</code>个子网一共享有<code>65536</code>个主机，每个网段平均有<code>1024</code>个主机。</p>
<h6 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h6><p>ARP 协议为<strong>地址解析协议</strong>，主要用于通过目标设备的 IP 地址，查询目标设备的 MAC 地址。就像交换机工作在数据链路层一样，路由器是工作在网络层的。比如主机 A 要给 B 发送一条信息，经过多重转发，找到了 B 的 IP 地址。这时路由器会以广播的形式发送一个 ARP 请求，所有连接到这台路由器的主机都会收到消息，只有 B 的地址是符合要求的，于是就会给路由器发送一个 ARP 相应，并把自己的 MAC 地址告诉路由器，接着就可以通信了。</p>
<h6 id="NAT-协议"><a href="#NAT-协议" class="headerlink" title="NAT 协议"></a>NAT 协议</h6><p>NAT 即<strong>网络地址转换</strong>。当在私有网络的一些主机已经分配到了 IP 地址，又想在公网进行通信时，就可以使用 NAT 技术。简单来说就是使得局域网和互联网通信的一项协议。主要可分为三种类型：</p>
<ol>
<li>静态 NAT：私网的每台主机都被永久映射到外网的某个地址。</li>
<li>动态 NAT：在外网定义了一系列地址，采用动态分配的方法映射到内网。当一个内网主机需要访问外网时，就从公网 IP 地址取出一个可用的，用完了就归还再供其他主机使用。</li>
<li>网络地址端口转换 NAPT：把内部地址映射到外网的一个 IP 地址的不同端口。</li>
</ol>
<h6 id="IPV6-协议"><a href="#IPV6-协议" class="headerlink" title="IPV6 协议"></a>IPV6 协议</h6><p>当前 IPV4 地址已用尽，为了解决这个问题就定义了 IPV6 协议，IPV6 地址的长度为<code>128bit</code>，一般写成8个16位字节，这很明显是用不尽的。但是目前很多地址还是使用的 IPV4，这是因为要切换到 IPV6 是很耗时的，所有主机和路由器的 IP 地址都需要重新配置。目前 IPV4 地址和 IPV6 地址通信主要是通过<strong>双协议栈</strong>和<strong>隧道技术</strong>来解决的。</p>
<p>双协议栈技术是指在同一台设备上同时开启 IPV4 和 IPV6 协议栈，这样这台设备就可以同时和 IPV4 网络和 IPV6 网络通信。</p>
<p>隧道技术指的是数据在传输的时候进行了封装与解封，使得双方可以进行通信。</p>
<p><img src="%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF.png" alt=""></p>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><h6 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h6><p>停止等待协议是数据链路层的一个协议。主机 A 给 B 发了一条信息，但没有收到 B 的答复，这时就会停止向 B 继续发送消息，直到 B 回复。停止等待协议主要由以下三部分组成：</p>
<ol>
<li>无差错情况：为保证无差错情况，主机 A 会一直等待 B 的回复。</li>
<li>出现差错：如果出现了差错，会有一种机制，让 A 重新发一遍消息给 B。这涉及到了一个<strong>重传时间</strong>的问题，重传时间不应小于 A 给 B 发消息，B 再给 A 发消息的时间总和。</li>
<li>确认丢失和确认迟到：</li>
</ol>
<p><img src="%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.png" alt=""></p>
<p>数据在传输中可能出现丢失和迟到这两种情况，对于丢失的数据，重新传输；对于迟到确认的数据，不做额外的处理。</p>
<h6 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h6><p>停止等待协议的发送方需要等待接收方的回复才会继续传输数据，而连续 ARQ 协议的发送方会维持着一个固定大小的发送窗口，分组的数据可以连续发送出去，无需等待接收方的回应，提高了信道的利用率。</p>
<h6 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h6><ul>
<li>面向无连接协议，传输不可靠。</li>
<li>面向数据报。</li>
<li>没有拥塞控制。</li>
<li>支持一对一、一对多、多对多、多对一的数据传输。</li>
</ul>
<h6 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h6><ul>
<li>面向连接的协议，提供可靠交付。</li>
<li>使用全双工通信。</li>
<li>面向字节流。</li>
</ul>
<h6 id="TCP-数据报"><a href="#TCP-数据报" class="headerlink" title="TCP 数据报"></a>TCP 数据报</h6><p><img src="TCP%E6%95%B0%E6%8D%AE%E6%8A%A5.png" alt=""></p>
<ul>
<li>源端口：发送主机的端口号</li>
<li>目的端口：接受主机的端口号</li>
<li>序号：在一次 TCP 连接中传送的字节流中的每一个字节都按顺序编号。字节流的起始序号必须在连接建立时设置。TCP 数据报首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。</li>
<li>确认号：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。</li>
<li>数据偏移：指出 TCP 报文段的数据起始位置距离 TCP 报文段的起始位置的距离。</li>
<li>窗口：指出现在允许对方发送的数据量。</li>
<li>校验和：检验和字段检验的范围包括首部和数据这两部分。</li>
<li>确认 ACK：当 ACK = 1 时确认字段才有效。在连接建立后，所有传送的报文段都需把 ACK 置为1。</li>
<li>推送 PUSH：两个应用程序进行交互式通信时，一端在输入一个命令后希望能够立即收到对方的响应，就把 PSH 置为1，立即创建一个报文段发送出去，接收方尽快交付接受。</li>
<li>复位 RST：当 RST = 1 时，表明 TCP 连接出现了严重差错，需要释放连接重新建立。</li>
<li>SYN：建立连接时同步序号。</li>
<li>FIN：释放连接。</li>
</ul>
<h6 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h6><p>TCP 为了提高数据传输的效率，采用了叫做滑动窗口的机制进行数据发送。</p>
<p><img src="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt=""></p>
<p>一旦发送端收到一个确认，滑动窗口就会向右移动。</p>
<h6 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h6><p>接受端会给发送端发送一个负反馈，控制滑动窗口的大小。</p>
<h6 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h6><ul>
<li>慢启动：一条 TCP 连接刚建立时不应一下发送大量数据导致网络拥塞，而应该从小到大根据反馈逐渐增大拥塞窗口。</li>
<li>快重传：发送端连续三次收到重复确认就应该立即重传而不是等到重传时间到期。</li>
<li>快恢复：当发送方连续收到三个重复确认时，就执行 “乘法减小” 算法，把慢开始门限减半。这是为了预防网络发生拥塞。注意，接下去不执行慢开始算法。执行快恢复算法时，改变滑动窗口的值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢性增大。</li>
</ul>
<h6 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h6><p>三次握手和四次挥手都是针对 TCP 连接的，为的就是尽量达到理想得传输数据。</p>
<p><img src="%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt=""></p>
<ul>
<li>第一次握手：Server 确认了 Client 发送正常，自己接收正常。</li>
<li>第二次握手：Client 确认了自己发送、接收正常，Server 发送、接收正常。</li>
<li>第三次握手：Server 确认了自己发送正常，Client 接收正常。</li>
</ul>
<p><img src="%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%8F%8F%E8%BF%B0.png" alt=""></p>
<h6 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h6><p><img src="%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt=""></p>
<ul>
<li>第一次挥手：Client 向 Server 发送断开连接的请求。</li>
<li>第二次挥手：Server 向 Client 发送断开连接的确认，Client 收到后，TCP 进入半连接状态，Client 向 Server 发送数据的通道被关闭。</li>
<li>第三次挥手：Server 向 Client 发送一个断开连接的请求。</li>
<li>第四次挥手：Client 向 Server 发送断开连接的确认。Server 收到以后，TCP 连接完全断开。</li>
</ul>
<p><img src="%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%8F%8F%E8%BF%B0.png" alt=""></p>
<h6 id="为什么-TCP-连接需要三次握手，断开需要四次挥手？"><a href="#为什么-TCP-连接需要三次握手，断开需要四次挥手？" class="headerlink" title="为什么 TCP 连接需要三次握手，断开需要四次挥手？"></a>为什么 TCP 连接需要三次握手，断开需要四次挥手？</h6><p>TCP 在连接时需要考虑丢包的问题，在第二次握手的时候服务器不能确认自己发送给客户端的确认报文有没有丢失，所以需要客户端再发送一次确认报文。如果第三次握手发生了丢包也没有关系，服务端一段时间内没有收到确认报文就会重新发送确认报文给客户端。</p>
<p>而 TCP 断开连接时，要确认双方都没有数据要发送了才能断开。客户端发出 FIN 报文时只能保证客户端没有数据要发了，服务端还有没有数据要发是不知道的，所以服务端只能先回复一个确认报文通知客户端我已经收到你的 FIN 报文了，然后等到服务端发完自己要发的数据，才能给客户端发送 FIN 报文。然后客户端再告诉服务端我收到了你的 FIN 报文，至此真正断开连接。</p>
<h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><h6 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h6><p>HTTP 是一个客户端和服务端之间请求和应答的标准，通常使用 TCP 协议。</p>
<h6 id="FTP-协议"><a href="#FTP-协议" class="headerlink" title="FTP 协议"></a>FTP 协议</h6><p>FTP（File Transfer Protocol）文件传输协议，在 TCP/IP 协议族中属于应用层协议，运行在 TCP 协议之上。主要用于用户之间文件的分发共享，以及用于网络管理者进行设备版本升级、日志下载、配置保存等等操作。</p>
<h6 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h6><p>DNS 是域名解析协议，用于把域名解析成 IP 地址，方便用户访问。</p>
<h6 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h6><p>局域网的网络协议，用于动态给主机分配 IP 地址与子网掩码。</p>
<hr>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP 是一种<strong>超文本传输协议（Hypertext Transfer Protocol）</strong>。HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</p>
<ul>
<li>超文本：超文本不仅是文本，还可以是图片、音频、视频，甚至点击文字或图片进行超链接的跳转。</li>
<li>传输：数据需要经过一系列物理介质从一端传输到另一端。传输数据包的一方叫做<strong>请求方</strong>，接收到二进制数据包的一方叫做<strong>应答方</strong>。</li>
<li>协议：协议指的是网络中传递、管理信息的一些规范。</li>
</ul>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p><img src="HTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=""></p>
<h4 id="GET、POST"><a href="#GET、POST" class="headerlink" title="GET、POST"></a>GET、POST</h4><ul>
<li><code>GET</code>方法用于从服务器获取资源，这个资源可以是文本、页面、图片、视频等，请求参数拼在 URL 后；而<code>POST</code>方法用于向指定的资源提交数据，数据放在<code>requestBody</code>中。</li>
<li><code>GET</code>请求的 URL 有长度限制，<code>POST</code>没有。</li>
<li><code>GET</code>请求会被浏览器 cache，<code>POST</code>不会。</li>
<li><code>GET</code>请求在发送过程中会产生一个 TCP 数据包；<code>POST</code>会发送两个，浏览器首先发送<code>header</code>，服务器响应<code>100 continue</code>，然后再发送<code>data</code>，服务器响应<code>200 ok</code>并返回数据。</li>
<li><code>GET</code>方法是<strong>幂等</strong>的，<code>POST</code>不是。</li>
</ul>
<h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>无状态协议是指<strong>浏览器对于事务的处理没有记忆能力</strong>，服务器不会保存客户端的连接状态，比如客户端请求了网站，然后重启浏览器进行登录，服务器不会知道客户端关闭了一次浏览器。</p>
<h4 id="HTTP1-0、HTTP1-1、HTTP2-0"><a href="#HTTP1-0、HTTP1-1、HTTP2-0" class="headerlink" title="HTTP1.0、HTTP1.1、HTTP2.0"></a>HTTP1.0、HTTP1.1、HTTP2.0</h4><h5 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h5><ul>
<li>HTTP1.0 仅提供了基本的认证，用户名和密码还未经加密。</li>
<li>HTTP1.0 使用短连接，每次发送数据都要经过三次握手和四次挥手，效率很低。</li>
<li>HTTP1.0 不支持断点续传，每次都会传送全部的页面和数据。</li>
<li>HTTP1.0 认为每台计算机都只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名。</li>
</ul>
<h5 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h5><ul>
<li>HTTP1.1 使用摘要算法进行身份验证。</li>
<li>HTTP1.1 默认使用长连接，只需建立一次连接就可以传输多次数据，完成后一次断开连接即可。长连接的连接时长可以通过请求头中的<code>keep-alive</code>设置。</li>
<li>HTTP1.1 增加了<code>E-tag</code>、<code>If-Unmodified-Since</code>、<code>If-Match</code>、<code>If-None-Match</code>等缓存控制标头来控制缓存失效。</li>
<li>HTTP1.1 支持断点续传，通过使用请求头中的<code>Range</code>来实现。</li>
<li>HTTP1.1 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，共享一个 IP 地址。</li>
</ul>
<h5 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h5><p>HTTP2.0 是 2015 年开发出的标准，主要有以下改变：</p>
<ul>
<li>头部压缩：HTTP1.1 经常会出现<code>User-Agent</code>、<code>Cookie</code>、<code>Accept</code>等字段占用几百甚至几千字节，而<code>Body</code>却只有几十字节。HTTP2.0 使用<code>HPACK</code>算法进行压缩。</li>
<li>二进制格式：HTTP2.0 使用更加靠近<code>TCP/IP</code>的二进制格式，抛弃了<code>ASCII</code>码，提升了解析效率。</li>
<li>安全：安全是重中之重，HTTP2.0 一般都跑在 HTTPS 上。</li>
<li>多路复用：HTTP1.1 中，传输的<code>request</code>和<code>response</code>都是基于文本的，这样会导致所有的数据都需要按顺序传输。如果某个请求被阻塞，将会导致后面排队的所有请求都被阻塞，这就是<strong>队头阻塞</strong>。HTTP2.0 引入了<strong>二进制数据帧</strong>和<strong>流</strong>的概念，帧对数据进行顺序标识，浏览器收到数据可以根据序列对数据进行合并，这样就不用按照顺序传输数据了，也不会有队头阻塞的情况出现；而流做的事就是使得服务器可以并行地传输数据。</li>
</ul>
<h4 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h4><p>HTTP 请求头分为四种：<strong>通用标头</strong>、<strong>实体标头</strong>、<strong>请求标头</strong>、<strong>响应标头</strong>。</p>
<h5 id="通用标头"><a href="#通用标头" class="headerlink" title="通用标头"></a>通用标头</h5><p>主要有三个：<code>Date</code>、<code>Cache-Control</code>、<code>Connection</code>。</p>
<h6 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h6><p><code>Date</code>是一个通用标头，表示格林威治标准时间，比北京慢八个小时。</p>
<h6 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h6><p><code>Cache-Control</code>是一个通用标头，通过指定指令来实现缓存机制。</p>
<h6 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h6><p><code>Connection</code>决定当前事务完成后是否关闭网络连接。如果为<code>keep-alive</code>即不关闭连接。</p>
<p><img src="%E9%80%9A%E7%94%A8%E6%A0%87%E5%A4%B4.png" alt=""></p>
<h5 id="实体标头"><a href="#实体标头" class="headerlink" title="实体标头"></a>实体标头</h5><p>描述消息正文内容的 HTTP 标头，用于请求和响应中。</p>
<ul>
<li><code>Content-Length</code>：实体主体的大小，字节为单位。</li>
<li><code>Content-Language</code>：客户端或者服务端能够接受的语言。</li>
<li><code>Content-encoding</code>：压缩媒体类型。指对实体应用了何种编码。常见的有<code>gzip</code>、<code>compress</code>、<code>deflate</code>、<code>identity</code>。此属性可以应用在请求报文和响应报文中。</li>
</ul>
<p><img src="%E5%AE%9E%E4%BD%93%E6%A0%87%E5%A4%B4.png" alt=""></p>
<h5 id="请求标头"><a href="#请求标头" class="headerlink" title="请求标头"></a>请求标头</h5><h6 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h6><p>指明了服务器的域名，以及服务器监听的 TCP 端口号。如果没有给定端口号会使用被请求服务的默认端口。</p>
<h6 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h6><p>HTTP Referer 是请求标头的一部分，浏览器向服务器发送请求时，一般会带上 Referer，告诉服务器该网页是从哪个页面链接过来的，服务器可以获取一些信息进行处理。</p>
<h6 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h6><p>通常和<code>If-None-Match</code>搭配使用，用于确认代理或者客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段<code>Last-Modified</code>来确定。如果在<code>Last-Modified</code>之后没有更新资源，那么服务器会返回<code>304</code>，否则返回<code>200</code>。</p>
<h6 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h6><p>使请求成为条件请求。对于<code>GET</code>和<code>HEAD</code>方法，仅当服务器没有与给定资源匹配的<code>ETag</code>时，服务器才会以<code>200</code>状态发送回请求的资源。对于其他方法，仅当最终现有资源的<code>ETag</code>与列出的任何值都不匹配时，才会处理请求。</p>
<h6 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h6><p>接受请求 HTTP 标头会通知客户端自身能够理解的<code>MIME</code>类型。</p>
<h6 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h6><p>规定了服务器处理表单数据所能接受的字符集。</p>
<h6 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h6><p>告知服务器用户代理能够处理的自然语言集。</p>
<p><img src="%E8%AF%B7%E6%B1%82%E6%A0%87%E5%A4%B4.png" alt=""></p>
<h5 id="响应标头"><a href="#响应标头" class="headerlink" title="响应标头"></a>响应标头</h5><h6 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h6><p>指定一个来源，告诉浏览器允许该来源进行资源的访问。</p>
<h6 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h6><p>表示<code>Connection</code>非持续连接的存活时间。</p>
<h6 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h6><p>用于服务器相客户端发送<code>sessionID</code>。</p>
<h6 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h6><p>规定了传输报文主体时采用的编码格式。</p>
<h6 id="X-frame-Options"><a href="#X-frame-Options" class="headerlink" title="X-frame-Options"></a>X-frame-Options</h6><p>HTTP 首部字段是可以自行拓展的，所以会出现各种非标准的首部字段。<code>X-frame-Options</code>用于控制网站内容在其他网站的<code>Frame</code>标签内的显示问题。主要是为了防止点击劫持攻击。</p>
<p><img src="%E5%93%8D%E5%BA%94%E6%A0%87%E5%A4%B4.png" alt=""></p>
<h4 id="在地址栏输入-URL-之后都发生了什么"><a href="#在地址栏输入-URL-之后都发生了什么" class="headerlink" title="在地址栏输入 URL 之后都发生了什么"></a>在地址栏输入 URL 之后都发生了什么</h4><p>首先，在地址栏输入<code>www.baidu.com</code>。浏览器会根据输入的地址去查找域名是否有被本地的 DNS 缓存，如果浏览器缓存了想要访问的 URL 地址，那么就直接返回 IP，否则会去本机的<code>hosts</code>文件查询是否有匹配的 IP 地址，如果还没有就会向网络发起<code>DNS</code>查询。</p>
<p><code>DNS</code>全称是<code>Domain Name System</code>，是一种由分层的<code>DNS</code>服务器实现的分布式数据库。<code>DNS</code>运行于<code>UDP</code>上，使用<code>53</code>端口。</p>
<p><img src="DNS%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt=""></p>
<p>获得 IP 地址后，浏览器需要和目标服务器通过三次握手建立 TCP 连接。建立连接后，浏览器会向目标服务器发起<code>HTTP-GET</code>请求，HTTP1.1 后默认使用长连接，只需要一次握手就可以多次传输数据。如果目标服务器只是一个简单的页面，就可以直接返回。但对于大型网站来说，往往会重定向。浏览器获取了重定向的响应后，在响应报文中的<code>Location</code>找到重定向的地址，浏览器重新进行访问，返回<code>200</code>状态码，表示服务器可以响应请求，返回报文。</p>
<hr>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS 全称为<code>Hypertext Transfer Protocol Secure</code>，是 HTTP + TLS/SSL 协议组合而成的，其默认端口为<code>443</code>。</p>
<h4 id="为什么需要-HTTPS"><a href="#为什么需要-HTTPS" class="headerlink" title="为什么需要 HTTPS"></a>为什么需要 HTTPS</h4><p>HTTP 有一个致命的缺陷，那就是内容都是<strong>明文</strong>传输的，没有任何加密。这些明文数据在传输的过程中会经过 WiFi、路由器、运营机房等等物理设备节点，如果被监听了，传输的内容就会完全暴露。这叫做<code>MITM(Man In The Middle)</code><strong>中间人</strong>攻击。</p>
<p>为了解决明文传输的安全性问题，就有了 HTTPS，通信协议仍然是 HTTP，但是利用了<code>SSL/TLS</code>加密数据包。</p>
<p><code>SSL(Secure Sockets Layer)</code>安全套接层和<code>TLS(Transport Layer Security)</code>传输层安全协议其实是一套东西。</p>
<h4 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h4><ol>
<li>用户发起一个 HTTPS 请求时，默认使用的端口是<code>443</code>。</li>
<li>HTTPS 需要一套<strong>CA数字证书</strong>，证书内携带一个<strong>公钥</strong>，与之对应的是<strong>私钥</strong>，私钥储存在服务器不公开。</li>
<li>服务器收到请求，返回包含公钥的证书给客户端。</li>
<li>客户端收到证书，校验其合法性，主要包含是否处于有效期内、证书的域名与请求的域名是否匹配、上级证书是否有效（递归，直到根证书），如果不通过，会显示 HTTPS 警告信息，通过的话继续。</li>
<li>客户端生成一个用于对称加密的随机 Key，用证书内的公钥进行加密，发给服务端。</li>
<li>服务端收到随机 Key 的密文，使用与公钥配对的私钥进行解密，得到客户端真正想发送的随机 Key。</li>
<li>服务端使用客户端发过来的随机 Key 对要传输的 HTTP 数据进行对称加密，将密文返回给客户端。</li>
<li>客户端使用随机 Key 对称解密密文，得到 HTTP 数据明文。</li>
<li>之后 HTTPS 请求都使用之前交换好的随机 Key 进行对称加解密。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2020/12/31/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>Java 泛型</p>
<a id="more"></a>

<h3 id="何为泛型，为什么要使用泛型？"><a href="#何为泛型，为什么要使用泛型？" class="headerlink" title="何为泛型，为什么要使用泛型？"></a>何为泛型，为什么要使用泛型？</h3><p>泛型，即为<strong>参数化类型</strong>，就是将类型由原来的具体的类型参数化，此时类型也定义成参数形式，在调用时传入具体的类型。泛型的使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口和泛型方法。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>泛型只在编译阶段有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; b = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; aClass = a.getClass();</span><br><span class="line">        Class&lt;?&gt; bClass = b.getClass();</span><br><span class="line">        System.out.println(aClass.equals(bClass));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果打印<code>true</code>。说明程序在编译之后会进行<strong>泛型擦除</strong>。也就是说泛型只在编译阶段有效，在检验泛型类型正确后就会将泛型的相关信息擦除，泛型不会进入运行阶段。因此<code>aClass</code>和<code>bClass</code>都是<code>class java.util.ArrayList</code>。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T可以写成任何标识，在实例化此类时需要指定T的具体类型。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 泛型的类型参数只能是类类型，传入的实参类型要和泛型的类型参数类型相同。</span></span><br><span class="line">        Test&lt;Integer&gt; test = <span class="keyword">new</span> Test&lt;&gt;(<span class="number">123</span>);</span><br><span class="line">        System.out.println(test.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>泛型接口和泛型类的定义和使用基本一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未传入泛型实参时，在声明类的时候，要将泛型的声明一起加到类中。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impl1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ITest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了泛型接口时，如已将泛型类型传入实参类型，那么所有使用泛型的地方都要传入实参类型。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impl2</span> <span class="keyword">implements</span> <span class="title">ITest</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Test&lt;Number&gt; o)</span> </span>&#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test&lt;Integer&gt; test = <span class="keyword">new</span> Test&lt;&gt;(<span class="number">123</span>);</span><br><span class="line">        show(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序不能通过编译。<code>Integer</code>是<code>Number</code>的一个子类，但是作为泛型却不能将<code>Test&lt;Integer&gt;</code>作为<code>Test&lt;Number&gt;</code>的子类。这说明了不同版本的泛型类实例是不兼容的。</p>
<p>为了解决这个问题，我们需要用一种方法表示同时是<code>Test&lt;Integer&gt;</code>和<code>Test&lt;Number&gt;</code>父类的引用类型，也就是使用泛型通配符。</p>
<p>类型通配符一般使用<code>?</code>代替具体的类型实参，例如<code>Test&lt;?&gt;</code>代替<code>Test&lt;Number&gt;</code>。</p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>泛型方法是在调用方法的时候指明泛型的具体类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public 与返回值之间的 &lt;T&gt; 声明了此方法为泛型方法，如果只是在方法中使用了泛型并不是泛型方法。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Test().get(<span class="string">"123"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(T... t)</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test().get(<span class="string">"123"</span>, <span class="number">456</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>静态方法无法访问类定义的泛型，如果静态方法要使用泛型，需要将静态方法也定义为泛型方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 编译不通过，即使在类中已经声明了这个泛型。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(T... t)</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要定义为泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(T... t)</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上下界"><a href="#上下界" class="headerlink" title="上下界"></a>上下界</h4><h5 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h5><p><code>&lt;? extends XXX&gt;</code>限制了上界，它有副作用，就是不能往里存东西。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        item = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        item = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test&lt;? extends Number&gt; test = <span class="keyword">new</span> Test&lt;&gt;(<span class="number">123</span>);</span><br><span class="line">        test.set(<span class="number">456</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>test.set(123)</code>不能通过编译。原因是编译器只知道参数是<code>Number</code>的子类，但具体是哪个并不知道。编译器看到后面用<code>123</code>赋值，只是标记一个占位符<code>capture#1</code>，表示捕获了一个<code>Number</code>或<code>Number</code>的子类。后面想<code>set</code>值，编译器不能判断能不能和之前的占位符匹配，所以不被允许。</p>
<h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><p><code>&lt;? super XXX&gt;</code>限制了下界，导致元素没有统一的“根”（除了<code>Object</code>这个大家统一的的根），所以读取元素的时候只能用<code>Object</code>类接收，除非强转。而往里存元素是可行的，限制是只能存<code>XXX</code>的子类，因为这样数据可以自动转型，不然只能强转。</p>
<h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><p>在 Java 中<strong>不能创建一个确切的泛型类型的数组</strong>。</p>
<p><code>List&lt;String&gt;[] list = new ArrayList&lt;String&gt;[5];</code>这样的定义是无法通过编译的。而利用通配符创建泛型数组是可行的。</p>
<p><code>List&lt;?&gt;[] list = new ArrayList&lt;?&gt;[5];</code></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis笔记</title>
    <url>/2021/01/02/MyBatis%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>MyBatis 学习笔记</p>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>MyBatis 是一款持久化框架，一个<strong>半 ORM</strong> 框架，支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或者注解来配置和映射原生类型、接口和 Java 的 POJO 为数据库所记录。</p>
<h4 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h4><p>ORM（Object Relational Mapping），对象关系映射，通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p>
<h4 id="半自动-ORM-映射"><a href="#半自动-ORM-映射" class="headerlink" title="半自动 ORM 映射"></a>半自动 ORM 映射</h4><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或关联集合对象时，可以根据对象关系模型直接获取，所以是全自动的。MyBatis 则需要手动编写 SQL，因此是半自动的。</p>
<h4 id="传统-JDBC-开发的问题"><a href="#传统-JDBC-开发的问题" class="headerlink" title="传统 JDBC 开发的问题"></a>传统 JDBC 开发的问题</h4><ul>
<li>频繁创建、释放数据库连接对象，很浪费系统资源，影响性能。如果使用连接池可以解决这个问题，但是使用 JDBC 需要自己实现连接池。</li>
<li>SQL 语句定义、参数设置、结果集的处理存在硬编码。实际项目中 SQL 语句变化的可能性较大，如果发生变化就要修改代码，系统要重新编译、发布，不易维护。</li>
<li>使用 preparedStatement 向占有位符号传参存在硬编码，SQL 语句的<code>WHERE</code>条件不是一定的，修改 SQL 语句还要修改 Java 代码，因此不易维护。</li>
<li>结果集的处理十分麻烦，如果映射为 Java 对象会比较好处理。</li>
</ul>
<h4 id="MyBatis如何解决这些问题"><a href="#MyBatis如何解决这些问题" class="headerlink" title="MyBatis如何解决这些问题"></a>MyBatis如何解决这些问题</h4><ul>
<li>使用数据库连接池可以解决频繁创建、释放数据库连接的问题，在 MyBatis 中可以通过<code>mybatis-config.xml</code>配置连接池，很方便。</li>
<li>SQL 语句写在代码中不易维护，在 MyBatis 中将 SQL 语句写在<code>XXXMapper.xml</code> 中与 Java 代码分离易于维护。</li>
<li>SQL 语句传参麻烦，因为条件不一定，使用 MyBatis 可以自动将 Java 对象映射到 SQL 语句。</li>
<li>结果集的处理很麻烦，使用 MyBatis 可以自动将 SQL 语句执行的结果映射到 Java 对象方便后续的处理。</li>
</ul>
<h4 id="MyBatis-优点"><a href="#MyBatis-优点" class="headerlink" title="MyBatis 优点"></a>MyBatis 优点</h4><ul>
<li>基于 SQL 语句编程，将 SQL 写在<code>xml</code>文件中，与程序代码解耦，方便维护管理。还支持动态 SQL 语句，很灵活。</li>
<li>不用手动编写开关数据库连接等等冗余的代码，专注于 SQL 的编写。</li>
<li>和 Spring 框架有很好的集成。</li>
<li>支持数据库和对象的映射。</li>
<li>与很多数据库都兼容（只要 JDBC 支持的数据库 MyBatis 都支持）。</li>
</ul>
<h4 id="MyBatis-缺点"><a href="#MyBatis-缺点" class="headerlink" title="MyBatis 缺点"></a>MyBatis 缺点</h4><ul>
<li>SQL 语句需要自己编写，工作量可能比较大。</li>
<li>SQL 语句依赖数据库，导致数据库移植性比较差。</li>
</ul>
<h4 id="Hibernate-和-MyBatis-区别"><a href="#Hibernate-和-MyBatis-区别" class="headerlink" title="Hibernate 和 MyBatis 区别"></a>Hibernate 和 MyBatis 区别</h4><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><p>都是对 JDBC 的封装，都是持久化框架，都是对 dao 层的开发。</p>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><ul>
<li>MyBatis 是一个半自动 ORM 框架，配置 Java 对象和 SQL 语句执行结果的对应关系，多表关联关系配置简单；Hibernate 是一个全自动 ORM 框架，配置 Java 对象和数据库表的对应关系，多表关联关系配置复杂。</li>
<li>Hibernate 对 SQL 语句封装，提供了日志、缓存、级联等特性，还提供了 HQL 操作数据库，数据库无关性较好；MyBatis 需要手动编写 SQL，支持动态 SQL、存储过程，不支持数据库无关性。</li>
</ul>
<hr>
<h3 id="解析和运行原理"><a href="#解析和运行原理" class="headerlink" title="解析和运行原理"></a>解析和运行原理</h3><h4 id="编程步骤"><a href="#编程步骤" class="headerlink" title="编程步骤"></a>编程步骤</h4><ol>
<li>创建<code>SqlSessionFactory</code></li>
<li>通过<code>SqlSessionFactory</code>创建<code>SqlSession</code></li>
<li>通过<code>SqlSession</code>执行数据库操作</li>
<li>调用<code>session.commit()</code>提交事务</li>
<li>调用<code>session.close()</code>关闭会话</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt=""></p>
<ol>
<li>读取 MyBatis 配置文件：<code>mybatis.config.xml</code>为全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</li>
<li>加载映射文件。该文件配置了操作数据库的 SQL 语句。<code>mybatis-config.xml</code>文件会加载该配置文件，可以加载多个映射文件，每个文件对应数据库中的一张表。</li>
<li>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂。</li>
<li>创建会话：通过会话工厂创建会话，包含了所有执行 SQL 语句的方法。</li>
<li>Executor 执行器：MyBatis 维护了一个 Executor 接口来操作数据库，根据会话对象传递的参数动态生成需要执行的 SQL 语句，同时负责查询缓存的维护。</li>
<li>MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</li>
<li>输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</li>
<li>输出结果映射：输出结果类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</li>
</ol>
<h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，这样 DBMS 执行 SQL 时，就不需要重新编译。</p>
<h5 id="为什么要预编译"><a href="#为什么要预编译" class="headerlink" title="为什么要预编译"></a>为什么要预编译</h5><p>JDBC 中使用 preparedStatement 来预编译语句，可以优化 SQL 的执行。预编译之后的 SQL 可以直接执行并且重复利用，DBMS 不需要再次编译。预编译还可以防止 SQL 注入，提高了安全性。</p>
<h4 id="Executor-执行器"><a href="#Executor-执行器" class="headerlink" title="Executor 执行器"></a>Executor 执行器</h4><p>MyBatis 有三种 Executor 执行器。</p>
<ol>
<li><code>SimpleExecutor</code>：每执行一次<code>update</code>或<code>select</code>，就开启一个<code>Statement</code>对象，用完立刻关闭该对象。</li>
<li><code>ReuseExecutor</code>：执行<code>update</code>或<code>select</code>，以 SQL 作为 key 查找<code>Statement</code>对象，存在就直接使用，否则创建，用完之后不关闭对象，而是放置于<code>Map&lt;String, Statement&gt;</code>中，以供后续重复使用。</li>
<li><code>BatchExecutor</code>：执行<code>update</code>，将所有 SQL 添加到批处理中，等待统一执行，它缓存了多个<code>statement</code>对象。</li>
</ol>
<p>在 MyBatis 配置文件中，在设置（settings）可以指定默认的 ExecutorType（执行器类型）。</p>
<h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>MyBatis 支持<code>association</code>关联对象和<code>collection</code>关联集合对象的延迟加载。<code>association</code>指的是一对一，<code>collection</code>指的是一对多。在 MyBatis 配置文件中，可以配置是否启用延迟加载。</p>
<p>延迟加载的原理是使用<code>cglib</code>创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用<code>a.getB().getName()</code>，拦截器<code>invoke()</code>方法发现<code>a.getB()</code>是<code>null</code>值，就会单独发送事先保存好的查询关联 B 对象的 SQL，把 B 查询上来，然后调用<code>a.setB(b)</code>，于是 a 的对象 b 属性就有值了，接着完成<code>a.getB().getName()</code>方法的调用。这就是延迟加载的原理。</p>
<hr>
<h3 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h3><h4 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{} 和 ${} 的区别"></a>#{} 和 ${} 的区别</h4><ul>
<li><code>#{}</code>是占位符，会进行预编译处理；<code>${}</code>是拼接符，没有预编译处理，直接替换字符串。</li>
<li>MyBatis 处理<code>#{}</code>时，会将 SQL 中的<code>#{}</code>替换为<code>?</code>，调用<code>preparedStatement</code>的<code>set</code>方法来赋值。</li>
<li>MyBatis 处理<code>${}</code>时，直接传入原值，相当于 JDBC 中的<code>statement</code>编译。</li>
<li>变量替换之后，<code>#{}</code>对应的变量自动加上单引号，<code>${}</code>对应的变量不会加单引号。</li>
<li><code>#{}</code>可以防止 SQL 注入，<code>${}</code>不行。</li>
<li><code>#{}</code>的变量替换是在 DBMS 中，<code>${}</code>的变量替换是在 DBMS 外。</li>
</ul>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><ul>
<li><p><code>&#39;%${question}%&#39;</code>会引起 SQL 注入。</p>
</li>
<li><p><code>&quot;%&quot;#{question}&quot;%&quot;</code>。<code>#{}</code>解析成 SQL 语句时，会在变量外侧自动添加单引号，所以<code>%</code>要使用双引号。</p>
</li>
<li><p><code>CONCAT(&#39;%&#39;, #{question}, &#39;%&#39;)</code>。推荐使用。</p>
</li>
<li><p><code>bind</code>标签</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUsersLikeUsername"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">  　<span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"'%' + username + '%'"</span>/&gt;</span></span><br><span class="line">  　SELECT * FROM user WHERE username LIKE #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="获取主键"><a href="#获取主键" class="headerlink" title="获取主键"></a>获取主键</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    INSERT INTO user(username, password) VALUES(#&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="dao-接口"><a href="#dao-接口" class="headerlink" title="dao 接口"></a>dao 接口</h4><p>dao 接口的工作原理是<strong>JDK 动态代理</strong>，MyBatis 运行的时候会使用 JDK 动态代理为 dao 接口生成代理对象，代理对象会拦截接口方法，转而执行 MappedStatement 代表的 SQL，然后返回结果。</p>
<h4 id="MyBatis-如何封装-SQL-运行结果为目标对象"><a href="#MyBatis-如何封装-SQL-运行结果为目标对象" class="headerlink" title="MyBatis 如何封装 SQL 运行结果为目标对象"></a>MyBatis 如何封装 SQL 运行结果为目标对象</h4><ul>
<li>使用<code>&lt;resultMap&gt;</code>标签，逐一定义列名和对象属性名之间的映射关系。</li>
<li>使用别名，例如<code>SELECT t_name AS name</code>。列名不区分大小写。</li>
</ul>
<p>有了映射关系后，Mybatis 会利用反射创建对象，给属性逐一赋值然后返回。</p>
<h4 id="A-标签引用（include）了-B-标签的内容，B-标签能否写在-A-后面？"><a href="#A-标签引用（include）了-B-标签的内容，B-标签能否写在-A-后面？" class="headerlink" title="A 标签引用（include）了 B 标签的内容，B 标签能否写在 A 后面？"></a>A 标签引用（include）了 B 标签的内容，B 标签能否写在 A 后面？</h4><p>B 标签可以定义在任何地方。MyBatis 按顺序先解析了 xml 文件的 A 标签，A 引用了 B，但 B 还没解析到，所以会被 MyBatis 标记为尚未解析状态，然后继续解析，解析到了 B 标签。解析完成后，Mybatis 会重新解析被标记为尚未解析的标签，这时 B 标签已被解析，A 也可以顺利被解析。</p>
<hr>
<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="MyBatis-是否可以映射枚举类？"><a href="#MyBatis-是否可以映射枚举类？" class="headerlink" title="MyBatis 是否可以映射枚举类？"></a>MyBatis 是否可以映射枚举类？</h4><p>MyBatis 可以通过自定义<code>TypeHandler</code>并实现<code>TypeHandler</code>接口的<code>setParameter()</code>和<code>getResult()</code>方法映射任何对象到表的一列上。</p>
<p><code>TypeHandler</code>可以完成从<code>JavaType</code>至<code>jdbcType</code>的转换，也可以完成<code>jdbcType</code>到<code>JavaType</code>的转换。</p>
<hr>
<h3 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h3><p>MyBatis 有9种动态 SQL 标签</p>
<ul>
<li>trim</li>
<li>where</li>
<li>set</li>
<li>foreach</li>
<li>if</li>
<li>choose</li>
<li>when</li>
<li>otherwise</li>
<li>bind</li>
</ul>
<p>MyBatis 使用<code>OGNL</code>从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL。</p>
<hr>
<h3 id="MyBatis-插件运行原理"><a href="#MyBatis-插件运行原理" class="headerlink" title="MyBatis 插件运行原理"></a>MyBatis 插件运行原理</h3><p>MyBatis 仅可以编写针对<code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code>接口的插件。MyBatis 使用<strong>JDK 动态代理</strong>，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体是<code>InvocationHandler</code>的<code>invoke()</code>方法，拦截指定配置的需要拦截的方法。</p>
<p>实现 MyBatis 的<code>interceptor</code>接口并且复写<code>intercept()</code>方法，然后给插件写注解，指定拦截哪个接口的哪些方法，最后在配置文件配置编写的插件。</p>
<hr>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p>MyBatis 的一级缓存是基于<code>PerpetualCache</code>的<code>HashMap</code>本地缓存，存储作用域为<code>session</code>。当<code>session</code>执行了<code>flush</code>或者<code>close</code>之后，会将该<code>session</code>的所有<code>cache</code>清空。默认情况下是打开一级缓存的。</p>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>二级缓存默认也是采用<code>PerpetualCache</code>，<code>HashMap</code>存储。不同的是存储作用域不同，是<code>Mapper</code>。还可以自定义存储源，例如<code>Redis</code>、<code>Ehcache</code>。默认情况下不开启二级缓存。如果要开启需要实现<code>Serializable</code>序列化接口，在<code>MyBatis</code>配置文件中添加<code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;</code>，并在配置文件中配置<code>&lt;cache/&gt;</code>。</p>
<h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>当缓存相应的作用域执行了增删改之后，该作用域下所有的<code>SELECT</code>中的缓存都会失效。</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ笔记</title>
    <url>/2021/01/05/RabbitMQ%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>RabbitMQ 笔记</p>
<a id="more"></a>

<h3 id="什么是-MQ？"><a href="#什么是-MQ？" class="headerlink" title="什么是 MQ？"></a>什么是 MQ？</h3><p>消息队列（Message Queue），本质是一个队列，满足<strong>先进先出</strong>的原则，队列中存放的是<code>message</code>。主要用于不同进程或线程之间的通信。</p>
<p>为什么会诞生消息队列？</p>
<ul>
<li>不同进程之间传递消息时，两个进程之间的耦合度很高，为了解耦，在两进程之间抽出一层，两个进程之间所有传递的消息，都必须通过消息队列来传递。</li>
<li>不同进程之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，如果某一个进程接收的消息太多，无法短时间内处理完，而且又有先后顺序的要求，就必须对接收的消息进行排队。</li>
</ul>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ 是一个开源的，基于<code>AMQP</code>协议的，可复用的的企业消息系统。开发语言为<code>Erlang</code>，它是一门面向并发的编程语言。</p>
<p><code>AMQP</code>是一个提供统一消息服务的<strong>应用层</strong>标准高级消息队列协议。基于此协议的客户端与消息中间件可传递消息，不受客户端/中间件不同产品，不同开发语言等条件的限制。</p>
<h3 id="五种队列"><a href="#五种队列" class="headerlink" title="五种队列"></a>五种队列</h3><h4 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h4><p><img src="%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97.png" alt=""></p>
<p><code>P</code>是生产者，<code>C</code>是消费者。中间的盒子是队列（一个消息缓冲区），RabbitMQ 用它来代表消费者。生产者发送一个<code>hello</code>的消息到队列，消费者从消息队列接收了消息。</p>
<h5 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h5><p>首先导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>获取<code>rabbitMQ</code>连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        System.out.println(<span class="string">"connection: "</span> + connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先写一个消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"q_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        <span class="comment">// 监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞队列（LinkedBlockingQueue）</span></span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">"Consumer received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"q_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"Producer sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        <span class="comment">// 关闭通道以及连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行生产者，向队列发送<code>Hello World!</code>消息，消费者可以接收到这条消息。</p>
<h4 id="Work-模式"><a href="#Work-模式" class="headerlink" title="Work 模式"></a>Work 模式</h4><p><img src="Work%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>一个生产者，两个消费者，而一条消息只能被一个消费者获取。</p>
<h5 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h5><p>定义两个消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"q_test_work"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">"Consumer1 received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"q_test_work"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">"Consumer2 received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个消费者<code>sleep</code>时间不同。</p>
<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"q_test_work"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"你好: "</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"Producer sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(i * <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者发送了100条消息。运行结果是</p>
<ol>
<li>两个消费者收到的消息不同。</li>
<li>两个消费者收到的消息个数相同，一个消费奇数号消息，一个消费偶数号。</li>
</ol>
<p>但这其实不是我们想要的。因为消费者1线程休眠的时间短，应该消费者1消费的消息更多才对。之所以消费的数量一致是因为<code>RabbitMQ</code>默认将消息按顺序发给下一个消费者，也就是<strong>轮询</strong>分发消息。所以两个消费者消费的数量一致。</p>
<p>那么如何按照消费者的能力分发消息呢？利用<code>Qos</code>和<code>Acknowledge</code>就可以做到。</p>
<ul>
<li><code>basicQos</code>方法设置了当前<code>channel</code>最大预获取消息的数量。消息从队列异步推送给消费者，消费者的<code>ACK</code>也是异步发送给队列的。从队列的视角来看，总是有一批消息已经推送出去但是还没获得<code>ACK</code>确认，<code>basicQos</code>就是用来限制未确认消息的数量的。如果设为1，队列只有在收到消费者的<code>ACK</code>确认之后才会向该消费者继续发送消息。默认是为0的，也就是说没有限制，队列收到的消息会尽快发送给消费者。</li>
<li>轮询分发：默认情况下，<code>RabbitMQ</code>会逐个发送消息到队列的下一个消费者，这样每个消费者平均下来会获得同等数量的消息。</li>
<li>公平分发：轮询分发存在一个问题，比如：现在有两个消费者，奇数的消息都是繁忙的，偶数则是空闲的。如果按照轮询的方式分发，奇数的消息推送给消费者1，一直处于繁忙的状态；而偶数的消息推送给消费者2，消费者2很快的完成了任务并且一直处于空闲的状态。然而在轮询分发的模式下<code>RabbitMQ</code>对这一切是不知情的。所以可以设置<code>basicQos(prefetchCount = 1)</code>来限制<code>RabbitMQ</code>只发送不超过一条消息给同一个消费者，等到消费者反馈完毕才会继续发送。如果使用了这种模式，需要关闭自动应答，因为自动应答模式下<code>RabbitMQ</code>将消息发送给消费者后就会把消息从内存中删除，如果消费者被杀死或者崩溃了，这条消息也就丢失了。改为手动应答的话，<code>RabbitMQ</code>会等到自己收到消费者的反馈后再将消息从内存中删除，如果<code>RabbitMQ</code>没有收到反馈，会重新分发这条消息给别的消费者。这可以通过<code>channel.basicConsume(QUEUE_NAME, autoAck, consumer)</code>来设置，<code>autoAck</code>为<code>false</code>代表手动应答。</li>
</ul>
<h5 id="公平分发"><a href="#公平分发" class="headerlink" title="公平分发"></a>公平分发</h5><p>修改消费者1代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"q_test_work"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 最大预获取消息数量改为1</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        <span class="comment">// autoAck改为false</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">"Consumer1 received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 使用手动确认模式</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者2同理，生产者不变。</p>
<p>运行发现消费者1消费了更多的消息，符合预期。</p>
<h4 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h4><p><img src="%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>一个生产者，多个消费者。每个消费者都有自己的队列。生产者将消息发送到<strong>交换机</strong>，每个队列都会绑定到交换机。生产者发送的消息，会经过交换机到达队列，实现一条消息被多个消费者获取的目的，但是最终只有一个消费者可以消费这条消息。</p>
<h5 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h5><p>生产者，向交换机发送消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"exchange_fanout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"Producer sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果消息发送到没有队列绑定的交换机的话，消息将会丢失，因为交换机并没有存储消息的功能。</p>
<p>消费者1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_fanout"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"q_test_work1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">"Consumer1 received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者2同理，只需要给<code>QUEUE_NAME</code>换个名字即可。</p>
<p>运行结果：两个消费者都收到了消息，只有一个消费者消费了消息。可以查看交换机和队列的绑定关系。</p>
<p><img src="%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E9%98%9F%E5%88%97%E7%BB%91%E5%AE%9A%E5%85%B3%E7%B3%BB.png" alt=""></p>
<h4 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h4><p><img src="%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>订阅模式可以使得一条消息广播给多个消费者。而路由模式可以使得队列绑定交换机消息的子集。比如，消费者1的队列只绑定<code>UPDATE</code>相关的消息，消费者2只绑定<code>INSERT</code>相关的消息。这需要我们在绑定的时候加上一个<code>routing_key</code>参数。</p>
<h5 id="实战-3"><a href="#实战-3" class="headerlink" title="实战"></a>实战</h5><p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 路由模式</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        <span class="comment">// 指定key为INSERT</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">"INSERT"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"Producer sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"q_test_direct1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 绑定到交换机，key为UPDATE</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"UPDATE"</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">"Consumer1 received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者2将<code>QUEUE_NAME</code>改成<code>q_test_direct2</code>，绑定的<code>key</code>改为<code>INSERT</code>。这样一来，生产者发送给交换机的<code>Hello World!</code>只会被广播到消费者2队列中。如果将消费者1的绑定<code>key</code>多加一个<code>INSERT</code>，那么再次发送消息两个队列都可以收到。</p>
<h4 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h4><p>主题模式又称通配符模式，将路由键和某模式进行匹配，队列需要绑定到一个模式上。<code>#</code>匹配一个或多个词，<code>*</code>匹配一个词。</p>
<p><img src="%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>一条消息可以被多个消费者获取，但同样只有一个消费者最终会消费这条消息。</p>
<h5 id="实战-4"><a href="#实战-4" class="headerlink" title="实战"></a>实战</h5><p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 主题模式</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        <span class="comment">// routing_key为key.1.2</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">"key.1.2"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"Producer sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_topic"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"q_test_topic1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"key.*"</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">"Consumer1 received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_topic"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"q_test_topic2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"key.#"</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">"Consumer2 received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，结果消息只有消费者2能接收到。因为<code>key.*</code>只能匹配一个词，无法匹配<code>key.1.2</code>。</p>
<hr>
<h3 id="Springboot-集成-RabbitMQ"><a href="#Springboot-集成-RabbitMQ" class="headerlink" title="Springboot 集成 RabbitMQ"></a>Springboot 集成 RabbitMQ</h3><h4 id="简单队列-1"><a href="#简单队列-1" class="headerlink" title="简单队列"></a>简单队列</h4><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置<code>application.properties</code>文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">springboot-rabbitmq</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br></pre></td></tr></table></figure>

<p>配置<code>RabbitMQ</code>队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"q_hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRabbitTemplate</span><span class="params">(AmqpTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String date = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        String message = <span class="string">"Hello "</span> + date;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"q_hello"</span>, message);</span><br><span class="line">        System.out.println(<span class="string">"Producer sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"q_hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Consumer received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RabbitmqdemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sender sender;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSender</span><span class="params">(Sender sender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sender = sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Producer sent 'Hello 2021-01-07 16:48:54'</span><br><span class="line">Consumer received 'Hello 2021-01-07 16:48:54'</span><br></pre></td></tr></table></figure>

<h4 id="Work-模式-1"><a href="#Work-模式-1" class="headerlink" title="Work 模式"></a>Work 模式</h4><p>注册两个消费者既可。</p>
<h4 id="订阅模式-1"><a href="#订阅模式-1" class="headerlink" title="订阅模式"></a>订阅模式</h4><p>一个生产者，两个消费者。</p>
<p>首先配置队列，绑定到交换机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">qA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"q_fanout_a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">qB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"q_fanout_b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanoutExchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeA</span><span class="params">(Queue qA, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(qA).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeB</span><span class="params">(Queue qB, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(qB).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRabbitTemplate</span><span class="params">(AmqpTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String message = <span class="string">"Hello fanout "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"fanoutExchange"</span>, <span class="string">""</span>, message);</span><br><span class="line">        System.out.println(<span class="string">"Producer sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"q_fanout_a"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConsumerA received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"q_fanout_b"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConsumerB received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RabbitmqdemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sender sender;</span><br><span class="line">    <span class="keyword">private</span> Recv1 recv1;</span><br><span class="line">    <span class="keyword">private</span> Recv2 recv2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSender</span><span class="params">(Sender sender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sender = sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRecv1</span><span class="params">(Recv1 recv1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.recv1 = recv1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRecv2</span><span class="params">(Recv2 recv2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.recv2 = recv2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Producer sent 'Hello fanout 2021-01-07 20:27:50'</span><br><span class="line"></span><br><span class="line">ConsumerB received 'Hello fanout 2021-01-07 20:27:50'</span><br><span class="line">ConsumerA received 'Hello fanout 2021-01-07 20:27:50'</span><br></pre></td></tr></table></figure>

<p>两个消费者都收到了消息。</p>
<h4 id="路由模式-1"><a href="#路由模式-1" class="headerlink" title="路由模式"></a>路由模式</h4><p>路由模式和订阅模式很像，只要加上<code>routing_key</code>即可。</p>
<p>配置队列，绑定交换机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">qA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"q_direct_a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">qB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"q_direct_b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">directExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"directExchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeA</span><span class="params">(Queue qA, DirectExchange directExchange)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加上routing_key</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(qA).to(directExchange).with(<span class="string">"INSERT"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeB</span><span class="params">(Queue qB, DirectExchange directExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(qB).to(directExchange).with(<span class="string">"UPDATE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"q_direct_a"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConsumerA received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"q_direct_b"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConsumerB received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码不变。最后运行的结果只有消费者1收到了消息。</p>
<h4 id="主题模式-1"><a href="#主题模式-1" class="headerlink" title="主题模式"></a>主题模式</h4><p>主题模式和路由模式很像，只是改成了通配符进行匹配。</p>
<hr>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p><code>RPC(Remote Procedure Call Protocol)</code>远程过程调用协议，意思就是允许一台计算机程序远程调用另一台计算机的程序，而不需要关心底层的网络通信。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在一个大型的项目中，系统往往是由很多个微服务组成的，由不同的团队进行维护，且部署在不同的服务器上。这时不同的服务之间往往会互相调用方法，由于服务部署在不同的服务器上，通信的效率就很关键了。<code>RPC</code>的效率要高于<code>HTTP</code>。</p>
<h4 id="RabbitMQ-实现-RPC"><a href="#RabbitMQ-实现-RPC" class="headerlink" title="RabbitMQ 实现 RPC"></a>RabbitMQ 实现 RPC</h4><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p><img src="RPC.png" alt=""></p>
<ul>
<li>生产者（客户端）：发送一条带有消息ID（<code>correlationId</code>）和回调队列名称的消息到队列。</li>
<li>消费者（服务端）：从队列获取消息处理业务，解析消息ID和回调的队列将业务处理的结果发送给回调的队列。</li>
<li>生产者（客户端）：从回调队列中检查相关的信息（<code>correlationId</code>是否和<code>request</code>中匹配），如果匹配上了就获取消息的返回结果。</li>
</ul>
<p>利用<code>RPC</code>可以运行远程计算机上的方法并且获取结果。</p>
<h4 id="Springboot-集成-RabbitMQ-的-RPC-功能"><a href="#Springboot-集成-RabbitMQ-的-RPC-功能" class="headerlink" title="Springboot 集成 RabbitMQ 的 RPC 功能"></a>Springboot 集成 RabbitMQ 的 RPC 功能</h4><p>采用路由模式。首先配置队列，绑定到交换机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">rpcQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"q_rpc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">directExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"rpcExchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">rpcBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(rpcQueue()).to(directExchange()).with(<span class="string">"add"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRabbitTemplate</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 确认了消费者接收到了消息才会发送下一条</span></span><br><span class="line">            Object response = <span class="keyword">this</span>.rabbitTemplate.convertSendAndReceive(<span class="string">"rpcExchange"</span>, <span class="string">"add"</span>, s);</span><br><span class="line">            <span class="comment">// 回调的信息</span></span><br><span class="line">            System.out.println(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"q_rpc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRabbitTemplate</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(@Payload String payload, Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">                        @Header(AmqpHeaders.REPLY_TO)</span> String replyTo,</span></span><br><span class="line"><span class="function">                        @<span class="title">Header</span><span class="params">(AmqpHeaders.CORRELATION_ID)</span> String correlationId) </span>&#123;</span><br><span class="line">        <span class="comment">// 返回相关信息给回调队列</span></span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(replyTo, payload + <span class="string">" is received"</span>, message -&gt; &#123;</span><br><span class="line">            message.getMessageProperties().setCorrelationId(correlationId);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RabbitmqdemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RPCServer rpcServer;</span><br><span class="line">    <span class="keyword">private</span> RPCClient rpcClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRpcServer</span><span class="params">(RPCServer rpcServer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rpcServer = rpcServer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRpcClient</span><span class="params">(RPCClient rpcClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rpcClient = rpcClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        rpcClient.doRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a is received</span><br><span class="line">b is received</span><br><span class="line">c is received</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud笔记</title>
    <url>/2021/01/21/SpringCloud%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>SpringCloud 笔记</p>
<a id="more"></a>

<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><h4 id="为什么需要微服务"><a href="#为什么需要微服务" class="headerlink" title="为什么需要微服务"></a>为什么需要微服务</h4><p>在没有微服务架构之前，大多数应用都是采用单体架构，把开发好的项目打包，然后发布到<code>tomcat</code>之类的容器之中运行。但是单体架构存在诸多问题：</p>
<ul>
<li>复杂性高：对于一个大型的单体项目来说，整个项目的模块非常多，模块的边界模糊，依赖的关系复杂，代码的质量也是参差不齐，导致维护起来非常困难。</li>
<li>部署效率低：对于单体应用，每次对于项目功能的修复、变更，都需要重新部署整个项目。而随着代码的增多，构建以及部署的时间肯定会增加的，这导致部署的效率很低。</li>
<li>可靠性低：对于单体应用，如果某个服务出现了<code>bug</code>，可能会导致整个应用的崩溃。</li>
<li>扩展能力低：单体的应用只能作为整体进行扩展。比如，某些功能需要大量的计算，这就需要比较强劲的<code>CPU</code>；而另一些服务可能需要比较大的内存。如果这些服务部署在一起，就不得不对硬件做出妥协。</li>
<li>技术创新难：作为单体应用，使用的技术必然是统一的，每个开发成员都需要使用相同的开发语言和框架，如果要引入新的技术会变得很困难。</li>
</ul>
<p>为了解决以上的问题，引入了微服务架构。</p>
<h4 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h4><p>微服务是一种将一个单一应用程序拆分成一组小型服务的方法，拆分完成后，每个服务都运行在独立的进程中，服务间的通信采用轻量级通信机制，例如<code>HTTP</code>、<code>RPC</code>。每个服务都围绕具体的业务进行构建，例如一个电商系统，会分为订单服务、物流服务、支付服务、会员服务等等，每个服务都会被拆分成单独的应用，独立部署到生产环境中。这些服务共用一个最小型的集中式管理。每个服务都可以采用不同的语言进行开发，使用不同的数据存储技术。</p>
<hr>
<h3 id="SpringCloud-介绍"><a href="#SpringCloud-介绍" class="headerlink" title="SpringCloud 介绍"></a>SpringCloud 介绍</h3><p><code>SpringCloud</code>是微服务思想在<code>Java</code>语言的具体实现。它提供了组件的一键式启动和部署能力，极大简化了微服务架构的落地。<code>SpringCloud</code>内部包含了许多框架，这些框架相互协作，共同来构建分布式系统。</p>
<h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>服务注册与发现</li>
<li>负载均衡</li>
<li>服务间调用</li>
<li>容错、服务降级、断路器</li>
<li>消息总线</li>
<li>分布式配置中心</li>
<li>链路器</li>
</ul>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p><code>SpringCloud</code>的版本是根据伦敦地铁站的名字命名的。<code>A(Angel)</code>、<code>B(Brixton)</code>、<code>C(Camden)</code>…目前已经到了<code>H(Hoxton)</code>。而版本后面的还带着小版本。</p>
<ul>
<li><code>M</code>：是里程碑<code>milestone</code>的缩写。</li>
<li><code>RC</code>：是<code>Release Candidate</code>的缩写，表示该版本处于候选状态。</li>
<li><code>SR</code>：是<code>Service Release</code>的缩写，是正式稳定版。相当于<code>GA(Generally Avaliable)</code>版本。</li>
<li><code>SNAPSHOT</code>：快照版本。</li>
</ul>
<hr>
<h3 id="SpringCloud-体系"><a href="#SpringCloud-体系" class="headerlink" title="SpringCloud 体系"></a>SpringCloud 体系</h3><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><ul>
<li><code>SpringCloud Netflix</code>：<code>SpringCloud</code>成立之初立下了汗马功劳。现在已经断更了。</li>
<li><code>SpringCloud Config</code>：分布式配置中心。利用<code>git</code>、<code>svn</code>集中管理项目的配置文件。</li>
<li><code>SpringCloud Bus</code>：消息总线。构建消息驱动的微服务，也可以用来做状态管理。</li>
<li><code>SpringCloud Cloudfoundry</code>：集成应用程序。</li>
<li><code>SpringCloud Consul</code>：服务注册发现。</li>
<li><code>SpringCloud Security</code>：在<code>Zuul</code>代理中，为<code>Oauth2</code>客户端认证提供支持。</li>
<li><code>SpringCloud Stream</code>：基于<code>Redis</code>、<code>RabbitMQ</code>、<code>Kafka</code>实现的消息微服务。</li>
<li><code>SpringCloud AWS</code>：快速集成亚马逊云服务。</li>
<li><code>SpringCloud Openfeign</code>：提供<code>OpenFeign</code>集成到<code>SpringBoot</code>应用中的方式，主要解决微服务之间的调用问题。</li>
<li><code>SpringCloud Contract</code>：消费者驱动的、面向<code>Java</code>的契约框架。</li>
<li><code>SpringCloud Zookeeper</code>：基于<code>Apache Zookeeper</code>的服务注册和发现。</li>
<li><code>SpringCloud Data Flow</code>：在一个结构化的平台上，组成数据微服务。</li>
<li><code>SpringCLoud Gateway</code>：网关服务。</li>
<li><code>SpringCloud Kubernetes</code>：<code>SpringCloud</code>提供的针对<code>Kubernetes</code>的支持。</li>
<li><code>SpringCloud Task</code>：短生命周期的微服务。</li>
</ul>
<hr>
<h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p><code>Eureka</code>是<code>SpringCloud</code>的一个注册中心，类似于<code>Zookeeper</code>。</p>
<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>什么是注册中心？为什么需要注册中心？</p>
<p>单体应用中，所有业务都集中在一起，用户从浏览器发送请求，直接由前端发起请求给后端，后端处理业务逻辑返回结果给前端做出响应。这是不需要注册中心的。</p>
<p>但如果将系统拆分为多个服务模块，每个模块独立运行，这时就需要模块之间相互协作，互相调用。模块之间的调用存在强耦合的问题。比如<code>A</code>调用<code>B</code>，那么就需要在<code>A</code>中写上<code>B</code>的地址，如果<code>B</code>的地址改了<code>A</code>也要改，如果<code>B</code>进行集群化部署的话<code>A</code>也要修改。</p>
<p>为了解决高耦合的问题，引入了注册中心。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>Eureka</code>是<code>Netflix</code>公司提供的一款服务注册中心，基于<code>REST</code>实现服务的注册和发现。</p>
<p><code>Eureka</code>由服务端和客户端构成。服务端就是注册中心，用来接收服务的注册，客户端是<code>Java</code>客户端，用于注册并可以实现负载均衡等等功能。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p><img src="eureka.png" alt=""></p>
<ol>
<li>服务提供者将服务注册到注册中心。</li>
<li>服务消费者通过注册中心查找服务。</li>
<li>服务消费者查找到服务后进行调用，无需硬编码<code>url</code>。</li>
<li>服务消费者与注册中心保持心跳连接，一旦服务提供者的地址发生变更，注册中心就会通知服务消费者。</li>
</ol>
<h4 id="基本搭建"><a href="#基本搭建" class="headerlink" title="基本搭建"></a>基本搭建</h4><p><code>Eureka</code>是使用<code>Java</code>开发的，<code>SpringCloud</code>使用了<code>SpringBoot</code>对<code>Eureka</code>进行了封装，只要引入<code>spring-cloud-starter-netflix-eureka-server</code>依赖即可使用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在项目启动类添加注解<code>@EnableEurekaServer</code>标记该项目是<code>Eureka server</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加配置信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务名</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka</span></span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">1111</span></span><br><span class="line"><span class="comment"># 当前项目不注册到注册中心上</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 不从 Eureka Server 上获取注册信息</span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>浏览器输入<code>localhost:1111</code>即可看到<code>Eureka</code>页面。</p>
<p><img src="eureka_server.png" alt=""></p>
<h4 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h4><p>使用了注册中心后，所有的服务都会通过注册中心进行数据通信，那么注册中心的可用性就很重要了，如果挂了那就会影响到整个系统。所以<code>Eureka</code>一般是以集群的方式部署的。</p>
<p><code>Eureka</code>集群，实际上就是启动多个<code>Eureka</code>实例，实例之间相互注册、同步数据，共同组成一个<code>Eureka</code>集群。</p>
<p>我们搭建两个<code>Eureka</code>实例，添加两个配置文件。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务名</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka</span></span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">1111</span></span><br><span class="line"><span class="comment"># 实例名</span></span><br><span class="line"><span class="meta">eureka.instance.hostname</span>=<span class="string">eurekaA</span></span><br><span class="line"><span class="comment"># A 注册到 B</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://eurekaB:1112/eureka</span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务名</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka</span></span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">1112</span></span><br><span class="line"><span class="comment"># 实例名</span></span><br><span class="line"><span class="meta">eureka.instance.hostname</span>=<span class="string">eurekaB</span></span><br><span class="line"><span class="comment"># B 注册到 A</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://eurekaA:1111/eureka</span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>在<code>hosts</code>文件中添加<code>127.0.0.1 eurakaA eurekaB</code>，使得主机名可以映射为<code>IP</code>地址。</p>
<p>用<code>maven</code>打包项目，通过命令行启动两个实例。最后在浏览器输入<code>1111</code>和<code>1112</code>端口，就可以看见集群已经搭建成功了。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><code>Eureka</code>本身可以分为<code>Eureka Server</code>和<code>Eureka Client</code>。</p>
<h5 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h5><p><code>Eureka Server</code>主要提供三个功能：</p>
<ul>
<li>服务注册，所有的服务都注册到<code>Eureka Server</code>上。</li>
<li>提供注册表，注册表就是所有注册到<code>Eureka Server</code>上的服务的列表，<code>Eureka Client</code>在调用服务时，需要获取这个注册表。注册表会进行缓存，如果缓存失效，就会获取最新的注册表。</li>
<li>同步状态，<code>Eureka Client</code>通过注册、心跳等机制，和<code>Eureka Server</code>同步当前客户端的状态。</li>
</ul>
<h5 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h5><p><code>Eureka Client</code>用于简化服务和<code>Eureka Server</code>之间的交互。<code>Eureka Client</code>会自动拉取、更新和缓存<code>Eureka Server</code>中的信息，即使<code>Eureka Server</code>所有节点都宕机了，<code>Eureka Client</code>依然能够获取想要调用的服务的地址，不过这个地址可能不是准确的。</p>
<h6 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h6><p>服务提供者将自己的服务注册到注册中心，提供自身的元数据信息，例如<code>IP</code>地址、端口、名称、运行状态等等。</p>
<h6 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h6><p><code>Eureka Client</code>注册到<code>Eureka Server</code>上，默认情况下每<strong>30秒</strong>就要向<code>Eureka Server</code>发送一条心跳消息，告诉<code>Eureka Server</code>自己还在运行。如果<code>Eureka Server</code>连续<strong>90秒</strong>都没有收到<code>Eureka Client</code>的续约消息，会认为它已经掉线了，将其从注册表中移除。</p>
<h6 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h6><p><code>Eureka Client</code>下线时会主动发送消息告诉<code>Eureka Server</code>。</p>
<h6 id="获取注册表信息"><a href="#获取注册表信息" class="headerlink" title="获取注册表信息"></a>获取注册表信息</h6><p><code>Eureka Client</code>从<code>Eureka Server</code>获取注册表信息缓存在本地。客户端需要调用服务时会从注册表获取对应的<code>IP</code>地址、端口等信息。缓存的注册表信息会定期更新，如果<code>Eureka Server</code>和本缓存的注册表信息不同的话<code>Eureka Client</code>会自动处理。在配置文件中可以通过</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>来配置是否允许客户端获取注册表信息进行缓存，通过</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">eureka.client.registry-fetch-interval-seconds</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure>

<p>来配置更新注册表的时间间隔，默认为<strong>30秒</strong>。</p>
<h4 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h4><p><img src="eureka%E9%9B%86%E7%BE%A4.png" alt=""></p>
<p><code>Eureka Server</code>之间通过<code>Replicate</code>同步数据，它们之间不区分主从节点，通过<code>service-url</code>相互注册，构成集群，提高节点的可用性。如果某个节点宕机了，<code>Eureka Client</code>会自动切换到新的<code>Eureka Server</code>上，每个<code>Eureka Server</code>节点都会相互同步数据。<code>Eureka Server</code>的连接方式也可以是单线的，例如<code>A -&gt; B -&gt; C</code>，这样<code>A</code>和<code>C</code>之间也可以同步数据。但是一般不这样写。</p>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p><code>Eureka</code>提供了<code>region</code>和<code>zone</code>进行分区。</p>
<ul>
<li><code>region</code>：地理分区，比如亚洲地区，或者东北地区，再或者北京、上海地区等等，没有具体大小的限制。</li>
<li><code>zone</code>：某个<code>region</code>内的具体机房。</li>
</ul>
<p>假设有一个<code>region</code>，底下有两个<code>zone</code>。每个<code>zone</code>有自己的注册中心和服务提供者。现在在<code>zone1</code>下创建消费者调用服务，则会优先调用<code>zone1</code>下的服务提供者提供的服务。</p>
<h4 id="服务注册-1"><a href="#服务注册-1" class="headerlink" title="服务注册"></a>服务注册</h4><p>把一个服务注册到注册中心上，当其他服务需要调用该服务时，就可以从注册中心上查询该服务的信息。</p>
<p>创建一个<code>provider</code>。首先添加<code>Eureka Client</code>和<code>web</code>依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置注册地址</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务名</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">provider</span></span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">1113</span></span><br><span class="line"><span class="comment"># 注册地址</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:1111/eureka</span></span><br></pre></td></tr></table></figure>

<p>最后访问<code>localhost:1111</code>就可以看到注册信息了。</p>
<h4 id="服务消费"><a href="#服务消费" class="headerlink" title="服务消费"></a>服务消费</h4><p>在<code>provider</code>中提供一个服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name + <span class="string">": "</span> + port + <span class="string">" "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着创建一个<code>consumer</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDiscoveryClient</span><span class="params">(DiscoveryClient discoveryClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.discoveryClient = discoveryClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">"provider"</span>);</span><br><span class="line">        ServiceInstance instance = list.get(<span class="number">0</span>);</span><br><span class="line">        String host = instance.getHost();</span><br><span class="line">        <span class="keyword">int</span> port = instance.getPort();</span><br><span class="line">        String path = <span class="string">"http://"</span> + host + <span class="string">":"</span> + port + <span class="string">"/hello/"</span> + name;</span><br><span class="line">        HttpURLConnection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">            conn = ((HttpURLConnection) url.openConnection());</span><br><span class="line">            <span class="keyword">if</span> (conn.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">                BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream()));</span><br><span class="line">                <span class="keyword">return</span> br.readLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consumer</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">1115</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:1111/eureka</span></span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:1115/hello/XXX</code>可以看到<code>hello XXX: 1113</code>。说明调用了<code>provider</code>提供的服务。</p>
<p>这里利用了<code>DiscoveryClient</code>类通过注册的服务名称获取服务的信息，然后拼接成<code>URL</code>地址就可以访问了。这样解决了硬编码<code>URL</code>的问题，如果服务提供者的地址发生了变化也依然可以访问到。</p>
<h5 id="集群化部署-provider"><a href="#集群化部署-provider" class="headerlink" title="集群化部署 provider"></a>集群化部署 provider</h5><p>前面只部署了一个服务提供者，不能保证高可用性，所以采用集群化部署，通过运行时指定端口就可以实现注册多个实例。</p>
<p>这里采用<code>1113</code>和<code>1114</code>端口部署。运行发现其中一个端口会一直为我们提供服务，如果把这个端口的服务下线，我们依然可以享受到这个服务，只不过提供者的端口变成了另一个。</p>
<p>这是因为<code>ServiceInstance instance = list.get(0);</code>始终获取的都是第一个实例。如果要实现<strong>负载均衡</strong>，可以这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">"provider"</span>);</span><br><span class="line">    <span class="comment">// 对服务列表长度取余</span></span><br><span class="line">    ServiceInstance instance = list.get((cnt++) % list.size());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于自己实现了线性负载均衡的功能。</p>
<h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h4><p><code>RestTemplate</code>是<code>Spring 3.0</code> 开始提供的一个<code>HTTP</code>请求工具，提供了常见的<code>REST</code>请求方法模板，例如<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>等等。</p>
<h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p><code>GET</code>请求有两大类方法：</p>
<p><img src="resttemplate_get.png" alt=""></p>
<p>这两大类方法是重载的，不同的是返回值类型。</p>
<p><code>getForObject</code>返回的是一个对象，也就是服务端返回的具体值。<code>getForEntity</code>返回的是<code>ResponseEntity</code>，包含了服务端返回的数据和<code>HTTP</code>相应头的数据。</p>
<p>首先添加一个<code>bean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入<code>restTemplate</code>，使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRestTemplate</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">"provider"</span>);</span><br><span class="line">    ServiceInstance instance = list.get(<span class="number">0</span>);</span><br><span class="line">    String host = instance.getHost();</span><br><span class="line">    <span class="keyword">int</span> port = instance.getPort();</span><br><span class="line">    String path = <span class="string">"http://"</span> + host + <span class="string">":"</span> + port + <span class="string">"/hello/"</span> + name;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(path, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>先提供一个<code>User</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>provider</code>中提供两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">addUser1</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">addUser2</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别代表了两种传参方式：<code>key-value</code>方式和<code>JSON</code>方式。</p>
<p>然后在<code>consumer</code>通过<code>restTemplate</code>发送<code>POST</code>请求。</p>
<p><img src="resttemplate_post.png" alt=""></p>
<p><code>POST</code>请求有三大类方法。其中<code>postForObject</code>和<code>postForEntity</code>与<code>GET</code>基本一致。</p>
<p><code>consumer</code>添加请求方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">hello1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultiValueMap&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    map.add(<span class="string">"id"</span>, <span class="number">1</span>); map.add(<span class="string">"username"</span>, <span class="string">"irvlin"</span>); map.add(<span class="string">"password"</span>, <span class="string">"123"</span>);</span><br><span class="line">    <span class="keyword">return</span> restTemplate.postForObject(<span class="string">"http://provider/user1"</span>, map, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">hello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>); user.setUsername(<span class="string">"irvlin"</span>); user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">    <span class="keyword">return</span> restTemplate.postForObject(<span class="string">"http://provider/user2"</span>, user, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hello1()</code>方法采用的是<code>key-value</code>形式传参，<code>hello2()</code>方法采用的是<code>JSON</code>形式进行传参。</p>
<p>还有一类方法是<code>postForLocation</code>。当执行完一个<code>POST</code>请求需要立即重定向就可以使用这个方法。重定向的地址要使用绝对路径。</p>
<h5 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h5><p><code>PUT</code>也支持两种方式传参。</p>
<p><img src="resttemplate_put.png" alt=""></p>
<h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p><code>DELETE</code>支持两种方式传参，<code>key-value</code>形式或者<code>@PathVariable</code>（参数放在请求路径中）。</p>
<p><img src="resttemplate_delete.png" alt=""></p>
<h4 id="LoadBalanced"><a href="#LoadBalanced" class="headerlink" title="@LoadBalanced"></a>@LoadBalanced</h4><p>负载均衡一般分为<strong>服务端负载均衡</strong>和<strong>客户端负载均衡</strong>。</p>
<p>服务端负载均衡一般是用<code>nginx</code>，它的一个特点是调用的客户端并不知道真正是哪个服务器提供了服务，也不用关心。将请求发送给<code>nginx</code>，<code>nginx</code>就会进行请求转发。</p>
<p>而客户端负载均衡，调用的客户端是知道所有<code>server</code>的信息的，需要调用服务时从自身维护的<code>server</code>列表中根据配置好的负载均衡策略选择一个进行调用。</p>
<p>使用<code>@LoadBalanced</code>注解就可以更方便地实现客户端负载均衡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么给<code>RestTemplate</code>提供了这个注解就可以了呢？</p>
<p>这是因为给<code>RestTemplate</code>加入了<code>LoadBalancerInterceptor</code>拦截器。这个拦截器会拦截<code>RestTemplate</code>的每次请求，利用<code>ribbon</code>实现负载均衡。以下是拦截方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> URI originalUri = request.getURI();</span><br><span class="line">    String serviceName = originalUri.getHost();</span><br><span class="line">    Assert.state(serviceName != <span class="keyword">null</span>,</span><br><span class="line">                 <span class="string">"Request URI does not contain a valid hostname: "</span> + originalUri);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.loadBalancer.execute(serviceName,</span><br><span class="line">                                     <span class="keyword">this</span>.requestFactory.createRequest(request, body, execution));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么是谁给<code>RestTemplate</code>加的拦截器呢？</p>
<ul>
<li><p>首先，<code>@LoadBalanced</code>生效的问题，我们需要去看<code>LoadBalancerAutoConfiguration</code>自动装配类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RestTemplate<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnBean</span>(<span class="title">LoadBalancerClient</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">LoadBalancerRetryProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类有两个注解：<code>@ConditionalOnClass(RestTemplate.class)</code>、<code>@ConditionalOnBean(LoadBalancerClient.class)</code>。意思是需要有<code>RestTemplate</code>类存在且<code>Spring</code>容器内有<code>LoadBalancerClient</code>类型的<code>Bean</code>，这个配置类才会生效。前面我们已经配了<code>RestTemplate</code>，而且<code>Ribbon</code>也提供了<code>LoadBalancerClient</code>接口的实现类，所以条件都满足了，配置也就生效了。</p>
<p>这个类有一个关键的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br></pre></td></tr></table></figure>

<p>就是这个变量获取了所有标注了<code>@LoadBalanced</code>的<code>RestTemplate</code>。</p>
</li>
<li><p>利用<code>RestTemplateCustomizer</code>加拦截器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">        List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">            restTemplate.getInterceptors());</span><br><span class="line">        list.add(loadBalancerInterceptor);</span><br><span class="line">        restTemplate.setInterceptors(list);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SmartInitializingSingleton <span class="title">loadBalancedRestTemplateInitializerDeprecated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;</span><br><span class="line">        <span class="comment">// 遍历成员变量 restTemplates 利用上面的 RestTemplateCustomizer 给每个都添加拦截器</span></span><br><span class="line">        <span class="keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="keyword">this</span>.restTemplates) &#123;</span><br><span class="line">            <span class="keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">                customizer.customize(restTemplate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>那么<code>ribbon</code>具体是如何实现的呢？</p>
<p>首先，<code>LoadBalancerClient</code>接口有三个方法，继承了<code>ServiceInstanceChooser</code>接口。<code>ServiceInstanceChooser</code>接口主要用于负载均衡功能的实现。</p>
<p>而<code>RibbonLoadBalancerClient</code>是<code>LoadBalancerClient</code>的具体实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">    Server server = getServer(loadBalancer, hint);</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">    RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server,</span><br><span class="line">                                                 isSecure(server, serviceId),</span><br><span class="line">                                                 serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，<code>getLoadBalancer</code>会获取所有可用的服务列表，然后通过<code>getServer</code>选择其中一个服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Server <span class="title">getServer</span><span class="params">(ILoadBalancer loadBalancer, Object hint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loadBalancer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Use 'default' on a null hint, or just pass it on?</span></span><br><span class="line">    <span class="keyword">return</span> loadBalancer.chooseServer(hint != <span class="keyword">null</span> ? hint : <span class="string">"default"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>chooseServer</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ENABLED.get() || getLoadBalancerStats().getAvailableZones().size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Zone aware logic disabled or there is only one zone"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.chooseServer(key);</span><br><span class="line">    &#125;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LoadBalancerStats lbStats = getLoadBalancerStats();</span><br><span class="line">        Map&lt;String, ZoneSnapshot&gt; zoneSnapshot = ZoneAvoidanceRule.createSnapshot(lbStats);</span><br><span class="line">        logger.debug(<span class="string">"Zone snapshots: &#123;&#125;"</span>, zoneSnapshot);</span><br><span class="line">        <span class="keyword">if</span> (triggeringLoad == <span class="keyword">null</span>) &#123;</span><br><span class="line">            triggeringLoad = DynamicPropertyFactory.getInstance().getDoubleProperty(</span><br><span class="line">                    <span class="string">"ZoneAwareNIWSDiscoveryLoadBalancer."</span> + <span class="keyword">this</span>.getName() + <span class="string">".triggeringLoadPerServerThreshold"</span>, <span class="number">0.2</span>d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (triggeringBlackoutPercentage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            triggeringBlackoutPercentage = DynamicPropertyFactory.getInstance().getDoubleProperty(</span><br><span class="line">                    <span class="string">"ZoneAwareNIWSDiscoveryLoadBalancer."</span> + <span class="keyword">this</span>.getName() + <span class="string">".avoidZoneWithBlackoutPercetage"</span>, <span class="number">0.99999</span>d);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; availableZones = ZoneAvoidanceRule.getAvailableZones(zoneSnapshot, triggeringLoad.get(), triggeringBlackoutPercentage.get());</span><br><span class="line">        logger.debug(<span class="string">"Available zones: &#123;&#125;"</span>, availableZones);</span><br><span class="line">        <span class="keyword">if</span> (availableZones != <span class="keyword">null</span> &amp;&amp;  availableZones.size() &lt; zoneSnapshot.keySet().size()) &#123;</span><br><span class="line">            String zone = ZoneAvoidanceRule.randomChooseZone(zoneSnapshot, availableZones);</span><br><span class="line">            logger.debug(<span class="string">"Zone chosen: &#123;&#125;"</span>, zone);</span><br><span class="line">            <span class="keyword">if</span> (zone != <span class="keyword">null</span>) &#123;</span><br><span class="line">                BaseLoadBalancer zoneLoadBalancer = getLoadBalancer(zone);</span><br><span class="line">                server = zoneLoadBalancer.chooseServer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"Error choosing server using zone aware logic for load balancer=&#123;&#125;"</span>, name, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">"Zone avoidance logic is not invoked."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.chooseServer(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        counter = createCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    counter.increment();</span><br><span class="line">    <span class="keyword">if</span> (rule == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rule.choose(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"LoadBalancer [&#123;&#125;]:  Error choosing server for key &#123;&#125;"</span>, name, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rule</code>是具体的负载均衡策略，默认是线性负载均衡。进入<code>choose</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">    Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">    <span class="keyword">if</span> (server.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> server.get();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>chooseRoundRobinAfterFiltering</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</code>就是具体的选择方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = nextIndex.get();</span><br><span class="line">        <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">        <span class="keyword">if</span> (nextIndex.compareAndSet(current, next) &amp;&amp; current &lt; modulo)</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这和之前自己写的逻辑基本一致，就是对服务列表的长度取余。然后用原子操作<code>CAS</code>对<code>index</code>赋值给后续的调用使用。</p>
<p><code>ribbon</code>提供的负载均衡策略还有很多个：</p>
<p><img src="ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5.png" alt=""></p>
<ul>
<li><code>AvailabilityFilteringRule</code>：过滤掉一直连接失败或者高并发的<code>server</code>，然后从剩余的服务节点中轮询选出节点。</li>
<li><code>BestAvailableRule</code>：选择一个并发量最小的<code>server</code>返回。<code>serverStats</code>有一个属性<code>activeRequestCount</code>记录了并发量，轮询所有<code>server</code>比较即可。</li>
<li><code>ZoneAvoidanceRule</code>：判断<code>server</code>的运行性能并且过滤掉连接数过多的<code>server</code>来选择。</li>
<li><code>RandomRule</code>：随机选择。</li>
<li><code>RetryRule</code>：默认使用轮询策略选择服务，也可以在构造函数传入自己的策略。为了应对可能选择失败的情况，提供了重试机制，在最大重试时间的范围之内重复尝试选择，直到选择成功或者超时。最大超时时间可以通过<code>maxRetryMillis</code>设置，默认为<code>500ms</code>。</li>
<li><code>RoundRobinRule</code>：轮询策略，有一个上限，如果轮询了<strong>10</strong>个服务节点还没有找到可用的服务，就直接结束轮询。</li>
<li><code>WeightedResponseTimeRule</code>：根据服务器的响应时间作为权重选取服务节点。响应时间越短被选中的概率越大。假设有4个服务节点，响应时间分别为<code>100ms</code>、<code>200ms</code>、<code>500ms</code>、<code>1000ms</code>。总响应时间为<code>1800ms</code>。用总时间分别减去每个服务的响应时间得到权重：<code>1700</code>、<code>1600</code>、<code>1300</code>、<code>800</code>，总权重为<code>5400</code>。最后在<code>0 - 5400</code>随机选一个数看它落在哪个区间就选择哪个服务节点。</li>
</ul>
<p><code>RibbonLoadBalancerClient</code>还有重构<code>URI</code>地址的方法，比如把<code>http://provider/hello</code>转换成实际的地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(instance, <span class="string">"instance can not be null"</span>);</span><br><span class="line">    String serviceId = instance.getServiceId();</span><br><span class="line">    RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory .getLoadBalancerContext(serviceId);</span><br><span class="line"></span><br><span class="line">    URI uri;</span><br><span class="line">    Server server;</span><br><span class="line">    <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">        RibbonServer ribbonServer = (RibbonServer) instance;</span><br><span class="line">        server = ribbonServer.getServer();</span><br><span class="line">        uri = updateToSecureConnectionIfNeeded(original, ribbonServer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        server = <span class="keyword">new</span> Server(instance.getScheme(), instance.getHost(), instance.getPort());</span><br><span class="line">        IClientConfig clientConfig = clientFactory.getClientConfig(serviceId);</span><br><span class="line">        ServerIntrospector serverIntrospector = serverIntrospector(serviceId);</span><br><span class="line">        uri = updateToSecureConnectionIfNeeded(original, clientConfig,</span><br><span class="line">                                               serverIntrospector, server);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context.reconstructURIWithServer(server, uri);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">reconstructURIWithServer</span><span class="params">(Server server, URI original)</span> </span>&#123;</span><br><span class="line">    String host = server.getHost();</span><br><span class="line">    <span class="keyword">int</span> port = server.getPort();</span><br><span class="line">    String scheme = server.getScheme();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (host.equals(original.getHost()) </span><br><span class="line">        &amp;&amp; port == original.getPort()</span><br><span class="line">        &amp;&amp; scheme == original.getScheme()) &#123;</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (scheme == <span class="keyword">null</span>) &#123;</span><br><span class="line">        scheme = original.getScheme();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (scheme == <span class="keyword">null</span>) &#123;</span><br><span class="line">        scheme = deriveSchemeAndPortFromPartialUri(original).first();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(scheme).append(<span class="string">"://"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Strings.isNullOrEmpty(original.getRawUserInfo())) &#123;</span><br><span class="line">            sb.append(original.getRawUserInfo()).append(<span class="string">"@"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(host);</span><br><span class="line">        <span class="keyword">if</span> (port &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">":"</span>).append(port);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(original.getRawPath());</span><br><span class="line">        <span class="keyword">if</span> (!Strings.isNullOrEmpty(original.getRawQuery())) &#123;</span><br><span class="line">            sb.append(<span class="string">"?"</span>).append(original.getRawQuery());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Strings.isNullOrEmpty(original.getRawFragment())) &#123;</span><br><span class="line">            sb.append(<span class="string">"#"</span>).append(original.getRawFragment());</span><br><span class="line">        &#125;</span><br><span class="line">        URI newURI = <span class="keyword">new</span> URI(sb.toString());</span><br><span class="line">        <span class="keyword">return</span> newURI;            </span><br><span class="line">    &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><p><code>Consul</code>也是一款注册中心产品，是<code>HashiCorp</code>公司推出的使用<code>GO</code>语言开发的开源产品，主要提供了服务发现、服务隔离、服务配置等功能。 相比于<code>Eureka</code>、<code>Zookeeper</code>，<code>Consul</code>的配置更加一站式，因为其内置了很多微服务常见的功能，例如：服务发现与注册、分布式一致性协议实现、健康检查、键值对存储、多数据中心等。这样就不需要再借助第三方工具来实现这些功能。</p>
<p>下载<code>consul</code>，启动命令为<code>./consul agent -dev -ui -node=consul-dev -client=127.0.0.1</code>。默认端口为<code>8500</code>。</p>
<h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>添加依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建两个<code>provider</code>，端口为<code>2000</code>和<code>2001</code>。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consul-provider</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># server.port=2001</span></span><br><span class="line"><span class="meta">spring.cloud.consul.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.service-name</span>=<span class="string">consul-provider</span></span><br></pre></td></tr></table></figure>

<p>提供服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello &gt;&gt;&gt; "</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加消费者。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consul-consumer</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">2002</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.consul.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.service-name</span>=<span class="string">consul-consumer</span></span><br></pre></td></tr></table></figure>

<p>开启服务发现，提供<code>RestTemplate</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsulConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsulConsumerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancerClient</span><span class="params">(LoadBalancerClient loadBalancerClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancerClient = loadBalancerClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRestTemplate</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取要调用的ServiceInstance</span></span><br><span class="line">        ServiceInstance choose = loadBalancerClient.choose(<span class="string">"consul-provider"</span>);</span><br><span class="line">        System.out.println(restTemplate.getForObject(choose.getUri() + <span class="string">"/hello"</span>, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发现<code>consul</code>已经自带了负载均衡的功能。</p>
<hr>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><h4 id="什么是-Hystrix"><a href="#什么是-Hystrix" class="headerlink" title="什么是 Hystrix"></a>什么是 Hystrix</h4><p><code>Hystrix</code>是<code>Netflix</code>开源的一款针对分布式系统延迟和容错的库，具备回退机制和断路器功能的线程和信号隔离、请求缓存和请求合并，以及监控和配置等功能。</p>
<p>在分布式环境中，一般会存在很多模块，模块之间经常需要互相调用来提供服务。这样就不可避免存在调用失败的情况，任何模块出现故障都可能导致整个系统的崩溃。所以<code>Hystrix</code>就是用来解决这些问题的，它可以通过线程隔离、熔断、服务降级等方案来控制模块之间的交互，以维持整个系统的稳定。<code>Hystrix</code>可以做到以下几件事：</p>
<ul>
<li>通过控制延迟和故障来保障第三方服务调用的可靠性。</li>
<li>在分布式系统中防止级联故障，避免服务雪崩。</li>
<li>快速失败、快速恢复。</li>
<li>服务降级。</li>
<li>监控、报警和操作控制。</li>
</ul>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="hystrix%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt=""></p>
<p>首先，要想使用<code>Hystrix</code>，需要继承<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>。两者主要的区别是：</p>
<ul>
<li>前者的逻辑写在<code>run()</code>方法；后者写在<code>construct()</code>方法。</li>
<li>前者的<code>run()</code>方法会创建一个新线程执行；后者的<code>construct()</code>是由调用程序的线程执行的。</li>
<li>前者的一个实例只能向调用的程序发送单条数据；后者的一个实例可以按顺序发送多条数据。</li>
</ul>
<p>然后是调用执行的方法。<code>execute()</code>、<code>queue()</code>、<code>observe()</code>和<code>toObservable()</code>用于触发执行<code>run()</code>或者<code>construct()</code>，其中<code>execute()</code>和<code>queue()</code>仅对<code>HystrixCommand</code>适用。一个实例只能执行一次这4个方法。它们的主要区别是：</p>
<ul>
<li><code>execute()</code>：同步阻塞的方式执行<code>run()</code>，直到服务返回结果或者抛出异常。</li>
<li><code>queue()</code>：异步非阻塞的方式执行<code>run()</code>，类似<code>Java</code>中的<code>future</code>。</li>
<li><code>observe()</code>：事件注册前，先调用<code>observe()</code>自动触发<code>run()</code>或者<code>construct()</code>。如果继承的是<code>HystrixCommand</code>，<code>Hystrix</code>将创建新线程非阻塞地执行<code>run()</code>，否则将以调用程序线程阻塞执行<code>construct()</code>。第二步是从<code>observe()</code>返回后调用程序调用<code>subscribe()</code>完成事件的注册。如果<code>run()</code>或者<code>construct()</code>执行成功会触发<code>onNext()</code>和<code>onCompleted()</code>，执行失败触发<code>onError()</code>。</li>
<li><code>toObservable()</code>：事件注册前，调用<code>toObservable()</code>返回<code>Observable&lt;R&gt;</code>对象，然后调用<code>subscribe()</code>完成事件注册后自动触发执行<code>run()</code>或者<code>construct()</code>。如果执行成功会触发<code>onNext()</code>和<code>onCompleted()</code>，执行失败触发<code>onError()</code>。</li>
</ul>
<p>这4种方法本质上都是通过<code>toObservable()</code>去执行的。</p>
<p>调用方法后，会判断响应是否存在于缓存中，如果存在就直接返回，否则继续下一步。下一步会检查是否开启了熔断器，如果配置了熔断器并且被打开了，就直接执行<code>fallback()</code>返回结果，否则会去检查线程池和队列，或者信号量是否满了，如果满了，会执行<code>fallback()</code>并且发送<code>reject</code>信息给断路器统计，如果没有满，这时才会去执行<code>run()</code>或者<code>construct()</code>。执行的过程中如果发生了异常或者超时，也会执行<code>fallback()</code>并且计算系统健康值报告给断路器，否则将正常返回方法的返回值。</p>
<h4 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h4><p><img src="%E6%9C%8D%E5%8A%A1%E9%9A%94%E7%A6%BB.png" alt=""></p>
<p>服务隔离的好处：</p>
<ul>
<li>如果我们是服务的消费者，访问了不同的服务，如果某个服务出现了故障，可能会由于雪崩效应导致整个系统的崩溃。而现在有了服务隔离，服务之间就不会影响到彼此。</li>
<li>如果我们是服务的提供者，我们可以动态地调整服务的访问情况。假设有<code>A</code>、<code>B</code>两个服务，在某期间<code>A</code>服务必须保证可用，<code>B</code>允许降级，我们就可以将这两个服务隔离开，<code>B</code>服务降级保证<code>A</code>的可用。</li>
</ul>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>滑动窗口是<code>Hystrix</code>的核心。<code>Hystrix</code>的<code>Metrics</code>保存了当前服务的健康状况，包括了服务调用总数和失败次数等等。通过这些计数，断路器可以计算出服务调用的失败率，从而和设定的阈值进行比较决定断路器的状态切换逻辑。<code>Hystrix</code>使用<code>RxJava</code>的<code>Observable.window()</code>实现滑动窗口。<code>Metrics</code>的配置：<code>metrics.rollingStats.timeInMilliseconds</code>，这个属性设置的是统计的滚动窗口的时间段大小，默认为<strong>10000毫秒</strong>，在代码中可以通过<code>HystrixCommandProperties.Setter().withMetricsRollingStatisticalWindowInMilliseconds(int value)</code>来设置；<code>metrics.rollingStats.numBuckets</code>属性设置的事统计的滚动窗口分为的桶数，默认为<strong>10个</strong>，可以通过<code>HystrixCommandProperties.Setter().withMetricsRollingStatisticalWindowBuckets(int value)</code>来设置。<code>timeInMilliseconds % numBuckets == 0</code>必须成立。</p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>在<code>Java</code>中可以通过注解或者继承的方式实现<code>Hystrix</code>的功能。先来看看继承的方式：</p>
<p>首先引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置信息：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">hystrix</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">3000</span></span><br><span class="line"><span class="comment"># 使用 eureka 作为注册中心</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:1111/eureka</span></span><br></pre></td></tr></table></figure>

<p>使用注解打开断路器，配置<code>RestTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义类继承<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHystrixCommand</span><span class="params">(Setter setter, RestTemplate restTemplate, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以配置GroupKey、CommandKey、ThreadPoolKey，最少需要配置GroupKey</span></span><br><span class="line">        <span class="keyword">super</span>(setter);</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://provider/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixObservableCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHystrixCommand</span><span class="params">(Setter setter, RestTemplate restTemplate, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(setter);</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Observable&lt;String&gt; <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(subscriber -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                subscriber.onNext(restTemplate.getForObject(<span class="string">"http://provider/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                subscriber.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRestTemplate</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyHystrixCommand(</span><br><span class="line">            HystrixCommand.Setter.withGroupKey(</span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(<span class="string">"test"</span>)), restTemplate, name).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要异步执行，就调用<code>queue().get()</code>方法。也可以通过<code>observe</code>阻塞和非阻塞执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步阻塞</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">    MyHystrixCommand command = <span class="keyword">new</span> MyHystrixCommand(</span><br><span class="line">        HystrixCommand.Setter.withGroupKey(</span><br><span class="line">            HystrixCommandGroupKey.Factory.asKey(<span class="string">"test"</span>)), restTemplate, name);</span><br><span class="line">    Observable&lt;String&gt; observe = command.observe();</span><br><span class="line">    <span class="keyword">return</span> observe.toBlocking().single();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步非阻塞</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">    MyHystrixCommand command = <span class="keyword">new</span> MyHystrixCommand(</span><br><span class="line">        HystrixCommand.Setter.withGroupKey(</span><br><span class="line">            HystrixCommandGroupKey.Factory.asKey(<span class="string">"test"</span>)), restTemplate, name);</span><br><span class="line">    Observable&lt;String&gt; observe = command.observe();</span><br><span class="line">    observe.subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"completed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>Eureka Server</code>、<code>provider</code>和<code>Hystrix</code>访问<code>localhost:3000/hello/XXX</code>即可。</p>
<p>如果使用注解，就非常方便了。</p>
<p>对于<code>HystrixCommand</code>，直接在方法上添加<code>@HystrixCommand</code>注解即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于execute()</span></span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://provider/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要实现异步调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于queue()</span></span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">helloService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://provider/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">helloController</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helloService(name).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>HystrixObservableCommand</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于Observe()</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(observableExecutionMode = ObservableExecutionMode.EAGER)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(subscriber -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">            subscriber.onNext(restTemplate.getForObject(<span class="string">"http://provider/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;String&gt; iterator = helloService.hello(name).toBlocking().getIterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解改为<code>@HystrixCommand(observableExecutionMode = ObservableExecutionMode.LAZY)</code>相当于<code>toObservable()</code>。</p>
<h5 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h5><p>当服务器压力剧增或其他某些原因时，一些下游的服务可能会响应过慢，这时我们可以主动停掉一些不太重要的服务，释放出服务器资源，增加主要服务的响应速度；当一些下游服务发生异常不可用时，上游服务可以主动调用一些降级服务，比如调用静态资源而不进行网络请求，或者使用缓存，这样可以避免卡顿，迅速将信息返回给用户。</p>
<p>使用注解，给<code>HystrixCommand</code>配置<code>fallbackMethod</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"error"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 制造异常</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://provider/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法签名和返回值类型都要一致，可以添加Throwable参数捕获异常信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">error</span><span class="params">(String name, Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error: "</span> + t.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以在<code>error</code>方法继续添加服务降级功能。每降一级方法获取数据就越容易。</p>
<p>使用继承，重写<code>getFallback()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHystrixCommand</span><span class="params">(Setter setter, RestTemplate restTemplate, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(setter);</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://provider/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，对于某些异常，我们可能希望直接抛出而不要使用服务降级，那么可以配置忽略某些异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"error"</span>, ignoreExceptions = ArithmeticException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">String</span> <span class="title">hello</span>(<span class="title">String</span> <span class="title">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://provider/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样<code>int i = 1 / 0</code>就会直接抛出异常。</p>
<h5 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h5><p>请求缓存有很多解决方案，使用像<code>redis</code>这样的第三方缓存比较流行。这里我们使用<code>Hystrix</code>也可以实现。注意只有参数相同的请求才可以被缓存。</p>
<p>注解形式，加上<code>@CacheResult</code>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="meta">@CacheResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">helloService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"run hello method"</span>);</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://provider/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这时缓存还不能生效。一般使用缓存，缓存都会有生命周期，所以我们需要初始化<code>HystrixRequestContext</code>，使得缓存生效。当<code>HystrixRequestContext close</code>之后，缓存也就失效了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">helloController</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    HystrixRequestContext ctx = HystrixRequestContext.initializeContext();</span><br><span class="line">    <span class="keyword">return</span> helloService.hello(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承形式，重写<code>getCacheKey()</code>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getCacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"读取cache"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getCacheKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，缓存的<code>key</code>是方法的参数，如果参数有多个，就将它们组合起来。例如参数有<code>name</code>和<code>age</code>，那么只有当<code>name</code>和<code>age</code>都一样才会读取这个缓存。如果想要只以某个参数作为缓存的<code>key</code>，可以添加<code>@CacheKey</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="meta">@CacheResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@CacheKey String name, Integer age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://provider/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话只有<code>name</code>会作为缓存的<code>key</code>。</p>
<p>在做数据缓存时，如果有修改或删除数据的方法，我们改变了数据库中的数据，应该把缓存中的数据给删了，否则后面再获取到的数据就不是最新的了。这时就需要使用<code>@CacheRemove()</code>注解。</p>
<p>使用<code>@CacheRemove()</code>注解时必须要指定<code>commandKey</code>，也就是指定缓存方法的名字，这样才能找到数据缓存在哪，以便删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Command name is used to find appropriate Hystrix command that cache should be cleared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> command name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">commandKey</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h5><p>如果消费者频繁调用某一个服务，调用时只是参数不同，那么就可以将多个请求合并成一个，减少网络请求的开销，提高效率。</p>
<p>先在<code>provider</code>中提供请求合并的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;ids&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserByIds</span><span class="params">(@PathVariable String ids)</span> </span>&#123;</span><br><span class="line">    String[] split = ids.split(<span class="string">","</span>);</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(Integer.parseInt(s));</span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口既可以处理合并之后的请求也可以处理单个请求。</p>
<p><strong>继承方式</strong>，首先<code>provider</code>提供服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;ids&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserByIds</span><span class="params">(@PathVariable String ids)</span> </span>&#123;</span><br><span class="line">    System.out.println(ids);</span><br><span class="line">    String[] split = ids.split(<span class="string">","</span>);</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(Integer.parseInt(s));</span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义<code>HystrixCommand</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixBatchCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">List</span>&lt;<span class="title">User</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; ids;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HystrixBatchCommand</span><span class="params">(Setter setter, List&lt;Integer&gt; ids, HelloService helloService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(setter);</span><br><span class="line">        <span class="keyword">this</span>.ids = ids;</span><br><span class="line">        <span class="keyword">this</span>.helloService = helloService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;User&gt; <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.getUserByIds(ids);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>helloService</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRestTemplate</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserByIds</span><span class="params">(List&lt;Integer&gt; ids)</span> </span>&#123;</span><br><span class="line">        User[] users = restTemplate.getForObject(<span class="string">"http://provider/user/"</span> + StringUtils.join(ids, <span class="string">","</span>), User[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义请求合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCollapseCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCollapser</span>&lt;<span class="title">List</span>&lt;<span class="title">User</span>&gt;, <span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HelloService helloService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HystrixCollapseCommand</span><span class="params">(Setter setter, HelloService helloService, Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 间隔200ms之内的请求进行合并，默认为10ms</span></span><br><span class="line">        <span class="keyword">super</span>(Setter.withCollapserKey(</span><br><span class="line">            HystrixCollapserKey.Factory.asKey(<span class="string">"test"</span>))</span><br><span class="line">              .andCollapserPropertiesDefaults(</span><br><span class="line">                  HystrixCollapserProperties.Setter().withTimerDelayInMilliseconds(<span class="number">200</span>)));</span><br><span class="line">        <span class="keyword">this</span>.helloService = helloService;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRequestArgument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求合并</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> HystrixCommand&lt;List&lt;User&gt;&gt; createCommand(Collection&lt;CollapsedRequest&lt;User, Integer&gt;&gt; collapsedRequests) &#123;</span><br><span class="line">        List&lt;Integer&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;(collapsedRequests.size());</span><br><span class="line">        <span class="keyword">for</span> (CollapsedRequest&lt;User, Integer&gt; request : collapsedRequests) &#123;</span><br><span class="line">            ids.add(request.getArgument());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HystrixBatchCommand(</span><br><span class="line">            HystrixCommand.Setter.withGroupKey(</span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(<span class="string">"test"</span>)), ids, helloService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求结果分发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">mapResponseToRequests</span><span class="params">(List&lt;User&gt; batchResponse, Collection&lt;CollapsedRequest&lt;User, Integer&gt;&gt; collapsedRequests)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (CollapsedRequest&lt;User, Integer&gt; request : collapsedRequests) &#123;</span><br><span class="line">            request.setResponse(batchResponse.get(cnt++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在<code>Hystrix</code>中定义访问接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRestTemplate</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloService</span><span class="params">(HelloService helloService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloService = helloService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        HystrixRequestContext ctx = HystrixRequestContext.initializeContext();</span><br><span class="line">        <span class="comment">// 定义4个请求</span></span><br><span class="line">        HystrixCollapseCommand c1 = <span class="keyword">new</span> HystrixCollapseCommand(helloService, <span class="number">1</span>);</span><br><span class="line">        HystrixCollapseCommand c2 = <span class="keyword">new</span> HystrixCollapseCommand(helloService, <span class="number">2</span>);</span><br><span class="line">        HystrixCollapseCommand c3 = <span class="keyword">new</span> HystrixCollapseCommand(helloService, <span class="number">3</span>);</span><br><span class="line">        HystrixCollapseCommand c4 = <span class="keyword">new</span> HystrixCollapseCommand(helloService, <span class="number">4</span>);</span><br><span class="line">        Future&lt;User&gt; q1 = c1.queue();</span><br><span class="line">        Future&lt;User&gt; q2 = c2.queue();</span><br><span class="line">        Future&lt;User&gt; q3 = c3.queue();</span><br><span class="line">        Future&lt;User&gt; q4 = c4.queue();</span><br><span class="line">        User u1 = q1.get();</span><br><span class="line">        User u2 = q2.get();</span><br><span class="line">        User u3 = q3.get();</span><br><span class="line">        User u4 = q4.get();</span><br><span class="line">        System.out.println(u1);</span><br><span class="line">        System.out.println(u2);</span><br><span class="line">        System.out.println(u3);</span><br><span class="line">        System.out.println(u4);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:3000/hello</code>就可以看到4个<code>User</code>的信息了，但是<code>provider</code>的<code>getUserByIds</code>只打印了<code>1,2,3,4</code>，说明4个请求被合并了。</p>
<p><strong>注解方式</strong>，非常简单，只需要利用<code>@HystrixCollapser</code>，指定批处理的方法名以及设置最大间隔时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCollapser</span>(batchMethod = <span class="string">"getUserByIds"</span>,</span><br><span class="line">                  collapserProperties = &#123;<span class="meta">@HystrixProperty</span>(name = <span class="string">"timerDelayInMilliseconds"</span>, value = <span class="string">"200"</span>)&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;User&gt; <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserByIds</span><span class="params">(List&lt;Integer&gt; ids)</span> </span>&#123;</span><br><span class="line">    User[] users = restTemplate.getForObject(<span class="string">"http://provider/user/"</span> + StringUtils.join(ids, <span class="string">","</span>), User[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义访问接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    HystrixRequestContext ctx = HystrixRequestContext.initializeContext();</span><br><span class="line">    Future&lt;User&gt; q1 = helloService.getUserById(<span class="number">1</span>);</span><br><span class="line">    Future&lt;User&gt; q2 = helloService.getUserById(<span class="number">2</span>);</span><br><span class="line">    Future&lt;User&gt; q3 = helloService.getUserById(<span class="number">3</span>);</span><br><span class="line">    Future&lt;User&gt; q4 = helloService.getUserById(<span class="number">4</span>);</span><br><span class="line">    User u1 = q1.get();</span><br><span class="line">    User u2 = q2.get();</span><br><span class="line">    User u3 = q3.get();</span><br><span class="line">    User u4 = q4.get();</span><br><span class="line">    System.out.println(u1);</span><br><span class="line">    System.out.println(u2);</span><br><span class="line">    System.out.println(u3);</span><br><span class="line">    System.out.println(u4);</span><br><span class="line">    ctx.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发现效果是一样的。</p>
<h4 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h4><p>快速失败指的是没有重写<code>getFallback</code>，直接抛出遇到的异常。</p>
<h4 id="线程池、信号量"><a href="#线程池、信号量" class="headerlink" title="线程池、信号量"></a>线程池、信号量</h4><p><code>Hystrix</code>提供两种模式处理请求：线程池和信号量，默认使用线程池。</p>
<ul>
<li>线程池隔离：对于每个依赖的请求都创建一个新线程去处理，资源的消耗比较大，可以捕获超时异常。</li>
<li>信号量隔离：使用调用服务的线程执行请求，通过信号量的计数器限制并发调用，默认大小为<strong>10</strong>。假设信号量大小为<code>10</code>，那么只允许同时有<code>10</code>个线程调用某服务。没有捕获超时异常的功能。</li>
</ul>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>线程池隔离，适用于大多数场景，比如我们对依赖服务的网络请求的调用和访问，需要对超时时间进行控制。也可以应对突发的流量，如果请求处理不完可以放到线程池的队列中慢慢处理。</li>
<li>信号量隔离，如果依赖的服务延迟极低，比如直接访问缓存数据，那就没有必要使用线程池隔离，那样反而会增加线程切换的开销，直接使用调用服务的线程去处理请求即可。但是信号量隔离不好应对突发的流量，如果线程数量超过了设置的值，其他请求会直接被拒绝。</li>
</ul>
<h4 id="超时熔断"><a href="#超时熔断" class="headerlink" title="超时熔断"></a>超时熔断</h4><p>为了优化用户体验，如果网络的请求遇到了超时的情况，可以直接放弃本次请求，返回缓存或者静态数据。超时的时间可以进行设置，默认为<strong>1秒</strong>。具体的配置项有：</p>
<ul>
<li><code>execution.timeout.enabled</code>：是否开启超时，默认为<strong>true</strong>。</li>
<li><code>execution.isolation.thread.timeoutInMilliseconds</code>：超时时间，默认为<strong>1秒</strong>。</li>
<li><code>execution.isolation.thread.interruptOnTimeout</code>：超时后是否中断<code>run()</code>方法，默认为<strong>false</strong>。</li>
</ul>
<h4 id="并发熔断"><a href="#并发熔断" class="headerlink" title="并发熔断"></a>并发熔断</h4><p>我们还可以配置最大的并发访问量，用到了<code>maxConcurrentRequests</code>。</p>
<ul>
<li><code>execution.isolation.semaphore.maxConcurrentRequests</code>：设置<code>run()</code>方法的最大并发请求数，默认为<strong>10</strong>。该属性仅在信号量模式下生效。</li>
<li><code>fallback.isolation.semaphore.maxConcurrentRequests</code>：设置<code>fallback</code>方法的最大并发请求数，默认为<strong>10</strong>。</li>
</ul>
<h4 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h4><p>熔断器相关配置有6个参数：</p>
<ul>
<li><code>circuitBreaker.enabled</code>：断路器是否打开。默认为<code>true</code>。</li>
<li><code>circuitBreaker.requestVolumeThreshold</code>：在一个时间窗内，请求达到多少次失败会触发熔断。默认为<strong>20</strong>。假设一个时间窗内有19个请求，全失败了，但由于达不到20，所以也不会熔断。</li>
<li><code>circuitBreaker.sleepWindowInMilliseconds</code>：熔断后，间隔多长时间检测服务是否恢复。默认为<strong>5秒</strong>。</li>
<li><code>circuitBreaker.forceOpen</code>：是否强制熔断。默认为<strong>false</strong>。如果设置为<code>true</code>，则所有请求都会熔断，直接执行<code>fallback()</code>。</li>
<li><code>circuitBreaker.forceClosed</code>：是否禁止熔断。默认为<strong>false</strong>。如果设置为<code>true</code>，则所有请求都会运行<code>run()</code>。如果<code>forceOpen</code>设置为<code>true</code>，此配置不生效。</li>
</ul>
<hr>
<h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p><code>OpenFeign</code>是<code>SpringCloud</code>在<code>Netflix Feign</code>基础上开发出的声明式服务调用组件。</p>
<p>前面我们调用服务都是使用了<code>RestTemplate</code>，但是它比较繁琐，很多请求只是参数不同或者返回值类型不同，其他是一样的，所以可以进行简化。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>首先导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>Eureka</code>作为注册中心。配置文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">openfeign</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">4000</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:1111/eureka</span></span><br></pre></td></tr></table></figure>

<p>在项目启动类添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenfeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OpenfeignApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建<code>service</code>，利用注解使用<code>openFeign</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"provider"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@PathVariable String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@FeignClient</code>绑定了<code>provider</code>，接口中定义了<code>hello</code>方法，方法名随意，<code>GetMapping(&quot;/hello/{name}&quot;)</code>指定了这是一个<code>GET</code>请求，地址为<code>/hello/{name}</code>，返回值类型是<code>String</code>。对应了<code>provider</code>中的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">Integer port;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + name + <span class="string">": "</span> + port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后定义<code>controller</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloService</span><span class="params">(HelloService helloService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloService = helloService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.hello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:4000/hello/XXX</code>即可正常访问。</p>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>几种传递参数的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"provider"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestParam String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function">String <span class="title">addUser</span><span class="params">(@RequestBody User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(@RequestBody String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"add "</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function">String <span class="title">hello</span><span class="params">(@RequestHeader String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestHeader String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@RequestHeader</code>表示使用<code>header</code>传递参数，如果传递的参数是中文，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helloService.hello(<span class="string">"爪哇"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要进行转码。否则，访问页面时候会出现乱码的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helloService.hello(URLEncoder.encode(<span class="string">"爪哇"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，在<code>provider</code>中进行解码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestHeader String name)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + URLDecoder.decode(name, <span class="string">"UTF-8"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样才能显示中文。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>由于<code>provider</code>和<code>openFeign</code>有重复的部分，故可以把重复的部分提取到一个公共的接口中，让<code>provider</code>和<code>openFeign</code>实现接口里的方法。这样可以节省代码量，而且不易出错。因为如果要修改服务的地址，只需要在公共接口中修改就一致了。但同时这也增加了服务端和消费端的代码耦合度。</p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>我们可以通过配置查看<code>openFeign</code>请求的调用过程。日志的级别分为四种：</p>
<ul>
<li><code>NONE</code>：不开启日志。默认不开启。</li>
<li><code>BASIC</code>：记录请求方法、<code>URL</code>、响应状态码、执行时间。</li>
<li><code>HEADERS</code>：在<code>BASIC</code>基础上，加载请求/响应头。</li>
<li><code>FULL</code>：在<code>HEADERS</code>基础上，增加<code>body</code>以及请求元数据。</li>
</ul>
<p>首先，要提供一个<code>bean</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">Logger.<span class="function">Level <span class="title">loggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加配置，配置日志级别</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.xyz.irvlin.openfeign.service.HelloService</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>重启之后发送请求就可看到日志了。</p>
<h4 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h4><p>我们可以使用数据压缩增加数据请求、响应的效率。</p>
<p>增加配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 请求的数据压缩</span></span><br><span class="line"><span class="meta">feign.compression.request.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 响应的数据压缩</span></span><br><span class="line"><span class="meta">feign.compression.response.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 压缩的数据类型</span></span><br><span class="line"><span class="meta">feign.compression.request.mime-types</span>=<span class="string">text/html, application/json</span></span><br><span class="line"><span class="comment"># 传输的数据大于 2048 byte 时才进行压缩</span></span><br><span class="line"><span class="meta">feign.compression.request.min-request-size</span>=<span class="string">2048</span></span><br></pre></td></tr></table></figure>

<h4 id="服务降级-1"><a href="#服务降级-1" class="headerlink" title="服务降级"></a>服务降级</h4><p>在<code>openFeign</code>中也可以实现服务降级。</p>
<p>配置文件中开启<code>Hystrix</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">feign.hystrix.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>在<code>service</code>中开启注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"provider"</span>, fallbackFactory = FallbackFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function">String <span class="title">getUserByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义<code>FallbackFactory</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FallbackFactory</span> <span class="keyword">implements</span> <span class="title">feign</span>.<span class="title">hystrix</span>.<span class="title">FallbackFactory</span>&lt;<span class="title">HelloService</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService() &#123;</span><br><span class="line">            <span class="comment">// 定义fallback方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> throwable.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getUserByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> throwable.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搞定。</p>
<hr>
<h3 id="Resilience4j"><a href="#Resilience4j" class="headerlink" title="Resilience4j"></a>Resilience4j</h3><p><code>Resilience4j</code>是一款容错解决方案，类似于<code>Hystrix</code>。<code>Resilience4j</code>专为<code>Java 8</code>以及函数式编程设计。</p>
<p><code>Resilience4j</code>主要提供了以下功能：</p>
<ul>
<li>断路器</li>
<li>限流</li>
<li>基于信号量的隔离</li>
<li>缓存</li>
<li>限时</li>
<li>请求重试</li>
</ul>
<h4 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><code>Resilience4j</code>的断路器通过有限状态机实现：<code>CLOSED</code>、<code>OPEN</code>、<code>HALF_OPEN</code>以及<code>DISABLED(所有请求都通过)</code>、<code>FORCED_OPEN(所有请求都拒绝)</code>。当断路器关闭时，所有请求都可以通过。如果失败率超过了设定的阈值，断路器就会打开，请求会被拒绝。经过一段时间后，断路器会处于<strong>半打开</strong>的状态，这时可以有一定数量的请求被放行，重新计算失败率。</p>
<p><img src="resilience4j%E7%8A%B6%E6%80%81%E6%9C%BA.jpg" alt=""></p>
<p>在<code>Hystrix</code>中是通过滑动窗口来计算请求状态的，而<code>Resilience4j</code>使用<strong>环形缓冲区</strong>。环形缓冲区内部使用<strong>bitset</strong>存储。</p>
<p><img src="%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt=""></p>
<p>每一次请求的成功或失败的状态只占用<code>1 bit</code>。计算失败率需要将数据填满缓冲区，如果缓冲区大小为<code>20</code>，但只发送了<code>19</code>个请求，那么即使这<code>19</code>个请求都失败了，也不会打开断路器。这点和<code>Hystrix</code>是一样的。</p>
<p>断路器为了保证线程安全的措施是这样的：</p>
<ul>
<li>断路器的状态使用<code>AtomicReference</code>保存。</li>
<li>更新断路器的状态是通过无状态的函数或者原子操作进行的。</li>
<li>更新事件的状态在<code>synchronized</code>代码块中。</li>
</ul>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul>
<li><code>failureRateThreshold</code>：故障率百分比，超过这个值断路器打开。默认为<strong>50</strong>。</li>
<li><code>ringBufferSizeInHalfOpenState</code>：断路器半开状态时缓冲区的大小，假设为<code>10</code>则每次只允许最多<code>10</code>个请求调用服务。默认为<strong>10</strong>。</li>
<li><code>ringBufferSizeInClosedState</code>：断路器关闭状态时缓冲区的大小，不会限制并发量，所有请求都可以通过。默认为<strong>100</strong>。</li>
<li><code>waitDurationInOpenState</code>：断路器从打开状态变为半开状态等待的时间。默认为<strong>60s</strong>。</li>
<li><code>automaticTransitionFromOpenToHalfOpenEnabled</code>：是否允许断路器自动从打开状态变为半开状态。如果为<code>true</code>，等待时间结束后断路器会自动转变，否则需要一个请求触发断路器转变。默认为<strong>false</strong>。</li>
<li><code>recordExceptions</code>：需要记录为失败的异常列表。默认为<strong>空</strong>。</li>
<li><code>ignoreExceptions</code>：需要忽略的异常列表。默认为<strong>空</strong>。</li>
<li><code>recordFailure</code>：自定义的断言逻辑用于判断一个异常需要记录为异常还是忽略。默认<strong>所有异常都记录为失败</strong>。</li>
</ul>
<h5 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h5><p>在新版本中，<code>Resilience4j</code>弃用了环形缓冲区，改用<strong>滑动窗口</strong>记录请求状态。一共有<strong>基于数量的滑动窗口</strong>和<strong>基于时间的滑动窗口</strong>两种模式。</p>
<ul>
<li>基于数量：统计指定数量的请求，先进先出，计算失败率。查询失败率的时间复杂度为<code>O(1)</code>，空间复杂度为<code>O(n)</code>。</li>
<li>基于时间：滑动窗口包含<code>n</code>个桶，<code>n</code>为设置的时间秒数。分别计算每个桶的失败率，算出总数。该模式也是先进先出。查询失败率的时间、空间复杂度和基于数量的模式一致。</li>
</ul>
<p>相关的参数：</p>
<ul>
<li><code>slidingWindowType</code>：模式，<code>COUNT_BASED</code>或者<code>TIME_BASED</code>。默认为<strong>COUNT_BASED</strong>。</li>
<li><code>slidingWindowSize</code>：滑动窗口大小，默认为<strong>100</strong>。</li>
</ul>
<h5 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h5><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-circuitbreaker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 断路器</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配置信息</span></span><br><span class="line">    CircuitBreakerConfig config = CircuitBreakerConfig.custom()</span><br><span class="line">        .slidingWindowSize(<span class="number">2</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 创建断路器</span></span><br><span class="line">    CircuitBreaker breaker = CircuitBreaker.of(<span class="string">"test"</span>, config);</span><br><span class="line">    System.out.println(breaker.getState()); <span class="comment">// CLOSED</span></span><br><span class="line">    breaker.onError(<span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> RuntimeException());</span><br><span class="line">    System.out.println(breaker.getState()); <span class="comment">// CLOSED</span></span><br><span class="line">    breaker.onError(<span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> RuntimeException());</span><br><span class="line">    System.out.println(breaker.getState()); <span class="comment">// OPEN</span></span><br><span class="line">    <span class="comment">// 装饰器模式</span></span><br><span class="line">    CheckedFunction0&lt;String&gt; supplier = CircuitBreaker.decorateCheckedSupplier(breaker, () -&gt; <span class="string">"hello resilience4j"</span>);</span><br><span class="line">    Try&lt;String&gt; res = Try.of(supplier);</span><br><span class="line">    System.out.println(res.isSuccess()); <span class="comment">// false</span></span><br><span class="line">    System.out.println(res.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将滑动窗口大小设置为<code>2</code>，模拟两个请求发生异常，故障率达到了<code>100%</code>，这时断路器就会打开。最后一行将会报错，因为断路器已经打开，不再允许后续的请求。如果想要重置断路器的状态，调用<code>breaker.reset()</code>即可。</p>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p><code>Resilience4j</code>的<code>RateLimiter</code>一般用于服务端，用于限制对特定服务的并发请求数量。</p>
<h5 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h5><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-ratelimiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 限流</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RateLimiterConfig config = RateLimiterConfig.custom()</span><br><span class="line">        <span class="comment">// 每秒允许2次请求</span></span><br><span class="line">        .limitRefreshPeriod(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">        .limitForPeriod(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 限流之后冷却1秒</span></span><br><span class="line">        .timeoutDuration(Duration.ofSeconds(<span class="number">1</span>)).build();</span><br><span class="line">    RateLimiter rateLimiter = RateLimiter.of(<span class="string">"test"</span>, config);</span><br><span class="line">    CheckedRunnable runnable = RateLimiter.decorateCheckedRunnable(rateLimiter, () -&gt; System.out.println(<span class="keyword">new</span> Date()));</span><br><span class="line">    <span class="comment">// 发送4次请求</span></span><br><span class="line">    Try.run(runnable)</span><br><span class="line">        .andThenTry(runnable)</span><br><span class="line">        .andThenTry(runnable)</span><br><span class="line">        .andThenTry(runnable).onFailure(t -&gt; System.out.println(t.getMessage()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发现前两次请求在同一秒，后两次请求在下一秒，已经达到了限流的目的。</p>
<h4 id="请求重试"><a href="#请求重试" class="headerlink" title="请求重试"></a>请求重试</h4><p>网络的请求可能会失败，所以<code>Resilience4j</code>提供了请求重试的功能，在一定的限制范围内重复发送请求直到获取响应。</p>
<h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h5><ul>
<li><code>maxAttempts</code>：最大重试次数。默认为<strong>3</strong>。</li>
<li><code>waitDuration</code>：重试的间隔时间。默认为<strong>500ms</strong>。</li>
<li><code>retryExceptions</code>：需要记录为失败并重试的异常列表。默认为<strong>空</strong>。</li>
<li><code>ignoreExceptions</code>：需要忽略的异常列表。默认为<strong>空</strong>。</li>
</ul>
<h5 id="实战-3"><a href="#实战-3" class="headerlink" title="实战"></a>实战</h5><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求重试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RetryConfig config = RetryConfig.custom()</span><br><span class="line">        .maxAttempts(<span class="number">4</span>)</span><br><span class="line">        .waitDuration(Duration.ofMillis(<span class="number">500</span>))</span><br><span class="line">        .retryExceptions(RuntimeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        .<span class="title">build</span>()</span>;</span><br><span class="line">    Retry retry = Retry.of(<span class="string">"test"</span>, config);</span><br><span class="line">    Retry.decorateRunnable(retry, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt++ &lt; <span class="number">3</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发现测试通过，也就是说没有抛出<code>RuntimeException</code>异常。这是因为前<code>3</code>次请求都发生了异常，自动触发了重试。由于配置的最大重试次数为<code>4</code>，且第<code>4</code>次<code>cnt</code>已经不小于<code>3</code>了，所以不会抛出异常，测试通过。</p>
<h4 id="结合SpringBoot"><a href="#结合SpringBoot" class="headerlink" title="结合SpringBoot"></a>结合SpringBoot</h4><h5 id="断路器、重试"><a href="#断路器、重试" class="headerlink" title="断路器、重试"></a>断路器、重试</h5><p>添加依赖，排除不需要的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-spring-boot2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-bulkhead<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-timelimiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-ratelimiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">resilience4j</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:1111/eureka</span> <span class="comment"># 注册</span></span><br><span class="line"><span class="attr">resilience4j:</span></span><br><span class="line">  <span class="attr">retry:</span></span><br><span class="line">    <span class="attr">retry-aspect-order:</span> <span class="number">9</span> <span class="comment"># 优先级</span></span><br><span class="line">    <span class="attr">backends:</span></span><br><span class="line">      <span class="attr">retryA:</span> <span class="comment"># 实例名</span></span><br><span class="line">        <span class="attr">maxRetryAttempts:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">waitDuration:</span> <span class="number">500</span></span><br><span class="line">        <span class="attr">exponentialBackoffMultiplier:</span> <span class="number">1.1</span> <span class="comment"># 间隔乘数</span></span><br><span class="line">        <span class="attr">retryExceptions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">java.lang.RuntimeException</span></span><br><span class="line">  <span class="attr">circuitbreaker:</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="attr">breakerA:</span></span><br><span class="line">      	<span class="attr">slidingWindowType:</span> <span class="string">COUNT_BASED</span></span><br><span class="line">        <span class="attr">slidingWindowSize:</span> <span class="number">5</span></span><br><span class="line">        <span class="comment"># ringBufferSizeInClosedState: 5</span></span><br><span class="line">        <span class="comment"># ringBufferSizeInHalfOpenState: 5</span></span><br><span class="line">        <span class="attr">waitInterval:</span> <span class="number">5000</span></span><br><span class="line">    <span class="attr">circuit-breaker-aspect-order:</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>定义<code>service</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retry</span>(name = <span class="string">"retryA"</span>)</span><br><span class="line"><span class="meta">@CircuitBreaker</span>(name = <span class="string">"breakerA"</span>, fallbackMethod = <span class="string">"error"</span>)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRestTemplate</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://localhost:1113/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 参数必须包含Throwable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">error</span><span class="params">(String name, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error: "</span> + t.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>provider</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:5000/hello/XXX</code>可以看到类似<code>error: 500 : [{&quot;timestamp&quot;:&quot;2021-01-29T14:12:15.960+00:00&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;&quot;,&quot;path&quot;:&quot;/hello/test&quot;}]</code>。说明服务已经降级了。</p>
<p>将<code>provider</code>改写一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt++ &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + name + <span class="string">": "</span> + port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启访问发现服务可以正常调用了。这是因为访问可以重试<code>5</code>次，而该接口访问<code>3</code>次以后就不会发生异常了。</p>
<h5 id="限流-1"><a href="#限流-1" class="headerlink" title="限流"></a>限流</h5><p><code>RateLimiter</code>在服务端使用，保护服务端的接口。</p>
<p>在<code>provider</code>中添加<code>Resilience4j</code>依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-spring-boot2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-bulkhead<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-timelimiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-circuitbreaker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置<code>RateLimiter</code>，每秒允许一次请求，冷却时间为<code>1s</code>。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">resilience4j.ratelimiter.limiters.rlA.limit-for-period</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">resilience4j.ratelimiter.limiters.rlA.limit-refresh-period</span>=<span class="string">1s</span></span><br><span class="line"><span class="meta">resilience4j.ratelimiter.limiters.rlA.timeout-duration</span>=<span class="string">1s</span></span><br></pre></td></tr></table></figure>

<p><code>provider</code>的接口，添加<code>RateLimiter</code>注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="meta">@RateLimiter</span>(name = <span class="string">"rlA"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name + <span class="string">": "</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Resilience4j</code>的<code>service</code>接口中连续发送<code>5</code>次请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        restTemplate.getForObject(<span class="string">"http://localhost:1113/hello/"</span> + name, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启访问<code>localhost:5000/hello/XXX</code>，等待<code>5</code>秒后浏览器输出<code>success</code>。观察<code>provider</code>控制台的输出信息。</p>
<p><img src="ratelimiter.png" alt=""></p>
<p>每秒处理了一个请求。</p>
<h4 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h4><p>微服务架构下，由于服务数量大，因此出故障的概率很大。这时候就需要服务监控软件帮助我们运维。</p>
<p>在<code>SpringCloud Greenwich</code>版本中，官方建议使用<code>Micrometer</code>作为监控工具。</p>
<h5 id="Micrometer"><a href="#Micrometer" class="headerlink" title="Micrometer"></a>Micrometer</h5><p><code>Micrometer</code>主要提供以下三种功能：</p>
<ol>
<li><code>Micrometer</code>提供了度量指标类，例如<code>timers</code>、<code>gauges</code>以及<code>counters</code>等。</li>
<li>一揽子开箱即用的解决方案，例如缓存、类加载器、垃圾收集、处理器利用率以及线程池等等。</li>
<li>在早期的<code>SpringBoot</code>版本中，需要通过手动添加依赖来使用<code>Micrometer</code>。从<code>SpringBoot 2.0</code>开始， 在<code>Spring Boot Actuator</code>中使用了<code>Micrometer</code>。</li>
</ol>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该依赖中已经包含<code>Micrometer</code>的<code>jar</code>包。</p>
<p>添加配置信息，暴露所有端点。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure>

<p>运行项目，在<code>Endpoints</code>可以看到所有暴露的端点地址，通过浏览器可以直接访问。</p>
<p><img src="micrometer.png" alt=""></p>
<p>但是由于返回的数据都是<code>JSON</code>的格式，不利于分析，所以需要一个可视化的工具。</p>
<h5 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h5><p><code>Prometheus</code>是<code>SpringCloud</code>使用<code>GO</code>语言开发的一款开源的监控报警系统和时序列数据库。</p>
<h6 id="实战-4"><a href="#实战-4" class="headerlink" title="实战"></a>实战</h6><p>首先到<code>github</code><a href="https://github.com/prometheus/prometheus" target="_blank" rel="noopener">下载</a><code>prometheus</code>，解压。进入主目录，编辑<code>prometheus.yml</code>：</p>
<p><img src="prometheus%E9%85%8D%E7%BD%AE.png" alt=""></p>
<p>在之前<code>Micrometer</code>的项目中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br><span class="line"><span class="meta">management.endpoint.prometheus.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">management.endpoint.metrics.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>启动项目访问<code>localhost:8080/actuator/prometheus</code>即可看到数据。然后通过<code>./prometheus --config.file=prometheus.yml</code>启动<code>prometheus</code>。访问<code>localhost:9090</code>就可以看到可视化页面了。</p>
<p>我们还可以利用<code>Grafana</code>配合<code>Prometheus</code>达到更好的监控效果。</p>
<h5 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h5><p><code>Grafana</code>是一款<code>Go</code>语言开发的开源数据可视化工具，提供数据监控、数据统计以及报警等功能。</p>
<h6 id="实战-5"><a href="#实战-5" class="headerlink" title="实战"></a>实战</h6><p>首先去官网<a href="Grafana是一款用Go语言开发的开源数据可视化工具，可以做数据监控和数据统计，带有告警功能。">下载</a><code>Grafana</code>，根据平台安装并启动<code>grafana-server</code>。默认端口为<code>3000</code>。访问<code>localhost:3000</code>进入登录页面，默认用户名和密码都是<code>admin</code>。修改密码进入主页面，添加数据源<code>(add data source)</code>，选择<code>prometheus</code>。然后添加仪表盘<code>dashboard</code>。最后在<code>Enter a PromQL query</code>输入框输入要查询的数据即可在上方显示出监控。</p>
<p><img src="grafana.png" alt=""></p>
<hr>
<h3 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h3><p>在微服务架构中，每个服务的地址都有可能发生变化，无法直接对外公布地址。考虑安全以及高内聚低耦合的设计，有必要将内部系统和外部系统切割开。服务网关就是专门用来处理外部请求的组件，主要有以下功能：</p>
<ul>
<li>权限问题统一处理</li>
<li>数据裁剪和聚合</li>
<li>简化客户端的调用</li>
<li>针对不同的客户端提供不同的网关支持</li>
</ul>
<p>在<code>SpringCloud</code>中，网关主要有两种实现方案：</p>
<ul>
<li><code>Zuul</code></li>
<li><code>Spring Cloud Gateway</code></li>
</ul>
<h4 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h4><p><code>Zuul</code>是<code>Netflix</code>公司开发的网关服务组件。主要有以下功能：</p>
<ul>
<li>权限控制</li>
<li>监控</li>
<li>动态路由</li>
<li>负载均衡</li>
<li>静态资源处理</li>
</ul>
<p><code>Zuul</code>的功能基本都是基于过滤器实现的，过滤器有几种不同的类型：</p>
<ul>
<li><code>PRE</code>：请求进入<code>Zuul</code>后，立刻进行过滤。</li>
<li><code>ROUTING</code>：请求进入<code>Zuul</code>并且路由过后进行过滤。</li>
<li><code>POST</code>：远程服务调用结束后进行过滤。</li>
<li><code>ERROR</code>：过滤器发生异常或者远程服务调用超时的时候进行过滤。</li>
</ul>
<h5 id="实战-6"><a href="#实战-6" class="headerlink" title="实战"></a>实战</h5><p>新建<code>SpringBoot</code>工程，添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件，注册到<code>Eureka</code>上。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">zuul</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">2020</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:1111/eureka</span></span><br></pre></td></tr></table></figure>

<p>在项目启动类添加<code>@EnableZuulProxy</code>注解开启网关代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动<code>eureka</code>、<code>provider</code>和<code>zuul</code>。这时可以通过<code>localhost:2020/provider/hello/XXX</code>访问<code>localhost:1113/hello/XXX</code>的服务接口，说明路由已经生效。如果不想使用默认的服务名，而是自定义配置路由规则也是可以的：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.test.path</span>=<span class="string">/test/**</span></span><br><span class="line"><span class="meta">zuul.routes.test.service-id</span>=<span class="string">provider</span></span><br></pre></td></tr></table></figure>

<p>意思是满足<code>/test/**</code>的请求地址都会被转发到<code>provider</code>上。这时通过<code>localhost:2020/test/hello/XXX</code>也可正常访问服务。这两行配置也可以简化为<code>zuul.routes.provider=/test/**</code>。</p>
<h5 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h5><p>对于来自客户端的请求，可以在<code>Zuul</code>中进行预处理，例如权限校验。</p>
<p>首先自定义一个类，继承于<code>ZuulFilter</code>抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 过滤器类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 优先级</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 是否过滤</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 具体过滤逻辑，返回值可以忽略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = context.getRequest();</span><br><span class="line">        String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"test"</span>.equals(username) || !<span class="string">"123"</span>.equals(password)) &#123;</span><br><span class="line">            context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            context.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            context.addZuulResponseHeader(<span class="string">"content-type"</span>, <span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">            context.setResponseBody(<span class="string">"无权限访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启访问<code>localhost:2020/test/hello/XXX?username=test&amp;password=123</code>发现可以访问到<code>provider</code>的服务，如果将<code>username</code>或者<code>password</code>的值改了或者不带参数则会显示<code>无权限访问</code>，说明过滤器生效了。</p>
<h5 id="忽略路径"><a href="#忽略路径" class="headerlink" title="忽略路径"></a>忽略路径</h5><p>默认情况下，<code>Zuul</code>的所有服务都会被自动代理。如果不想给某个服务做代理，可以配置忽略该服务。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.ignored-services</span>=<span class="string">provider</span></span><br></pre></td></tr></table></figure>

<p>意思是忽略<code>provider</code>服务。这时再访问<code>localhost:2020/provider/hello/XXX</code>会报<code>404</code>错误。还可以忽略某一类的路径：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.ignored-patterns</span>=<span class="string">/**/hello/**</span></span><br></pre></td></tr></table></figure>

<p>表示如果请求的地址包含<code>hello</code>，则不会被代理。</p>
<h5 id="请求前缀"><a href="#请求前缀" class="headerlink" title="请求前缀"></a>请求前缀</h5><p>不仅可以忽略路径，还可以给请求路径加上一个统一的前缀。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.prefix</span>=<span class="string">/prefix</span></span><br></pre></td></tr></table></figure>

<p>这样，所有的请求地址都要在前面加上<code>/prefix</code>。</p>
<h4 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h4><p><code>Spring Cloud Gateway</code>是基于<code>Spring 5.0</code>，<code>Spring Boot 2.0</code>和<code>Project Reactor</code>等技术开发的服务网关，旨在为微服务架构提供简单的、有效的、统一的<code>API</code>路由管理方式。目的是替代<code>Zuul</code>。<code>Spring Cloud Gateway</code>底层使用了高性能的通信框架<code>Netty</code>。</p>
<p><code>Spring Cloud Gateway</code>的主要功能如下：</p>
<ul>
<li>限流</li>
<li>路径重写</li>
<li>动态路由</li>
<li>集成<code>Spring Cloud DiscoveryClient</code></li>
<li>集成<code>Hystrix</code>断路器</li>
</ul>
<p>和<code>Zuul</code>的区别：</p>
<ul>
<li><code>Zuul</code>是<code>Netflix</code>的产品，而<code>Spring Cloud Gateway</code>是<code>Spring</code>的产品，所以可以更好的兼容<code>Spring</code>的其他产品。</li>
<li><code>Zuul1</code>不支持长连接，<code>Spring Cloud Gateway</code>支持。</li>
<li><code>Spring Cloud Gateway</code>支持限流。</li>
<li><code>Zuul1</code>采用的是阻塞和多线程的方式实现的，每个线程处理一个连接请求，<code>Spring Cloud Gateway</code>底层使用的是<code>Netty</code>，实现了异步和非阻塞，占用的资源更小，性能更强。</li>
</ul>
<h5 id="实战-7"><a href="#实战-7" class="headerlink" title="实战"></a>实战</h5><p>首先添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启自动代理</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.discovery.locator.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 注册</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">gateway</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:1111/eureka</span></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.cloud.gateway</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:8080/hello/XXX</code>可以正常调用服务。</p>
<h5 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h5><p><code>Predicate</code>是<code>Java 8</code>引入的一个函数，接收一个参数，返回<code>Boolean</code>值。<code>Spring Cloud Gateway</code>利用<code>Predicate</code>的特性实现了各种路由匹配的规则：</p>
<p><img src="gateway_predicate.png" alt=""></p>
<h6 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h6><table>
<thead>
<tr>
<th align="left">规则</th>
<th align="left">实例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Path</code></td>
<td align="left"><code>Path=/user/**</code></td>
<td>请求路径以<code>user</code>开头时，会转发到<code>uri</code>上。</td>
</tr>
<tr>
<td align="left"><code>Before</code></td>
<td align="left"><code>Before=2021-01-30T17:30:30+08:00[Asia/Shanghai]</code></td>
<td>在这个时间点之前的请求才会被转发</td>
</tr>
<tr>
<td align="left"><code>After</code></td>
<td align="left"><code>After=2021-01-30T17:30:30+08:00[Asia/Shanghai]</code></td>
<td>在这个时间点之后的请求才会被转发</td>
</tr>
<tr>
<td align="left"><code>Between</code></td>
<td align="left"><code>Between=2021-01-30T17:30:30+08:00[Asia/Shanghai],2021-01-30T17:40:30+08:00[Asia/Shanghai]</code></td>
<td>在这个时间段之间的请求才会被转发</td>
</tr>
<tr>
<td align="left"><code>Cookie</code></td>
<td align="left"><code>Cookie=test*</code></td>
<td>名字满足正则<code>test*</code>的表单才会被请求转发</td>
</tr>
<tr>
<td align="left"><code>Header</code></td>
<td align="left"><code>Header=test*</code></td>
<td>携带参数满足正则<code>test*</code>的请求头才会被转发</td>
</tr>
<tr>
<td align="left"><code>Host</code></td>
<td align="left"><code>Host=www.irvlin.xyz</code></td>
<td>主机名为<code>www.irvlin.xyz</code>的请求才会被转发</td>
</tr>
<tr>
<td align="left"><code>Method</code></td>
<td align="left"><code>Method=GET</code></td>
<td><code>GET</code>请求才会被转发</td>
</tr>
<tr>
<td align="left"><code>Query</code></td>
<td align="left"><code>Query=username,test*</code></td>
<td>路径中包含<code>username</code>参数并且值以<code>test</code>开头的请求才会被转发。如果规则没有指定值则值没有要求。</td>
</tr>
</tbody></table>
<h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><h6 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h6><p><code>Spring Cloud Gateway</code>和<code>Zuul</code>类似，有<code>PRE</code>和<code>POST</code>两种<code>filter</code>。客户端的请求先经过<code>PRE</code>类型的过滤器，将请求转发到具体服务，收到响应之后，再经过<code>POST</code>类型的过滤器，返回响应给客户端。</p>
<p><code>Spring Cloud Gateway</code>的过滤器按照作用来分可分为两类：</p>
<ul>
<li><code>GatewayFilter</code>：针对单个路由。</li>
<li><code>GlobalFilter</code>：针对所有路由。</li>
</ul>
<h6 id="GatewayFilter"><a href="#GatewayFilter" class="headerlink" title="GatewayFilter"></a>GatewayFilter</h6><p><code>Spring Cloud Gateway</code>包含很多内置的<code>GatewayFilter</code>工厂。</p>
<p><img src="gatewayfilter.png" alt=""></p>
<p>例如，在配置文件中添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.gateway.routes[0].filters[0]</span>=<span class="string">AddRequestParameter=name,test</span></span><br></pre></td></tr></table></figure>

<p>相当于给请求添加了<code>name</code>参数，值为<code>test</code>。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.gateway.routes[0].filters[0]</span>=<span class="string">PrefixPath=/app</span></span><br></pre></td></tr></table></figure>

<p>相当于给请求增加了前缀<code>/app</code>。</p>
<h6 id="GlobalFilter"><a href="#GlobalFilter" class="headerlink" title="GlobalFilter"></a>GlobalFilter</h6><p><code>Spring Cloud Gateway</code>内置的<code>GlobalFilter</code>工厂：</p>
<p><img src="globalfilter.png" alt=""></p>
<p>添加配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.gateway.routes[0].id</span>=<span class="string">test</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[0].uri</span>=<span class="string">lb://provider</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[0].predicates[0]</span>=<span class="string">Method=GET</span></span><br></pre></td></tr></table></figure>

<p><code>lb://provider</code>开启了负载均衡。如果<code>provider</code>是集群化部署的，访问服务时将使用线性负载均衡的方式。</p>
<hr>
<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><code>Spring Cloud Config</code>是一个分布式系统配置管理的解决方案，包含了<code>server</code>和<code>client</code>。配置文件放在<code>server</code>，通过接口的形式提供给<code>client</code>。</p>
<p><code>Spring Cloud Config</code>主要有以下几个功能：</p>
<ul>
<li>集中管理各个环境、各个微服务的配置文件。</li>
<li>提供服务端和客户端支持。</li>
<li>配置文件修改之后，可以快速生效。</li>
<li>配置文件通过<code>GIT</code>或者<code>SVN</code>管理，支持版本回退。</li>
<li>支持高并发查询。</li>
<li>支持多种开发语言。</li>
</ul>
<h4 id="实战-8"><a href="#实战-8" class="headerlink" title="实战"></a>实战</h4><p>首先创建一个目录，在该目录下创建三个配置文件<code>client1-dev.properties</code>、<code>client1-prod.properties</code>、<code>client1-test.properties</code>，分别用于开发环境、生产环境和测试环境。文件内容分别是：<code>env=dev</code>、<code>env=prod</code>、<code>env=test</code>。</p>
<p>在<code>github</code>上创建一个新仓库，名字随意。将三个配置文件<code>push</code>到仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git commit -m "first commit"</span><br><span class="line">git remote add origin https://github.com/IRVLIN/configRepo.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>创建<code>config-server</code>项目，添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在启动类添加注解<code>@EnableConfigServer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">config-server</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="comment"># github地址</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.uri</span>=<span class="string">https://github.com/IRVLIN/configRepo.git</span></span><br><span class="line"><span class="comment"># 仓库中的目录</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.search-paths</span>=<span class="string">client1</span></span><br><span class="line"><span class="comment"># 如果仓库是私有的</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.username</span>=<span class="string">1203710288@qq.com</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>运行，访问<code>localhost:8081/client1/dev/master</code>就可以看到信息了。访问的地址是有规则的：<code>/{application}/{profile}/{label}</code>。<code>application</code>表示配置的文件名，<code>profile</code>表示配置文件<code>profile</code>，例如<code>prod</code>、<code>dev</code>，<code>label</code>表示<code>git</code>的分支，默认为<code>master</code>。除了这种方式，还可以直接访问<code>localhost:8081/master/client1-dev.yml</code>或者<code>localhost:8081/master/client1-dev.properties</code>。</p>
<p>修改任意配置文件内容，<code>push</code>到<code>github</code>仓库，再次访问接口可以看到内容实时刷新了。</p>
<h4 id="config-client"><a href="#config-client" class="headerlink" title="config-client"></a>config-client</h4><p>创建<code>bootstrap.properties</code>。这里要说一下<code>bootstrap.properties</code>和<code>application.properties</code>的区别。</p>
<ul>
<li><code>bootstrap.properties</code>先加载。</li>
<li><code>bootstrap.properties</code>用于应用程序上下文的引导阶段，<code>application.properties</code>由<code>ApplicationContext</code>加载。</li>
<li><code>bootstrap.properties</code>配置系统级别的参数，一般是不会变的，而<code>application.properties</code>用来配置应用级别的参数。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面三行配置分别对应config-server中的&#123;application&#125;、&#123;profile&#125;以及&#123;label&#125;</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">client1</span></span><br><span class="line"><span class="meta">spring.cloud.config.profile</span>=<span class="string">test</span></span><br><span class="line"><span class="meta">spring.cloud.config.label</span>=<span class="string">master</span></span><br><span class="line"><span class="comment"># config-server地址</span></span><br><span class="line"><span class="meta">spring.cloud.config.uri</span>=<span class="string">http://localhost:8081</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8082</span></span><br></pre></td></tr></table></figure>

<p><code>controller</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 配置文件中的key</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;env&#125;"</span>)</span><br><span class="line">    String env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> env;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动<code>config-client</code>，访问<code>localhost:8082/hello</code>就可以看到配置文件中的值<code>test</code>了。</p>
<p>除了将配置文件<code>push</code>到远程仓库中，还可以放在项目的<code>classpath</code>下，同时添加一条配置信息：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 让config-server从classpath下查找配置文件</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">native</span></span><br></pre></td></tr></table></figure>

<p>还可以以指定配置文件的位置的方式</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.server.native.search-locations</span>=<span class="string">配置文件路径</span></span><br></pre></td></tr></table></figure>

<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p>前面配置<code>config-server</code>的目录时我们直接写死了，实际上可以使用占位符更灵活的使用，这样可以根据不同的<code>client</code>获取不同的配置文件。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.server.git.search-paths</span>=<span class="string">&#123;application&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>由于配置文件的内容是比较敏感的，所以有必要进行加密。这里有对称加密和非对称加密两种方式。</p>
<h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p><code>Java Cryptography Extension (JCE)</code>是<code>Java</code>正式发布的标准加密扩展，提供了用于加密、密钥生成和密钥协商以及消息身份验证代码算法的框架和实现。</p>
<p>首先去<code>Oracle</code>下载不限长度的<code>JCE</code>，将解压后的文件放到<code>Java</code>安装目录下：<code>$JAVA_HOME/lib/security</code>。</p>
<p>在<code>config-server</code>中创建<code>bootstrap.properties</code>。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 密钥</span></span><br><span class="line"><span class="meta">encrypt.key</span>=<span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>重启<code>config-server</code>，发送<code>POST</code>请求到<code>localhost:8081/encrypt</code>带上要加密的字符串，假设为<code>dev</code>。</p>
<p><img src="encrypt.png" alt=""></p>
<p>修改配置文件，这里以<code>client1-dev.properties</code>为例：<code>env={ciper}740791531899d6f23f96c9d44da3877f0a3a18e58427badbcd4439255cde535f</code>。这里要添加<code>{ciper}</code>前缀表示这是一个加密后的字符串。重新<code>push</code>到仓库。重启<code>config-client</code>访问<code>http://localhost:8082/hello</code>显示<code>dev</code>。</p>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>首先要生成一个密钥对。在命令行执行命令：<code>keytool -genkeypair -alias config-server -keyalg RSA -keystore ./config-server.keystore</code>生成<code>keystore</code>。将这个文件移动到<code>config-server</code>的<code>resources</code>目录下。</p>
<p>修改<code>config-server</code>的<code>bootstrap.properties</code>：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释掉下面一行</span></span><br><span class="line"><span class="comment"># encrypt.key=IRvLin</span></span><br><span class="line"><span class="meta">encrypt.key-store.location</span>=<span class="string">config-server.keystore</span></span><br><span class="line"><span class="meta">encrypt.key-store.alias</span>=<span class="string">mytestkey</span></span><br><span class="line"><span class="comment"># 生成keystore时填写的密码</span></span><br><span class="line"><span class="meta">encrypt.key-store.password</span>=<span class="string">testtest</span></span><br><span class="line"><span class="meta">encrypt.key-store.secret</span>=<span class="string">testtest</span></span><br></pre></td></tr></table></figure>

<p>重启<code>config-server</code>，再次加密字符串<code>dev</code>，更新配置文件上传到<code>github</code>。重启<code>config-client</code>访问<code>localhost:8082/hello</code>同样可以显示<code>dev</code>。</p>
<h4 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h4><p>目前所有配置文件都可以直接通过访问<code>config-server</code>获取内容，这是不安全的。所以我们可以利用<code>Spring Security</code>进行权限管理。</p>
<p>首先添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>config-server</code>和<code>config-client</code>的<code>bootstrap.properties</code>中添加：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.security.user.name</span>=<span class="string">irvlin</span></span><br><span class="line"><span class="meta">spring.security.user.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure>

<h4 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h4><p>之前的<code>config</code>都没有注册到注册中心，所以现在要将它们注册到服务中心。</p>
<p>首先给<code>server</code>和<code>client</code>都添加<code>Eureka</code>依赖，并注册到<code>Eureka</code>：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:1111/eureka</span></span><br></pre></td></tr></table></figure>

<p>修改<code>client</code>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释下面这行，不直接写死config-server的地址</span></span><br><span class="line"><span class="comment"># spring.cloud.config.uri=http://localhost:8081</span></span><br><span class="line"><span class="comment"># 添加下面两行，通过eureka获取config-server</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.service-id</span>=<span class="string">config-server</span></span><br></pre></td></tr></table></figure>

<p>全部重启访问<code>localhost:8082/hello</code>可以看到<code>dev</code>，说明服务化改造成功了。</p>
<h4 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h4><p>目前当配置文件刷新时，要重启<code>client</code>才能看到最新的内容，这明显是不合理的。</p>
<p>我们有两种方案：</p>
<p>首先在<code>client</code>添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>暴露<code>refresh</code>端点：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">refresh</span></span><br></pre></td></tr></table></figure>

<p>在<code>controller</code>添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;env&#125;"</span>)</span><br><span class="line">    String env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> env;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，配置文件改变后，只要调用<code>refresh</code>端点，比如发送<code>POST</code>请求到<code>localhost:8082/actuator/refresh</code>就可以刷新得到最新的内容。</p>
<h4 id="请求重试-1"><a href="#请求重试-1" class="headerlink" title="请求重试"></a>请求重试</h4><p><code>config-client</code>调用<code>config-server</code>时有可能请求失败，所以可以配置一个请求重试的功能。</p>
<p>首先添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速失败</span></span><br><span class="line"><span class="meta">spring.cloud.config.fail-fast</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 初始间隔时间，默认为1000ms</span></span><br><span class="line"><span class="meta">spring.cloud.config.retry.initial-interval</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"># 最大重试次数，默认为6</span></span><br><span class="line"><span class="meta">spring.cloud.config.retry.max-attempts</span>=<span class="string">6</span></span><br><span class="line"><span class="comment"># 间隔乘数，默认为1.1</span></span><br><span class="line"><span class="meta">spring.cloud.config.retry.multiplier</span>=<span class="string">1.1</span></span><br><span class="line"><span class="comment"># 最大间隔时间，默认为2000ms</span></span><br><span class="line"><span class="meta">spring.cloud.config.retry.max-interval</span>=<span class="string">2000</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><p><code>Spring Cloud Bus</code>通过轻量级的消息代理连接各个微服务，可以用来广播配置文件的更改，例如前面的<code>config-server</code>和<code>config-client</code>，或者其他管理指令。<code>Spring Cloud Bus</code>就像一个扩展的<code>SpringBoot</code>应用程序的分布式执行器，但也可以用作应用程序之间的通信渠道。当前唯一的实现是使用<code>AMQP</code>代理作为传输。</p>
<p>首先安装<code>RabbitMQ</code>。给<code>server</code>和<code>client</code>添加依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于<code>config-server</code>要提供刷新的接口，所以给<code>config-server</code>加上<code>actuator</code>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>给<code>server</code>和<code>client</code>的<code>bootstrap.properties</code>配置<code>RabbitMQ</code>信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br></pre></td></tr></table></figure>

<p>由于之前给<code>config-server</code>配置了<code>Spring Security</code>，所有接口都需要登录才能访问，所以要修改配置，修改端点的权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 开启httpBasic认证，发送刷新请求时可以直接通过HttpBasic配置认证信息。</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在<code>server</code>的<code>application.properties</code>添加配置信息暴露<code>bus-refresh</code>端点。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">bus-refresh</span></span><br></pre></td></tr></table></figure>

<p>测试：随意修改配置文件的值，提交到仓库。这时发送一个<code>POST</code>请求到<code>localhost:8081/actuator/bus-refresh</code>，认证方式选择<code>Basic Auth</code>，输入之前<code>Spring Security</code>配置的用户名密码。如果返回为空证明请求成功。这时再刷新<code>localhost:8082/hello</code>就可以看到最新的值了。</p>
<p>这种方式是通过发送一个<code>POST</code>请求到<code>config-server</code>，<code>config-server</code>会发送一条刷新的消息到<code>RabbitMQ</code>，<code>RabbitMQ</code>会创建一个<code>topic</code>类型的交换机和两个匿名<code>Queue</code>，把消息发送给所有连接到<code>config-server</code>的<code>config-client</code>，所以无论有多少个<code>client</code>都会同步更新。</p>
<h4 id="逐个刷新"><a href="#逐个刷新" class="headerlink" title="逐个刷新"></a>逐个刷新</h4><p>我们更新了某些微服务的配置文件，如果按照上面的方式，所有微服务都会刷新配置文件，这其实是没有必要的。</p>
<p>首先给每个<code>config-client</code>配置一个实例<code>id</code>：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">eureka.instance.instance-id</span>=<span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></span><br></pre></td></tr></table></figure>

<p>打包启动两个实例，假设端口为<code>8082</code>和<code>8083</code>。</p>
<p>假设我们只想更新<code>8082</code>的实例，只需要在<code>POST</code>请求加参数就可以了：<code>localhost:8081/actuator/bus-refresh/client1:8082</code>。</p>
<hr>
<h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><code>Spring Cloud Stream</code>用于构建高度可扩展的基于事件驱动的微服务。</p>
<p><code>Spring Cloud Stream</code>提供了一个应用程序和消息中间件之间的粘合剂<code>binder</code>。<code>binder</code>负责与消息中间件交互，而开发者使用<code>inputs</code>、<code>outputs</code>消息通道和<code>binder</code>进行交互。<code>binder</code>对于应用程序来说起到了隔离的作用。如果没有<code>binder</code>，应用程序要和消息中间件交互时，由于各个消息中间件的实现不同，使得我们实现交互的逻辑非常笨重，如果消息中间件有比较大的变更，那么代码也需要比较大的变动。使用<code>binder</code>，通过向应用程序暴露统一的<code>channel</code>通道，使用者不再需要关注不同底层消息中间件的通信逻辑，如果要要更改中间件时，只需要更换<code>binder</code>即可，让开发者更加关注业务逻辑的实现。</p>
<p><img src="binder.png" alt=""></p>
<h4 id="实战-9"><a href="#实战-9" class="headerlink" title="实战"></a>实战</h4><p>新建一个项目，添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rabbitmq配置</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br></pre></td></tr></table></figure>

<p>定义一个消息接收器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定Sink消息通道</span></span><br><span class="line"><span class="meta">@EnableBinding</span>(Sink<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MsgReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MsgReceiver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="comment">// 监听该通道</span></span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Received: "</span> + payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Sink</code>是内置的消息通道</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Input channel name.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String INPUT = <span class="string">"input"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> input channel.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Input</span>(Sink.INPUT)</span><br><span class="line">	<span class="function">SubscribableChannel <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，登录<code>rabbitmq</code>会发现有一个匿名队列，进入并发送一条消息<code>hello Stream</code>，可以看到日志会输出类似<code>Received: hello stream</code>的信息。</p>
<p>除了使用内置的消息通道，还可以使用自定义的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyChannel</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从F版开始，默认使用通道的名字作为实例名，所以两个消息通道的名字不能一样</span></span><br><span class="line">    String INPUT = <span class="string">"test-input"</span>;</span><br><span class="line">    String OUTPUT = <span class="string">"test-output"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Output</span>(OUTPUT)</span><br><span class="line">    <span class="function">MessageChannel <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Input</span>(INPUT)</span><br><span class="line">    <span class="function">SubscribableChannel <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义消息接收器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(MyChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MsgReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MsgReceiver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener</span>(MyChannel.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Received: "</span> + payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个<code>controller</code>发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyChannel myChannel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyChannel</span><span class="params">(MyChannel myChannel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myChannel = myChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myChannel.output().send(MessageBuilder.withPayload(<span class="string">"hello spring cloud stream"</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件，让输入输出通道对接。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 值要一样</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.test-input.destination</span>=<span class="string">test.topic</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.test-output.destination</span>=<span class="string">test.topic</span></span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:8080/hello</code>发送消息，可以看到日志的输出。</p>
<h5 id="消息分组"><a href="#消息分组" class="headerlink" title="消息分组"></a>消息分组</h5><p>默认情况下，如果消费者是集群部署的，一条消息会被多次消费。消息分组可以解决这个问题。</p>
<p>添加配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给binder分组</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.test-input.group</span>=<span class="string">group1</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.test-output.group</span>=<span class="string">group1</span></span><br></pre></td></tr></table></figure>

<p>启动两个实例，发送消息发现只有一个实例收到了。</p>
<h5 id="消息分区"><a href="#消息分区" class="headerlink" title="消息分区"></a>消息分区</h5><p>使用消息分区可以保证一条消息只被一个消费者消费，但是不能确保是哪个。有时候我们希望具有相同特征的消息被同一个消费者消费，例如要进行用户数据的统计，这时就可以使用消息分区。</p>
<p>添加配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启消息分区（配置在消费者端）</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.test-input.consumer.partitioned</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 消费者实例个数（配置在消费者端）</span></span><br><span class="line"><span class="meta">spring.cloud.stream.instance-count</span>=<span class="string">2</span></span><br><span class="line"><span class="comment"># 当前实例下标（配置在消费者端）,启动时动态修改</span></span><br><span class="line"><span class="meta">spring.cloud.stream.instance-index</span>=<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 被下标为1的消费者消费（配置在生产者端），启动时动态修改</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.test-output.producer.partition-key-expression</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 消费者实例个数（配置在生产者端）</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.test-output.producer.partition-count</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure>

<h5 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h5><p>定时任务有很多实现方式。假设是定期要定时执行的任务，可以使用<code>cron</code>表达式。还有一种比较特殊的定时任务，例如指定几分钟后执行，这可以利用<code>Spring Cloud Stream + RabbitMQ</code>实现。</p>
<p>首先下载一个消息延迟插件：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" target="_blank" rel="noopener">链接</a>，版本要和<code>RabbitMQ</code>相对应。将解压后的文件放到<code>RabbitMQ</code>的<code>plugins</code>目录下。通过命令<code>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code>启动该插件，如果有输出<code>started 1 plugins.</code>说明启动成功。</p>
<p>添加配置信息，开启消息延迟功能。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入输出通道destination改为delay_msg</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.test-input.destination</span>=<span class="string">delay_msg</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.test-output.destination</span>=<span class="string">delay_msg</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.stream.rabbit.bindings.irvlin-input.consumer.delayed-exchange</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.stream.rabbit.bindings.irvlin-output.producer.delayed-exchange</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>改写<code>controller</code>和<code>receiver</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> MyChannel myChannel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyChannel</span><span class="params">(MyChannel myChannel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myChannel = myChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"send msg: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="comment">// 延迟3秒发送消息</span></span><br><span class="line">        myChannel.output().send(MessageBuilder.withPayload(<span class="string">"hello spring cloud stream"</span>).setHeader(<span class="string">"x-delay"</span>, <span class="number">3000</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(MyChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MsgReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MsgReceiver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener</span>(MyChannel.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Received: "</span> + payload + <span class="string">" "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启访问<code>localhost:8080/hello</code>发送消息。消费者三秒之后收到了消息，达到了定时的效果。</p>
<p><img src="delayed_message.png" alt=""></p>
<hr>
<h3 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>一个大型的分布式系统，是由非常多微服务组成的，每个服务可能部署在不同的机器上，此时如果服务出现问题，想要定位故障就很麻烦。</p>
<p>在微服务架构中，客户端发起一次请求，可能会引起几十甚至几百次服务之间的调用。如果服务出现了故障，我们需要考虑很多问题：</p>
<ul>
<li>如何快速定位问题？</li>
<li>如何快速确定本次调用都涉及哪些服务？</li>
<li>如何快速定位是哪个服务出现了问题？</li>
</ul>
<p>为了解决以上问题，引入了分布式链路追踪。分布式链路追踪系统主要用来跟踪服务调用记录，一般来说一个分布式链路追踪系统由三部分组成：</p>
<ul>
<li>数据收集</li>
<li>数据存储</li>
<li>数据展示</li>
</ul>
<p><code>Spring Cloud Sleuth</code>是<code>SpringCloud</code>提供的一套分布式链路追踪系统，主要有以下几个概念：</p>
<ul>
<li><code>trace</code>：从请求到达系统开始，到给请求做出响应为止的一个过程称为<code>trace</code>。</li>
<li><code>span</code>：每次调用服务埋入的一个调用的记录称为<code>span</code>。</li>
<li><code>annotation</code>：相当于<code>span</code>的语法，描述<code>span</code>所处的状态。</li>
</ul>
<h4 id="实战-10"><a href="#实战-10" class="headerlink" title="实战"></a>实战</h4><p>创建工程，添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">test-sleuth</span></span><br></pre></td></tr></table></figure>

<p><code>controller</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(HelloController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRestTemplate</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"hello spring cloud sleuth"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello spring cloud sleuth"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:8080/hello</code>可以看到控制台的输出<code>INFO [test-sleuth,83534632bca0923e,83534632bca0923e] 7721 --- [nio-8080-exec-1] xyz.irvlin.sleuth.HelloController        : hello spring cloud sleuth</code>。<code>[test-sleuth,83534632bca0923e,83534632bca0923e]</code>分别表示<code>[applicationName,traceId,spanId]</code>。</p>
<p>接下来再定义两个方法形成一条调用链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"hello2"</span>);</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://localhost:8080/hello3"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello3"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"hello3"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello3"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:8080/hello2</code>显示<code>hello3</code>。查看控制台日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2021-02-01 20:51:12.434  INFO [test-sleuth,7c3f7a84cf0bb191,7c3f7a84cf0bb191] 7721 --- [nio-8080-exec-4] xyz.irvlin.sleuth.HelloController        : hello2</span><br><span class="line">2021-02-01 20:51:12.468  INFO [test-sleuth,7c3f7a84cf0bb191,01d954d69ca89b1a] 7721 --- [nio-8080-exec-5] xyz.irvlin.sleuth.HelloController        : hello3</span><br></pre></td></tr></table></figure>

<p>两个请求的<code>spanId</code>不同，<code>traceId</code>相同。</p>
<hr>
<h3 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a>Zipkin</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p><code>Zipkin</code>是<code>Twitter</code>公司开源的一款分布式实时数据追踪系统，其主要功能是聚合来自各个异构系统的实时监控数据。在链路追踪<code>Tracing Analysis</code>中，可以通过<code>Zipkin</code>上报<code>Java</code>应用的数据。</p>
<p><code>Zipkin</code>分为<code>server</code>和<code>client</code>。<code>server</code>端用于展示数据，<code>client</code>端用于收集、上报数据。</p>
<h4 id="实战-11"><a href="#实战-11" class="headerlink" title="实战"></a>实战</h4><p><code>Zipkin</code>需要存储数据，这里使用<code>elasticsearch</code>作为数据库。</p>
<p>首先用<code>docker</code>安装<code>elasticsearch</code>：<code>docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</code>。然后安装<code>zipkin</code>：<code>docker run -d -p 9411:9411 --name zipkin -e ES_HOSTS=127.0.0.2 -e STORAGE_TYPE=elasticsearch -e ES_HTTP_LOGGING=BASIC -e RABBIT_URI=amqp://guest:guest@127.0.0.3:5672 openzipkin/zipkin-slim</code>。这里有几个参数：</p>
<ul>
<li><code>ES_HOSTS</code>：<code>elasticsearch</code>的地址。</li>
<li><code>STORAGE_TYPE</code>：数据存储的方式。</li>
<li><code>RABBIT_URI</code>：<code>rabbitmq</code>地址。</li>
</ul>
<p>访问<code>localhost:9411</code>。</p>
<p>新建<strong>两个</strong><code>zipkin</code>项目，添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-sleuth-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置<code>1</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">zipkin1</span></span><br><span class="line"><span class="comment"># 开启链路追踪</span></span><br><span class="line"><span class="meta">spring.sleuth.web.client.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 采样比例，默认为0.1</span></span><br><span class="line"><span class="meta">spring.sleuth.sampler.probability</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 开启zipkin</span></span><br><span class="line"><span class="meta">spring.zipkin.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># zipkin地址</span></span><br><span class="line"><span class="meta">spring.zipkin.base-url</span>=<span class="string">http://localhost:9411</span></span><br><span class="line"><span class="comment"># 追踪消息的发送类型</span></span><br><span class="line"><span class="meta">spring.zipkin.sender.type</span>=<span class="string">rabbit</span></span><br><span class="line"><span class="comment"># rabbitmq</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br></pre></td></tr></table></figure>

<p>配置<code>2</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">zipkin2</span></span><br><span class="line"><span class="comment"># 改端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="comment"># 开启链路追踪</span></span><br><span class="line"><span class="meta">spring.sleuth.web.client.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 采样比例，默认为0.1</span></span><br><span class="line"><span class="meta">spring.sleuth.sampler.probability</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 开启zipkin</span></span><br><span class="line"><span class="meta">spring.zipkin.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># zipkin地址</span></span><br><span class="line"><span class="meta">spring.zipkin.base-url</span>=<span class="string">http://localhost:9411</span></span><br><span class="line"><span class="comment"># 追踪消息的发送类型</span></span><br><span class="line"><span class="meta">spring.zipkin.sender.type</span>=<span class="string">rabbit</span></span><br><span class="line"><span class="comment"># rabbitmq</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br></pre></td></tr></table></figure>

<p>在<code>zipkin2</code>的<code>controller</code>调用<code>1</code>的服务。</p>
<p><code>zipkin1 controller</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"zipkin1 hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello: "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zipkin2 controller</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRestTemplate</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(restTemplate.getForObject("http://localhost:8080/hello?name=&#123;1&#125;", String.class, "test"));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zipkin2Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Zipkin2Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:8081/hello</code>发送请求。在<code>zipkin</code>中可以看到相关信息。</p>
<hr>
<h3 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h3><p><code>Spring Cloud Alibaba</code>是阿里巴巴提供的一套微服务一站式解决方案。主要有以下功能：</p>
<ul>
<li>服务注册与发现<code>Nacos</code></li>
<li>服务限流降级</li>
<li>分布式配置中心</li>
<li>消息驱动</li>
<li>分布式事务</li>
<li>阿里云对象存储<code>OSS</code></li>
</ul>
<h4 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h4><p><code>Nacos</code>主要提供了服务发现、服务配置和服务管理。</p>
<h5 id="实战-12"><a href="#实战-12" class="headerlink" title="实战"></a>实战</h5><p>首先去官网<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">下载</a><code>Nacos</code>，解压后执行启动脚本。访问<code>localhost:8848/nacos</code>。</p>
<h6 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h6><p>首先看配置中心，点击配置管理&gt;配置列表，点击<code>+</code>号新建配置文件，需要指定<code>Data ID</code>、<code>Group</code>以及配置的内容。<code>Data ID</code>的格式是<code>${prefix}-${spring.profiles.active}-.${file-extension}</code>，这和之前<code>Spring Cloud Config</code>的格式很像。</p>
<p><img src="nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.png" alt=""></p>
<p>新建项目，添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置<code>bootstrap.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">nacos</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.server-addr</span>=<span class="string">localhost:8848</span></span><br><span class="line"><span class="comment"># 配置文件拓展名</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.file-extension</span>=<span class="string">properties</span></span><br></pre></td></tr></table></figure>

<p>添加接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello: "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目访问<code>localhost:8080/hello</code>就可以看到之前在配置中心配置的文件内容。修改配置文件点击发布，再次刷新接口就可以看到最新的内容了。</p>
<h6 id="注册中心-1"><a href="#注册中心-1" class="headerlink" title="注册中心"></a>注册中心</h6><p>新建项目，添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">nacos1</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">localhost:8848</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure>

<p><code>controller</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello: "</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动两个实例作为集群。在<code>nacos</code>的服务列表可以看到注册上来的实例。</p>
<p>再创建一个<code>client</code>项目。</p>
<p><code>controller</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRestTemplate</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://nacos1/hello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">nacos2</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">localhost:8848</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8083</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nacos02Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Nacos02Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 负载均衡</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，访问<code>localhost:8083/hello</code>就可以看到负载均衡的效果了。</p>
<h6 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h6><p><code>Sentinel</code>相当于分布式系统的流量防卫兵，用于保障服务的稳定性，类似于<code>Hystrix</code>。由于<code>Hystrix</code>已经停更，<code>SpringCloud</code>推荐除了<code>Resilience4j</code>，就是使用<code>Spring Cloud Alibaba</code>的<code>Sentinel</code>。</p>
<p>首先去<code>github</code><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">下载</a><code>Sentinel</code>，直接使用<code>java -jar</code>命令启动。访问<code>localhost:8080</code>，默认用户名和密码都是<code>sentinel</code>。</p>
<p>新建项目，添加依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">sentinel</span></span><br><span class="line"><span class="comment"># sentinel地址</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.transport.dashboard</span>=<span class="string">localhost:8080</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure>

<p><code>controller</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello sentinel"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目访问<code>localhost:8081/hello</code>后，刷新<code>sentinel</code>页面就可以看到相关的信息了。</p>
<p><img src="sentinel.png" alt=""></p>
<p>点击<strong>簇点链路</strong>，可以看到有我们访问的<code>/hello</code>接口。我们可以增加流控的规则：</p>
<p><img src="%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99.png" alt=""></p>
<p>我们设置了请求每秒只允许最多有<code>5</code>次请求，其余的排队等待，超时时间设置为<code>1000ms</code>。</p>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentinelApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            String s = restTemplate.getForObject(<span class="string">"http://localhost:8081/hello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(s + <span class="string">" "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行查看控制台输出：</p>
<p><img src="sentinel%E6%B5%8B%E8%AF%95.png" alt=""></p>
<p>一共运行了<code>3</code>秒，达到了流控的效果。</p>
<p>除了在<code>Sentinel</code>中配置流控规则，还可以直接在<code>Nacos</code>中配置。</p>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.server-addr</span>=<span class="string">localhost:8848</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.data-id</span>=<span class="string">sentinel-rule</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.group-id</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.rule-type</span>=<span class="string">flow</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>Nacos</code>中添加配置文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接口</span></span><br><span class="line">        <span class="attr">"resource"</span>: <span class="string">"/hello"</span>,</span><br><span class="line">        <span class="comment">// 调用源</span></span><br><span class="line">        <span class="attr">"limitApp"</span>: <span class="string">"default"</span>,</span><br><span class="line">        <span class="comment">// 阈值类型，1表示QPS</span></span><br><span class="line">        <span class="attr">"grade"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 阈值</span></span><br><span class="line">        <span class="attr">"count"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="comment">// 集群模式</span></span><br><span class="line">        <span class="attr">"clusterMode"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 流控模式，0表示直接</span></span><br><span class="line">        <span class="attr">"strategy"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 流控效果，0表示快速失败</span></span><br><span class="line">        <span class="attr">"controlBehavior"</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>再次测试可以得到相同的效果。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO</title>
    <url>/2021/02/03/Java-IO/</url>
    <content><![CDATA[<p>Java IO笔记</p>
<a id="more"></a>

<h3 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h3><h4 id="Java-IO分类"><a href="#Java-IO分类" class="headerlink" title="Java IO分类"></a>Java IO分类</h4><p><code>IO</code>指的是<code>Input/Output</code>，也就是输入和输出。</p>
<ul>
<li><code>Input</code>：从外部把数据读入内存。例如：硬盘、网络、<code>USB</code>等等。</li>
<li><code>Output</code>：从内存中把数据输出到外部。同样的，可以输出到硬盘、网络、<code>USB</code>等等。</li>
</ul>
<p>从数据传输的方式来看，可以将<code>IO</code>分为<strong>字节流</strong>和<strong>字符流</strong>。<code>Java</code>中字节流以字节为单位传输数据，字符流则是以字符（根据编码的不同对应的字节也不同）为单位。</p>
<p><img src="%E5%AD%97%E8%8A%82%E6%B5%81.png" alt=""></p>
<p><img src="%E5%AD%97%E7%AC%A6%E6%B5%81.png" alt=""></p>
<p>将字符转换为字节就称之为<strong>编码</strong>，反之称之为<strong>解码</strong>。如果编码和解码使用了不同的编码方式，那么就会出现<strong>乱码</strong>的情况。</p>
<p>从数据来源的角度来看，<code>IO</code>可以分为以下几类：</p>
<p><img src="IO%E5%88%86%E7%B1%BB.png" alt=""></p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><h5 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归读取一个目录下所有文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listAllFiles</span><span class="params">(File dir)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="keyword">null</span> || !dir.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"input path is null or doesn't exist"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir.isFile()) &#123;</span><br><span class="line">        System.out.println(dir.getName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (File f : dir.listFiles()) &#123;</span><br><span class="line">            listAllFiles(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="字节流类"><a href="#字节流类" class="headerlink" title="字节流类"></a>字节流类</h5><h6 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="comment">// 每次读取一个字节</span></span><br><span class="line">    <span class="keyword">while</span> ((cnt = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        sb.append((<span class="keyword">char</span>) cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码可以完成对<code>test.txt</code>文件的读取。但是，这样效率太低，每次只从文件中读取一个字节，<code>IO</code>次数太多，效率低。所以可以用缓冲区一次多读一些字节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="comment">// 每次读取1024字节</span></span><br><span class="line">    <span class="keyword">while</span> ((cnt = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        sb.append(<span class="keyword">new</span> String(buff, <span class="number">0</span> ,cnt));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h6><p>我们还可以利用<code>BufferedInputStream</code>继续优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line">    <span class="comment">// 使用了缓冲区，默认大小为8192字节，也就是说会一次性读取8kb的数据到内存中，进一步减少了与磁盘的IO次数。</span></span><br><span class="line">    InputStream is = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file), <span class="number">8192</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">while</span> ((cnt = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        sb.append(<span class="keyword">new</span> String(buff, <span class="number">0</span> ,cnt));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="字符流类"><a href="#字符流类" class="headerlink" title="字符流类"></a>字符流类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按行读取一个文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFileByLine</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FileReader reader = <span class="keyword">new</span> FileReader(path);</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h5><ul>
<li><code>RandomAccessFile</code>虽然属于<code>java.io</code>下的类，但是它独立于字节流和字符流，可以对文件进行读和写。</li>
<li><code>RandomAccessFile</code>可以在文件的任意位置读写。</li>
<li>通过<code>seek()</code>本地方法设置起始随机读取文件的位置，字节为单位。</li>
<li>通过<code>length()</code>本地方法返回文件的长度，字节为单位。</li>
<li>新建对象时要在构造函数中指定读写的方式：<ul>
<li><code>r</code>代表以只读的方式。</li>
<li><code>rw</code>代表以读写的方式。</li>
<li><code>rws</code>代表以读写的方式，同时对于内容和元数据都同步到存储设备。</li>
<li><code>rwd</code>代表以读写的方式，同时只同步对于内容的更新到存储设备上。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>), <span class="string">"rw"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 跳过指定的字节数</span></span><br><span class="line">    file.seek(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 覆盖</span></span><br><span class="line">    file.write(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">while</span> ((cnt = file.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, cnt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h5><p><code>server</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        Socket socket;</span><br><span class="line">        InputStream is;</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            socket = server.accept();</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((cnt = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                sb.append(<span class="keyword">new</span> String(buff, <span class="number">0</span> ,cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>client</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">"hello world"</span>.getBytes());</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><p>直接从<code>URL</code>中读取字节流数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">    InputStream is = url.openStream();</span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is, StandardCharsets.UTF_8);</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>装饰器模式允许向现有的对象添加额外的功能，而同时不改变其结构。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>创建一个<code>Card</code>接口，我们可以裁剪它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">implements</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cut shape: rectangle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cut shape: circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建抽象装饰类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorDecorator</span> <span class="keyword">implements</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Card card;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorDecorator</span><span class="params">(Card card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        card.cut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实体装饰类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedCardDecorator</span> <span class="keyword">extends</span> <span class="title">ColorDecorator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedCardDecorator</span><span class="params">(Card card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(card);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        card.cut();</span><br><span class="line">        drawColor(card);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawColor</span><span class="params">(Card card)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw color: red"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Card card = <span class="keyword">new</span> Card();</span><br><span class="line">        <span class="comment">// 利用装饰器给Card添加着色的功能</span></span><br><span class="line">        ColorDecorator redRect = <span class="keyword">new</span> RedCardDecorator(<span class="keyword">new</span> Rect());</span><br><span class="line">        ColorDecorator redCircle = <span class="keyword">new</span> RedCardDecorator(<span class="keyword">new</span> Circle());</span><br><span class="line">        System.out.println(<span class="string">"make a red rectangle card"</span>);</span><br><span class="line">        redRect.cut();</span><br><span class="line">        System.out.println(<span class="string">"make a red circle card"</span>);</span><br><span class="line">        redCircle.cut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="IO装饰器"><a href="#IO装饰器" class="headerlink" title="IO装饰器"></a>IO装饰器</h5><p>以<code>InputStream</code>为例，<code>InputStream</code>本身是抽象类，<code>FileInputStream</code>是<code>InputStream</code>的子类，提供了基于字节流的输入操作。而<code>FilterInputStream</code>就相当于抽象装饰类，其实现类例如<code>DataInputStream</code>、<code>BufferedInputStream</code>相当于具体的装饰类，为<code>FileInputStream</code>提供了额外的功能。例如前面提到的<code>BufferedInputStream</code>为<code>FileInputStream</code>提供了缓冲区的功能。</p>
<p>使用装饰器模式的好处是比继承更加灵活。继承是静态的，一旦使用继承所有的子类都会有一样的功能，而装饰器模式可以动态添加功能。而且装饰器模式更加容易复用，直接在原有对象套上一层装饰器对象即可。</p>
<hr>
<h3 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步/异步/阻塞/非阻塞"></a>同步/异步/阻塞/非阻塞</h3><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>同步和异步指的是执行流程中一个方法是否要等到前一个方法执行完成后才能执行。同步的话一旦方法调用，就必须等到方法调用返回才能继续后续的流程；而异步不必等待，调用立即返回，继续后续的流程。也就是说异步执行方法会交给其他线程，不阻塞主线程。</p>
<p>同步和异步关注的是方法的执行线程是主线程还是其他线程。</p>
<h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>阻塞与非阻塞指的是单个线程内遇到同步等待时，是否待在原地不做任何操作。阻塞的话会一直待在原地等待同步方法执行完成。非阻塞的话不会待在原地，可以先去做其他操作，但要定期检查同步方法是否执行完成了。</p>
<p>阻塞和非阻塞关注的是线程是否会在原地等待同步方法。</p>
<hr>
<h3 id="Unix-IO模型"><a href="#Unix-IO模型" class="headerlink" title="Unix IO模型"></a>Unix IO模型</h3><p>为了了解<code>Unix IO</code>模型，需要先理解几个概念：</p>
<h4 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h4><p><code>Linux</code>系统的运行空间分为内核空间（<code>Kernel space</code>）和用户空间（<code>User space</code>），它们之间彼此隔离，因此我们遇到应用程序崩溃时也不用担心内核受损。</p>
<p>在内核空间中可以执行任何<code>CPU</code>指令，访问底层资源；但是用户空间中只能通过系统的接口才能向内核发送指令。</p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符（<code>fd, File Descriptor</code>），用于描述指向文件的引用的抽象概念。文件描述符是一个非负整数索引值，指向内核为每一个进程维护的本进程打开文件的记录表。每当应用程序新建或打开一个文件时，内核都会向该进程返回一个文件描述符。文件描述符是为了内核高效管理已被打开的文件，所有执行<code>I/O</code>的系统调用都会通过文件描述符。</p>
<p><code>Linux</code>系统打开文件描述符的数量是有限制的，可以通过<code>cat /proc/sys/fs/file-max</code>查看，在<code>/etc/sysctl.conf</code>中可以通过<code>fs.file-max=xxx</code>修改。而进程也有自己的最大打开文件描述符，通过<code>ulimit -n</code>查看。该值是<code>user limit</code>中<code>nofile</code>的<code>soft limit</code>，不能大于<code>hard limit</code>。<code>hard limt</code>可以通过<code>ulimit -Hn</code>查看。我们可以用<code>ulimit -Sn xxx</code>临时修改<code>soft limit</code>。如果想要永久设置，要在<code>/etc/security/limits.conf</code>中修改。例如对于<code>a</code>用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a soft nofile xxx</span><br><span class="line">a hard nofile xxx</span><br></pre></td></tr></table></figure>

<p>设置的<code>hard limit</code>不能大于<code>/proc/sys/fs/nr_open</code>的值。当然我们也可以修改<code>nr_open</code>的值：<code>echo xxx &gt; /proc/sys/fs/nr_open</code>。</p>
<p>若要查看当前系统使用的文件描述符的数据，可以通过<code>car /proc/sys/fs/file-nr</code>查看。第一个值表示已分配使用的打开文件描述符数，第二个值表示分配后已释放的数，目前已不使用，第三个值等于<code>file-max</code>。</p>
<h4 id="内核缓冲区"><a href="#内核缓冲区" class="headerlink" title="内核缓冲区"></a>内核缓冲区</h4><p><code>Linux</code>存在缓存<code>IO</code>的机制，当进行<code>input</code>或者<code>output</code>时，数据会被先拷贝或读取到内核空间的缓冲区中，然后才会被写入到设备中或者拷贝到用户空间的缓冲区中。</p>
<h4 id="5种模型"><a href="#5种模型" class="headerlink" title="5种模型"></a>5种模型</h4><h5 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h5><p>阻塞式<code>I/O</code>简称<code>BIO(Blocking IO)</code>。</p>
<p>如下图，从应用程序调用<code>recvfrom</code>，到数据报到达并且被复制到应用程序的缓冲区或者发生错误（例如信号中断）的过程中，如果发起调用的线程一直处于等待的状态，那么它是阻塞式<code>I/O</code>。</p>
<p><img src="%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png" alt=""></p>
<p><code>BIO</code>存在一个问题，如果内核的数据需要耗时比较久才能准备好，那么进程将长时间阻塞，浪费性能。</p>
<h5 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h5><p>为了解决以上问题，引入了非阻塞式<code>I/O</code>，简称<code>NIO(Non-Blocking IO)</code>。</p>
<p>如下图，应用程序调用<code>recvfrom</code>等到内核接收到请求之后就立即返回，然后通过<strong>轮询</strong>的方式反复调用，如果数据还没准备好，内核立即返回<code>EWOULDBLOCK</code>错误。直到数据报准备好了，进程阻塞，将数据从内核缓冲区拷贝到用户空间的缓冲区，然后进程继续后续的任务。应用程序发起系统调用的线程不会一直等待而是立即返回，这样的<code>IO</code>是非阻塞式<code>IO</code>。</p>
<p><img src="%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png" alt=""></p>
<p><code>NIO</code>相对于<code>BIO</code>已经大幅提升了性能，但依然不是完美的，那就是因为轮询会消耗大量的<code>CPU</code>资源，而且大多数都是无效的系统调用。</p>
<h5 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h5><p>非阻塞式<code>I/O</code>的最大问题就是轮询导致大量的无效系统调用，于是有了<code>IO</code>多路复用这样的解决思路。</p>
<p><code>IO</code>多路复用是一种机制，使得内核可以监视多个描述符，一旦一个或多个<code>IO</code>条件就绪（输入已准备好被读取，或者描述符已能承接更多输出），就会通知应用程序进行相应的读写操作。</p>
<h6 id="select-poll"><a href="#select-poll" class="headerlink" title="select/poll"></a>select/poll</h6><p><code>select</code>是内核提供的一个系统调用，监视的文件描述符有<code>writedfs</code>、<code>readfds</code>、<code>exceptfds</code>三类。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>timeval</code>用于指定超时时间的秒数或微秒数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;  <span class="comment">// 秒</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec; <span class="comment">// 微秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该参数有三种可能。</p>
<ol>
<li>永远等待，仅在有一个描述符准备好了<code>IO</code>时才返回。这时我们应该把该参数设为空指针。</li>
<li>等待一段固定时间，在有一个描述符准备好了<code>IO</code>时返回，但是时间不超过设置的时间。</li>
<li>不等待，检查描述符之后即刻返回，也就是轮询。这时应该把该参数设置为<code>0</code>。</li>
</ol>
<p>调用后<code>select</code>函数会阻塞，直到有文件描述符就绪或者超时，函数返回。当<code>select</code>返回后，内核会遍历<code>fdset</code>，找到就绪的描述符。所以<code>select</code>的时间复杂度为<code>O(n)</code>。</p>
<p><code>select</code>的缺点是：</p>
<ul>
<li>单个进程可监视的文件描述符数量是有限制的。在<code>Linux</code>中要求小于<code>1024</code>。</li>
<li>时间复杂度为<code>O(n)</code>，相当于内核采用了轮询，浪费<code>CPU</code>。</li>
<li>需要维护一个存放文件描述符的数据结构。每次调用<code>select</code>都要把这个数据结构从用户空间拷贝到内核空间，开销很大。</li>
</ul>
<p><code>poll</code>的本质和<code>select</code>是一样的，只是存放文件描述符的结构不同，用的是<code>pollfd</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>pollfd</code>其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>   fd;       <span class="comment">// 文件描述符</span></span><br><span class="line">	short events;   <span class="comment">// 要监视的events</span></span><br><span class="line">	short revents;  <span class="comment">// 发生的events</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其大小没有限制。但同样的，<code>poll</code>在返回后内核同样要轮询找出就绪的描述符，并且同样有大量的拷贝操作。</p>
<p><img src="select&poll.png" alt=""></p>
<p>总的来说，<code>select/poll</code>减少了应用程序发起的系统调用，但内核的工作并不会减少。在高并发的场景下，内核的性能问题依然存在。所以问题就是如何减少内核重复的遍历。</p>
<h6 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h6><p><code>epoll</code>是在<code>Linux 2.6</code>内核中提出的，它没有描述符的限制。<code>epoll</code>使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中。</p>
<p><code>epoll</code>过程有三个方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>int epoll_create(int size)</code>：建立与内核的连接。创建一个<code>epoll</code>的句柄，参数<code>size</code>用来告诉内核监听的描述符数一共多大，它并不是限制了<code>epoll</code>所能监听的最大描述符数，只是对内核初始分配内部数据结构的建议。创建好句柄之后，它会占用一个<code>fd</code>，所以使用完<code>epoll</code>要调用<code>close()</code>关闭以免<code>fd</code>被耗尽。</p>
</li>
<li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>：注册事件，对指定<code>fd</code>执行操作。<code>epfd</code>是<code>epoll_create</code>的返回值，<code>op</code>则表示具体的操作，用三个宏表示：添加<code>EPOLL_CTL_ADD</code>，删除<code>EPOLL_CTL_DEL</code>，修改<code>EPOLL_CTL_MOD</code>，分别表示添加、删除和修改对<code>fd</code>的监听事件。<code>fd</code>表示监听的文件描述符。<code>epoll_event</code>表示告诉内核监听什么事，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">// epoll事件</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">// 用户数据变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</code>：等待<code>IO</code>事件，最多返回<code>maxevents</code>个事件。<code>events</code>从内核得到事件的集合，<code>maxevents</code>告诉内核<code>events</code>有多大，该值不能超过<code>epoll_create(int size)</code>的<code>size</code>值。<code>timeout</code>是超时时间，同<code>select</code>中的<code>timeout</code>参数类似。该函数返回需要处理的事件数目，如果为<code>0</code>表示已经超时了。</p>
</li>
</ol>
<p><code>epoll</code>对文件描述符的操作有两种模式：</p>
<ul>
<li><code>LT(Level-Triggered)</code>模式：当<code>epoll_wait</code>检测到描述符事件发生了会将此事件告知应用程序。如果应用程序没有处理该事件，下次再调用<code>epoll_wait</code>依然会告知应用程序。该模式是<strong>默认</strong>模式。</li>
<li><code>ET(Edge-Triggered)</code>模式：当<code>epoll_wait</code>检测到描述符事件发生了会将此事件告知应用程序，但是只会告知一次，即使应用程序没有处理它，直到下一次该描述符上有了新的<code>IO</code>事件。这种模式效率高。</li>
</ul>
<p>使用<code>epoll</code>，相对于<code>select/poll</code>的好处有：</p>
<ul>
<li>相对<code>select</code>来说，没有监听的最大文件描述符的限制，它所支持的<code>fd</code>上限是最大可以打开文件的数目。<code>Linux</code>中通过<code>cat /proc/sys/fs/file-max</code>查看。</li>
<li>在<code>select/poll</code>中，内核需要对文件描述符进行线性扫描找出处于就绪状态的，而<code>epoll</code>通过注册文件描述符，使得一个<code>fd</code>就绪时，会自动回调，将就绪的<code>fd</code>放到<code>rdlist</code>中。当应用程序调用<code>epoll_wait</code>时会收到通知。所以<code>epoll</code>的时间复杂度是<code>O(1)</code>的。</li>
<li>只有调用<code>epoll_ctl</code>时才会把<code>fd</code>拷贝到内核空间，使用<code>mmap</code>加速内核空间与用户空间之间数据的传递。</li>
</ul>
<p><img src="epoll.png" alt=""></p>
<p>但是<code>epoll</code>还是有缺陷的，那就是在数据准备阶段，用户进程是阻塞的。</p>
<h5 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h5><p>信号驱动式<code>IO</code>与<code>BIO</code>和<code>NIO</code>的区别在于，在数据准备的阶段，用户进程不会阻塞。</p>
<p>如下图，当应用程序发起一个<code>IO</code>请求，会给对应的<code>socket</code>注册一个信号函数，然后用户进程继续运行，不会阻塞。当内核中的数据准备好了，会发送一个<code>SIGIO</code>信号给用户线程，然后用户进程调用<code>recvfrom</code>将数据拷贝到用户空间，进行后续的操作。</p>
<p><img src="%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%BC%8FIO.png" alt=""></p>
<p>相比于之前几种<code>IO</code>，信号驱动式<code>IO</code>解决了数据准备时用户进程阻塞的问题。但是最后拷贝数据时依旧是阻塞的。</p>
<h5 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h5><p>异步<code>IO</code>真正实现了<code>IO</code>流程全程非阻塞。</p>
<p>如下图，用户进程调用<code>aio_read</code>，无论内核数据有没有准备好，都会直接返回给用户进程。当<code>socket</code>数据准备好然后拷贝完成后，内核向进程发送通知。用户进程全程都是非阻塞的。</p>
<p><img src="%E5%BC%82%E6%AD%A5IO.png" alt=""></p>
<hr>
<h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>Java NIO</code>是<code>Java 1.4</code>之后新出的一套<code>IO</code>接口。它的特点有：</p>
<ul>
<li>标准的<code>IO</code>编程接口是面向字节流和字符流的，而<code>NIO</code>是面向<strong>通道</strong>和<strong>缓冲区</strong>的。数据从通道中读取到缓冲区中，或者从缓冲区中写入到通道中。</li>
<li>使用同步非阻塞式<code>IO</code>。</li>
<li>使用<code>selector</code>，可以检测多个通道的事件状态，使得单线程可以操作多个通道的数据。</li>
</ul>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p><code>Channel</code>，通道。通过它可以读取、写入数据，相当于<code>IO</code>中的流。但不同的是：</p>
<ul>
<li><code>Channel</code>是双向传输的（<code>NIO</code>面向缓冲区），可以读可以写，而传统的<code>IO</code>操作是单向的。</li>
<li><code>Channel</code>可以异步读写。</li>
<li>对<code>Channel</code>的读写要通过<code>buffer</code>。</li>
<li><code>buffer</code>负责存储数据，<code>Channel</code>负责传输数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通道是否打开</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 关闭该通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Java NIO</code>中提供了几种<code>Channel</code>：</p>
<ul>
<li><code>FileChannel</code>：从文件中读取数据。</li>
<li><code>DatagramChannel</code>：读写<code>UDP</code>网络协议的数据。</li>
<li><code>SocketChannel</code>：读写<code>TCP</code>网络协议的数据。</li>
<li><code>ServerSocketChannel</code>：监听<code>TCP</code>连接。</li>
</ul>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p><code>Buffer</code>，缓冲区，本质是一个数组，用于数据的读写。在<code>Java</code>中是一个抽象类，它包含四个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;     <span class="comment">// 标记当前position，可以通过reset()恢复</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;  <span class="comment">// 正在操作的数据的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;         <span class="comment">// 当前可用容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;      <span class="comment">// 总容量</span></span><br></pre></td></tr></table></figure>

<p>这四个属性不变的是<code>mark &lt;= position &lt;= limit &lt;= capacity</code>。</p>
<p>还包含几个重要的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets this buffer's limit.  If the position is larger than the new limit</span></span><br><span class="line"><span class="comment"> * then it is set to the new limit.  If the mark is defined and larger than</span></span><br><span class="line"><span class="comment"> * the new limit then it is discarded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; newLimit) position = newLimit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; newLimit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resets this buffer's position to the previously-marked position.</span></span><br><span class="line"><span class="comment"> * 该方法不会改变或者丢弃mark的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clears this buffer.  The position is set to zero, the limit is set to</span></span><br><span class="line"><span class="comment"> * the capacity, and the mark is discarded.</span></span><br><span class="line"><span class="comment"> * 不会真的清除buffer中的数据，只是把position指向0的位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flips this buffer.  The limit is set to the current position and then</span></span><br><span class="line"><span class="comment"> * the position is set to zero.  If the mark is defined then it is discarded.</span></span><br><span class="line"><span class="comment"> * 将limit设置为当前position的位置，把position指向0的位置，并且丢弃mark。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rewinds this buffer.  The position is set to zero and the mark is discarded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Buffer</code>读写数据一般要经过以下几个步骤：</p>
<ul>
<li>写入数据到<code>Buffer</code>。</li>
<li>调用<code>flip()</code>，切换到读模式。</li>
<li>从<code>Buffer</code>中读取数据。</li>
<li>调用<code>clear()</code>。</li>
</ul>
<p><code>Java NIO</code>主要提供了以下几种<code>Buffer</code>：</p>
<ul>
<li><code>ByteBuffer</code></li>
<li><code>CharBuffer</code></li>
<li><code>DoubleBuffer</code></li>
<li><code>FloatBuffer</code></li>
<li><code>IntBuffer</code></li>
<li><code>LongBuffer</code></li>
<li><code>ShortBuffer</code></li>
</ul>
<h5 id="直接缓冲区和非直接缓冲区"><a href="#直接缓冲区和非直接缓冲区" class="headerlink" title="直接缓冲区和非直接缓冲区"></a>直接缓冲区和非直接缓冲区</h5><ul>
<li>非直接缓冲区：在虚拟机内存中创建缓冲区，易回收，但是占用了虚拟机的内存，读写数据的时候需要复制。使用<code>allocate()</code>分配缓冲区。</li>
</ul>
<p><img src="%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt=""></p>
<ul>
<li>直接缓冲区：在物理内存中申请一块空间，映射到内核空间和用户空间。这样读写数据时就不需要复制了，而是直接通过这块申请的空间。这种方式效率更高，但是创建和销毁空间开销比较大。使用<code>allocateDirect()</code>分配缓冲区。</li>
</ul>
<p><img src="%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt=""></p>
<h4 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>));</span><br><span class="line">    FileChannel channel = fis.getChannel();</span><br><span class="line">    <span class="comment">// 创建非直接缓冲区</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = channel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// limit=position, position=0</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(byteBuffer, <span class="number">0</span>, len));</span><br><span class="line">        <span class="comment">// position=0, limit=capacity</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close();</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>), <span class="keyword">true</span>);</span><br><span class="line">    FileChannel channel = fos.getChannel();</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"hello nio"</span>.getBytes());</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    channel.write(byteBuffer);</span><br><span class="line">    channel.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分散和聚集"><a href="#分散和聚集" class="headerlink" title="分散和聚集"></a>分散和聚集</h4><ul>
<li>分散读取：将通道中的数据分散到多个缓冲区中。</li>
<li>聚集写入：将多个缓冲区中的数据聚集到通道中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>));</span><br><span class="line">    FileChannel channel1 = fis.getChannel();</span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    ByteBuffer buffer3 = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    ByteBuffer[] buffers = &#123;buffer1, buffer2, buffer3&#125;;</span><br><span class="line">    <span class="comment">// 分散读取</span></span><br><span class="line">    channel1.read(buffers);</span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer bf : buffers) &#123;</span><br><span class="line">        bf.flip();</span><br><span class="line">    &#125;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"test1.txt"</span>), <span class="keyword">true</span>);</span><br><span class="line">    FileChannel channel2 = fos.getChannel();</span><br><span class="line">    <span class="comment">// 聚集写入</span></span><br><span class="line">    channel2.write(buffers);</span><br><span class="line">    channel1.close();</span><br><span class="line">    channel2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>字符集用于解决乱码的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    CharBuffer cb = CharBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    Charset charset = StandardCharsets.UTF_8;</span><br><span class="line">    <span class="comment">// 编码器</span></span><br><span class="line">    CharsetEncoder encoder = charset.newEncoder();</span><br><span class="line">    <span class="comment">// 解码器</span></span><br><span class="line">    CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">    cb.put(<span class="string">"你好"</span>);</span><br><span class="line">    <span class="comment">// 切换为读模式</span></span><br><span class="line">    cb.flip();</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    ByteBuffer bb = encoder.encode(cb);</span><br><span class="line">    <span class="comment">// 解码</span></span><br><span class="line">    System.out.println(decoder.decode(bb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通道间传输"><a href="#通道间传输" class="headerlink" title="通道间传输"></a>通道间传输</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>));</span><br><span class="line">    FileChannel from = fis.getChannel();</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"test1.txt"</span>));</span><br><span class="line">    FileChannel to = fos.getChannel();</span><br><span class="line">    <span class="keyword">long</span> position = <span class="number">0</span>, cnt = from.size();</span><br><span class="line">    <span class="comment">// 两种方式</span></span><br><span class="line">    from.transferTo(position, cnt, to);</span><br><span class="line">    to.transferFrom(from, position, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p><code>Selector</code>是<code>NIO</code>的组件。将通道全部注册到选择器上，选择器会监控通道的信息（连接、读、写等情况）。当某一通道，某一事件就绪时，选择器会把这个通道分配到服务器的一个或多个线程上。</p>
<p>使用<code>Selector</code>的好处是可以使用更少的线程去处理通道，减少了线程之间的切换带来的开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Selector</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">// 创建通道，该通道必须是非阻塞的，所以FileChannel不适用。</span></span><br><span class="line">SocketChannel channel = SocketChannel.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 连接server</span></span><br><span class="line">channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 注册通道，返回一个键对象。</span></span><br><span class="line"><span class="comment">// 如果对第二个参数重新赋值，将会覆盖之前的值。</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>

<p><code>SelectionKey</code>有四个常量，代表了不同的监听类型：</p>
<ul>
<li><code>SelectionKey.OP_READ</code>：读</li>
<li><code>SelectionKey.OP_WRITE</code>：写</li>
<li><code>SelectionKey.OP_CONNECT</code>：连接</li>
<li><code>SelectionKey.OP_ACCEPT</code>：接收</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>对于客户端的<code>SocketChannel</code>，支持读、写、连接三个操作；而服务端的<code>ServerSocketChannel</code>只支持接收操作，<code>accept()</code>方法产生的<code>SocketChannel</code>只支持读和写操作。</p>
<p>如果想要监听多种事件，可以使用<strong>或</strong>运算进行组合，例如：<code>SelectionKey.OP_READ | SelectionKey.OP_WRITE</code>。</p>
<p><code>Selector</code>中还有几个重要的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册的SelectionKeys集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;SelectionKey&gt; <span class="title">keys</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 至少有一个监听的事件ready的keys集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;SelectionKey&gt; <span class="title">selectedKeys</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 使得第一个阻塞在select()方法的线程立即返回结果。</span></span><br><span class="line"><span class="comment">// 如果当前没有线程阻塞在select()方法，下一个执行select()方法的线程会立即返回结果。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title">wakeup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 关闭Selector，使得所有注册在该Selector上的SelectionKey失效。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">// 选择准备就绪的通道，返回值代表有多少通道已就绪。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  <span class="comment">// 阻塞，直到某个通道至少有一个监听事件ready</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException</span>;  <span class="comment">// 阻塞，但是有超时时间，单位毫秒。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  <span class="comment">// 非阻塞，立即返回。</span></span><br></pre></td></tr></table></figure>

<h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><p>之前注册通道到<code>Selector</code>上返回了<code>SelectionKey</code>对象，它主要包含了以下几种属性和方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回该SelectionKey对应的Channel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回该SelectionKey对应的Selector</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title">selector</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回该SelectionKey感兴趣的集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interestOps</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 重新设置该SelectionKey感兴趣的集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>;</span><br><span class="line"><span class="comment">// 返回通道已经就绪的操作的集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readyOps</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 有数据可读的通道读事件是否就绪</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_READ) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有数据可写的通道写事件是否就绪</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_WRITE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isConnectable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_CONNECT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isAcceptable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readyOps() &amp; OP_ACCEPT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该SelectionKey是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 取消该SelectionKey以及Selector的注册</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="非阻塞Socket通信"><a href="#非阻塞Socket通信" class="headerlink" title="非阻塞Socket通信"></a>非阻塞Socket通信</h4><h5 id="非阻塞server"><a href="#非阻塞server" class="headerlink" title="非阻塞server"></a>非阻塞server</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 监听TCP连接的通道，就像传统的ServerSocket</span></span><br><span class="line">    ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 绑定连接</span></span><br><span class="line">    channel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">    <span class="comment">// 创建选择器</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    <span class="comment">// 注册通道到选择器上，监听接收事件，等待客户端的连接</span></span><br><span class="line">    channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="comment">// 有监听的事件已就绪</span></span><br><span class="line">    <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取就绪的监听事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="comment">// 迭代</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = iterator.next();</span><br><span class="line">            <span class="comment">// 如果是接收事件</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                <span class="comment">// 获取服务端通道</span></span><br><span class="line">                ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="comment">// 获取客户端的连接</span></span><br><span class="line">                SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 注册客户端通道到选择器上，监听读事件</span></span><br><span class="line">                socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isValid() &amp;&amp; key.isReadable()) &#123;</span><br><span class="line">                SocketChannel readChannel = <span class="keyword">null</span>;</span><br><span class="line">                System.out.println(<span class="string">"开始读取"</span>);</span><br><span class="line">                <span class="comment">// 获取读事件就绪的通道</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    readChannel = (SocketChannel) key.channel();</span><br><span class="line">                    readChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="comment">// 创建非直接缓冲区</span></span><br><span class="line">                    ByteBuffer bb = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> cnt;</span><br><span class="line">                    <span class="comment">// 读取数据</span></span><br><span class="line">                    <span class="keyword">while</span> ((cnt = readChannel.read(bb)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        bb.flip();</span><br><span class="line">                        sb.append(<span class="keyword">new</span> String(bb.array(), <span class="number">0</span>, cnt));</span><br><span class="line">                        bb.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(sb.toString());</span><br><span class="line">                    System.out.println(<span class="string">"读取完毕"</span>);</span><br><span class="line">                    <span class="comment">// 添加写事件</span></span><br><span class="line">                    key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);</span><br><span class="line">                    <span class="keyword">if</span> ((readChannel.read(bb)) == -<span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"客户端断开连接"</span>);</span><br><span class="line">                        key.cancel();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            readChannel.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"异常关闭"</span>);</span><br><span class="line">                    key.cancel();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        readChannel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isValid() &amp;&amp; key.isWritable()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"开始写"</span>);</span><br><span class="line">                <span class="keyword">try</span> (SocketChannel writeChannel = (SocketChannel) key.channel()) &#123;</span><br><span class="line">                    <span class="comment">// 写数据</span></span><br><span class="line">                    writeChannel.write(ByteBuffer.wrap(<span class="string">"收到"</span>.getBytes()));</span><br><span class="line">                    System.out.println(<span class="string">"写完了"</span>);</span><br><span class="line">                    <span class="comment">// 取消写事件</span></span><br><span class="line">                    key.interestOps(key.interestOps() &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 手动remove，否则下次轮询时selectedKeys()仍然带有上次轮询留下的数据</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="非阻塞client"><a href="#非阻塞client" class="headerlink" title="非阻塞client"></a>非阻塞client</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建socket通道</span></span><br><span class="line">    SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    System.out.println(<span class="string">"开始发送数据"</span>);</span><br><span class="line">    ByteBuffer sendbuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    sendbuffer.put((<span class="string">"Hello "</span> + <span class="keyword">new</span> Date()).getBytes());</span><br><span class="line">    sendbuffer.flip();</span><br><span class="line">    socketChannel.write(sendbuffer);</span><br><span class="line">    sendbuffer.clear();</span><br><span class="line">    System.out.println(<span class="string">"从服务端接收数据!"</span>);</span><br><span class="line">    ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">while</span> ((cnt = socketChannel.read(readBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        readBuffer.flip();</span><br><span class="line">        sb.append(<span class="keyword">new</span> String(readBuffer.array(), <span class="number">0</span>, cnt));</span><br><span class="line">        readBuffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">    System.out.println(<span class="string">"关闭客户端！"</span>);</span><br><span class="line">    socketChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h4><p><code>Java NIO</code>管道是两个线程之间的单向数据连接。一个<code>Pipe</code>有一个<code>sink channel</code>和一个<code>source channel</code>。把数据写到<code>sink channel</code>，然后从<code>source channel</code>读取。</p>
<p><img src="pipe.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pipe</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    Pipe pipe = Pipe.open();</span><br><span class="line">    <span class="comment">// 获取sink管道</span></span><br><span class="line">    Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">    <span class="comment">// 创建缓冲区</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"Hello Pipe"</span>.getBytes());</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="comment">// 写入数据到管道</span></span><br><span class="line">    sinkChannel.write(byteBuffer);</span><br><span class="line">    <span class="comment">// 获取source管道</span></span><br><span class="line">    Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">int</span> cnt = sourceChannel.read(byteBuffer);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, cnt));</span><br><span class="line">    <span class="comment">// 关闭管道</span></span><br><span class="line">    sinkChannel.close();</span><br><span class="line">    sourceChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring笔记</title>
    <url>/2021/01/15/Spring%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Spring笔记</p>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Spring</code>是一款开源的轻量级框架，主要是为了解决企业应用程序开发的复杂性而创建的。近几年比较流行的微服务框架<code>SpringBoot</code>，也是基于<code>Spring</code>实现的。</p>
<hr>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p><code>Spring</code>核心主要包含以下三部分：</p>
<ul>
<li>控制反转（<code>IoC</code>）</li>
<li>依赖注入（<code>DI</code>）</li>
<li>面向切面编程（<code>AOP</code>）</li>
</ul>
<h4 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h4><p>控制反转（<code>Inverse of Control</code>）是一种设计思想，将原本在程序中手动创建对象的控制权交给<code>Spring</code>容器管理。<code>IoC</code>容器实际上就是一个<code>Map</code>，存放着各种对象。</p>
<p>我们将对象之间的依赖关系交给了容器进行管理，将对象注入容器。这样就有效降低了代码的耦合度，简化了开发，当我们要使用某个对象时，只需要配置好文件或者注解即可，而不用考虑底层是怎样创建出这个对象的，听起来有点像工厂模式。实际上，<code>Spring</code>的<code>IoC</code>就是利用<strong>反射+工厂模式</strong>实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pear</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat pear"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入class类名，通过反射创建对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getBean</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">            Object o = clazz.newInstance();</span><br><span class="line">            <span class="keyword">return</span> (Fruit) o;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 无需知晓具体创建对象的逻辑，直接从工厂获取对象。</span></span><br><span class="line">        Fruit apple = Factory.getBean(<span class="string">"Apple"</span>);</span><br><span class="line">        apple.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们自己设计了一个工厂类，从中获取对象。而<code>Spring</code>使用的是<code>BeanFactory</code>。<code>BeanFactory</code>是<code>Spring IoC</code>容器的核心接口，定义了<code>IoC</code>的基本功能。使用<code>BeanFactory</code>启动容器时，只有使用到了某个<code>Bean</code>时才会对其进行实例化。</p>
<h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h5><p><code>ApplicationContext</code>由<code>BeanFactory</code>派生而来，提供了更多面向应用的功能：</p>
<ul>
<li>资源访问，例如文件和<code>URL</code>。</li>
<li>支持<code>AOP</code>特性。</li>
<li>载入多个具有继承关系的上下文，使得每一个上下文都关注于一个特定的层次。</li>
<li>提供国际化的消息访问。</li>
</ul>
<p><code>ApplicationContext</code>在容器启动时就会一次性创建所有的<code>Bean</code>。好处是如果存在配置错误，可以在一开始就发现它。但同时消耗的内存也会更多，启动效率更低。</p>
<p><code>ApplicationContext</code>有两个具体的实现类，用于读取配置文件：</p>
<ul>
<li><code>ClassPathXmlApplicationContext</code>：从类路径加载配置文件。</li>
<li><code>FileSystemXmlApplicationContext</code>：从本地文件中加载配置文件。</li>
</ul>
<h5 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h5><p>首先创建一个<code>Maven</code>工程，导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建一个<code>User</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>resources</code>目录创建配置文件<code>test.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testBean"</span> <span class="attr">class</span>=<span class="string">"bean.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"irvlin"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Bean</code>标签有几个常见属性：</p>
<ul>
<li><code>id</code>：给实例化对象起名字，原则上可以是任意不包含非特殊符号的字符串。</li>
<li><code>class</code>：创建的对象所在类的路径。</li>
<li><code>name</code>：和<code>id</code>作用差不多，一般不用了。</li>
<li><code>scope</code>：作用域。一般有单例模式<code>Singleton</code>（整个应用程序只创建一个实例）和原型模式<code>Prototype</code>（每次注入都会创建一个新的实例）。<code>Spring</code>默认使用的是单例模式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过配置文件加载容器</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test.xml"</span>);</span><br><span class="line">        <span class="comment">// 获取bean</span></span><br><span class="line">        User user = context.getBean(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>依赖注入（<code>Dependency Injection</code>）。利用配置文件把资源从外部注入到内部，容器加载外部的文件、对象、数据，把这些资源注入给程序中的对象，维护了程序内外对象之间的依赖关系。所以说<code>IoC</code>是设计思想，而<code>DI</code>就是<code>Spring</code>的具体实现。</p>
<p>依赖注入常见的方式：</p>
<ul>
<li><code>setter</code>注入</li>
<li>构造方法注入</li>
<li>注解注入</li>
</ul>
<h5 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test.xml"</span>);</span><br><span class="line">        Main main = context.getBean(Main<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        main.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testBean"</span> <span class="attr">class</span>=<span class="string">"bean.User"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"Main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">ref</span>=<span class="string">"testBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test.xml"</span>);</span><br><span class="line">        Main user = context.getBean(Main<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        user.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testBean"</span> <span class="attr">class</span>=<span class="string">"bean.User"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"Main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"testBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h5><p>在<code>bean</code>目录创建<code>UserDao</code>、<code>UserService</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"addUser"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @Autowired注解注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.addUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 开启注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"bean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test.xml"</span>);</span><br><span class="line">        UserService userService = context.getBean(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userService.addUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h4><p>面向切面编程（<code>Aspect Oriented Programming</code>），能够封装与业务无关，却被不同业务共同调用的代码，例如事务管理、日志管理、权限管理等等，减少了重复代码，降低耦合度，也方便后期代码的维护。</p>
<h5 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h5><ul>
<li><code>Join point</code>：连接点，程序执行期间的某一点，例如执行方法或处理异常时的点。在<code>Spring AOP</code>中，连接点表示方法的执行。</li>
<li><code>Advice</code>：通知。分为方法执行前通知、方法执行后通知、环绕通知等等，类似于拦截器，对连接点的方法进行增强。</li>
<li><code>Pointcut</code>：切点，匹配连接点的表达式。<code>Spring</code>默认使用<code>AspectJ</code>作为切入点表达式语言。</li>
<li><code>Aspect</code>：切面，是通知和切点集合的抽象，定义了一个切点用来匹配连接点。</li>
<li><code>Target Object</code>：被通知的对象。</li>
<li><code>AOP proxy</code>：<code>AOP</code>代理，为了实现切面功能而使用<code>AOP</code>框架创建一个对象。<code>Spring</code>中的<code>AOP</code>代理指的是使用<code>JDK</code>动态代理或者<code>cglib</code>动态代理。如果要代理的对象实现了某个接口，那么会使用<code>JDK</code>动态代理，否则使用<code>cglib</code>。</li>
</ul>
<p><img src="aop.png" alt=""></p>
<ul>
<li><code>Weaving</code>：织入。指把切面加入到对象，创建出代理对象的过程。</li>
<li><code>Advisor</code>：增强器。是切面的另一种实现，不同的是只有一种通知。</li>
</ul>
<h5 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h5><p><code>AspectJ</code>是一个面向切面的框架，定义了<code>AOP</code>的语法，有一个专门的字节码生成器来生成遵守<code>Java</code>规范的<code>class</code>文件。</p>
<p><code>AspectJ</code>一共有前置、后置、环绕、异常、最终这五种通知类型。我们只需要根据<code>AspectJ</code>提供的切点表达式配置好切面就可以了。</p>
<ul>
<li>前置通知<code>@Before</code>：在目标方法执行前执行的通知。</li>
<li>后置通知<code>@After</code>：在目标方法执行后执行的通知。</li>
<li>环绕通知<code>@Around</code>：在目标方法执行前和后都可以执行的通知。</li>
<li>异常通知<code>@AfterThrowing</code>：方法抛出异常后执行的通知。</li>
<li>最终通知<code>@AfterReturning</code>：在某连接点正常完成后执行的通知。</li>
</ul>
<p>执行顺序：</p>
<ul>
<li>无异常时，<code>around start -&gt; before -&gt; around start -&gt; afterReturning -&gt; after</code></li>
<li>发生异常时，<code>around start -&gt; before -&gt; afterThrowing -&gt;after</code></li>
</ul>
<h5 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h5><p>定义一个跑步的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Athlete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始跑步"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义切点表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunAOP</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义切点表达式</span></span><br><span class="line">    <span class="comment">// aop.Athlete.*匹配aop.Athlete包下所有方法，(..)表示任意参数，public *表示方法修饰符为public，返回值任意。</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* aop.Athlete.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterReturning"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"around before"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"around exception: "</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"around after"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"aop"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test.xml"</span>);</span><br><span class="line">        Athlete athlete = context.getBean(Athlete<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        athlete.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发现顺序是<code>around before -&gt; before -&gt; 开始跑步 -&gt; afterReturning -&gt; after -&gt; around after</code>。这和以前的版本略有不同，我的版本是<code>5.3.3</code>。模拟发生一个算术异常，再运行的顺序是<code>around before -&gt; before -&gt; after -&gt; around exception: / by zero -&gt; around after</code>。</p>
<h5 id="Spring-AOP-与-AspectJ"><a href="#Spring-AOP-与-AspectJ" class="headerlink" title="Spring AOP 与 AspectJ"></a>Spring AOP 与 AspectJ</h5><ul>
<li><code>Spring AOP</code>属于运行时增强，<code>AspectJ</code>属于编译时增强。</li>
<li><code>Spring AOP</code>基于代理，而<code>AspectJ</code>基于字节码的操作。</li>
<li><code>Spring AOP</code>性能比较差，如果切面比较多，建议使用<code>AspectJ</code>。</li>
</ul>
<hr>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><code>Spring</code>中的<code>bean</code>有好几种作用域：</p>
<ul>
<li><code>singleton</code>：单例模式。只产生一个实例。（默认）</li>
<li><code>prototype</code>：原型模式。每次请求都产生一个新的实例。</li>
<li><code>request</code>：每次<code>HTTP</code>请求产生一个新的实例，该实例仅在当前<code>HTTP request</code>有效。</li>
<li><code>session</code>：每次<code>HTTP</code>请求产生一个新的实例，该实例仅在当前<code>HTTP session</code>有效。</li>
<li><code>global-session</code>：全局<code>session</code>作用域。仅在基于<code>portlet</code>的<code>web</code>应用中才有意义，<code>Spring 5</code>之后已经没有了。</li>
</ul>
<hr>
<h3 id="Component-和-Bean"><a href="#Component-和-Bean" class="headerlink" title="@Component 和 @Bean"></a>@Component 和 @Bean</h3><ul>
<li><p><code>@Component</code>作用于类，<code>@Bean</code>作用于方法。</p>
</li>
<li><p><code>@Component</code>通常是通过类路径扫描（<code>@ComponentScan</code>）来侦测和装配对象到容器中；<code>@Bean</code>用来告诉<code>Spring</code>这是某个类的实例。我们要用到第三方库的类时，就需要用<code>@Bean</code>把它装配到容器中。</p>
</li>
</ul>
<hr>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>在<code>Spring</code>中，管理事务的方式有两种：</p>
<ul>
<li>编程式事务，也就是硬编码的方式。并不推荐使用。</li>
<li>声明式事务，也就是在配置文件中配置。分为<code>xml</code>配置和注解配置。推荐使用。</li>
</ul>
<p>使用声明式事务注解配置的方式，只需要在方法或者类上加上<code>@Transactional</code>注解即可。其底层也是建立在<code>Spring AOP</code>的基础上，在方法执行的前后进行拦截，在目标方法执行前创建一个事务或者加入一个已存在的事务，最后在方法执行完根据情况提交事务或者回滚。</p>
<p><code>@Transactional</code>有几个参数：</p>
<ul>
<li><code>propagation</code>：事务传播行为，默认为<strong>REQUIRED</strong>。</li>
<li><code>isolation</code>：事务隔离级别，默认为<strong>READ_COMMITED</strong>。</li>
<li><code>rollbackFor</code>：回滚的异常类型，默认对所有<strong>运行时异常</strong>进行回滚。</li>
<li><code>readOnly</code>：指定事务是否为只读，默认为<strong>false</strong>。</li>
<li><code>timeout</code>：指定回滚的超时时间，单位是秒。默认不使用。</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p><code>Spring</code>的事务隔离级别分为五级：</p>
<ul>
<li><code>Isolation_DEFAULT</code>：使用后端数据库默认的隔离级别。<code>MySQL</code>默认的是<code>REPEATABLE_READ</code>，<code>Oracle</code>默认的是<code>READ_COMMITED</code>。</li>
<li><code>Isolation_READ_UNCOMMITED</code>：未提交读。允许读取尚未提交的数据变更，可能会造成脏读、幻读、不可重复读。</li>
<li><code>Isolation_READ_COMMITED</code>：提交读。允许读取并发事务中已提交的数据，可能会造成幻读和不可重复读。</li>
<li><code>Isolation_REPEATABLE_READ</code>：可重复读。保证对同一个字段多次读取的结果都是一样的，可能会造成幻读。</li>
<li><code>Isolation_SERIALIZABLE</code>：序列化。最高的隔离级别。所有事务逐个执行，这样事务之间就不可能产生干扰。但是该级别事务执行的效率非常低。</li>
</ul>
<h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>支持当前事务的情况：</p>
<ul>
<li><code>Propagation.REQUIRED</code>：如果当前存在事务，加入该事务；如果没有，创建一个新事务。</li>
<li><code>Propagation.SUPPORTS</code>：如果当前存在事务，加入该事务；如果没有，以非事务的方式执行。</li>
<li><code>Propagation.MANDATORY</code>：如果当前存在事务，加入该事务；如果没有，抛出异常。</li>
</ul>
<p>不支持当前事务的情况：</p>
<ul>
<li><code>Propagation.REQUIRES_NEW</code>：创建一个新事务。如果当前存在事务，将其挂起。</li>
<li><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式执行。如果当前存在事务，将其挂起。</li>
<li><code>Propagation.NEVER</code>：以非事务的方式执行。如果当前存在事务，抛出异常。</li>
</ul>
<p>还有一种<code>Propagation.NESTED</code>：如果当前存在事务，就创建一个事务作为当前事务的嵌套事务运行；如果没有，该配置等价于<code>Propagation.REQUIRED</code>。</p>
<hr>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><code>Spring</code>中<code>Bean</code>的生命周期如下：</p>
<ul>
<li>容器利用反射实例化<code>Bean</code>，如果涉及属性值就调用<code>set</code>方法赋值。</li>
<li>如果<code>Bean</code>实现了<code>BeanNameAware</code>接口，就调用<code>setBeanName()</code>方法，传入<code>Bean</code>的名字。</li>
<li>类似的，如果实现了其他<code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果<code>Bean</code>实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果<code>Bean</code>在配置文件中的定义包含<code>init-method</code>属性，则调用配置的初始化方法。</li>
<li>如果有和加载这个<code>Bean</code>的<code>Spring</code>容器相关的<code>BeanPostProcessor</code>对象，则执行<code>postProcessAfterInitialization()</code>方法。</li>
<li>使用阶段。</li>
<li>要销毁<code>Bean</code>时，如果实现了<code>DisposableBean</code>接口，就执行<code>destroy()</code>方法。</li>
<li>如果这个<code>Bean</code>配置了<code>destroy-method</code>属性，调用配置的销毁方法。</li>
</ul>
<hr>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p><code>MVC</code>是一种设计模式，将代码分为多层，降低耦合度，也方便后期的维护和扩展。而<code>Spring MVC</code>是基于该设计模式的一款框架。我们一般把项目分为<code>entity</code>层、<code>dao</code>层、<code>service</code>层、<code>controller</code>层。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li>客户端发起请求，请求到达<code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code>根据请求的信息调用<code>HandlerMapping</code>，解析请求对应的<code>Handler</code>。</li>
<li>解析到对应的<code>handler</code>之后，由<code>HandlerAdapter</code>适配器处理。</li>
<li><code>HandlerAdapter</code>根据<code>Handler</code>调用处理器处理请求，以及相应的业务逻辑。</li>
<li>处理完业务之后，返回一个<code>ModelAndView</code>对象。</li>
<li><code>ViewResolver</code>对传来的对象进行解析，返回<code>View</code>。</li>
<li><code>DispatcherServlet</code>把返回的<code>Model</code>传给<code>View</code>进行渲染。</li>
<li>最后<code>View</code>返回给请求端。</li>
</ol>
<hr>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><h4 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h4><p>从字面上的意思来看，就是：假设有两个<code>Bean A、B</code>，<code>A</code>依赖<code>B</code>的同时<code>B</code>又依赖<code>A</code>。用代码体现就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种比较特殊的循环依赖，就是自己依赖自己：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么情况下可以处理循环依赖"><a href="#什么情况下可以处理循环依赖" class="headerlink" title="什么情况下可以处理循环依赖"></a>什么情况下可以处理循环依赖</h4><p><code>Spring</code>解决循环依赖问题是有条件的：</p>
<ul>
<li>出现循环依赖的<code>Bean</code>必须是单例的。</li>
<li>依赖注入的方式不能全是构造器注入。</li>
</ul>
<p>对于第一点，如果<code>Bean</code>是原型模式的话，是不支持循环依赖的，在获取<code>Bean</code>时会抛出<code>BeanCurrentlyInCreationException</code>异常。</p>
<p><img src="%E5%8E%9F%E5%9E%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt=""></p>
<p>因为在创建<code>A</code>时，要注入<code>B</code>的原型，于是又去创建<code>B</code>，发现要注入<code>A</code>的原型，就类似于死锁了。</p>
<p>对于第二点，如果两个<code>Bean</code>都是构造器注入的话，同样会报<code>BeanCurrentlyInCreationException</code>错误。</p>
<h4 id="Spring-如何解决循环依赖"><a href="#Spring-如何解决循环依赖" class="headerlink" title="Spring 如何解决循环依赖"></a>Spring 如何解决循环依赖</h4><p>解决循环依赖的方式要分两种情况来讨论：</p>
<ul>
<li>没有<code>AOP</code>的循环依赖</li>
<li>结合<code>AOP</code>的循环依赖</li>
</ul>
<p>首先，<code>Spring</code>创建<code>Bean</code>的时候是根据自然排序的顺序来创建的，也就是说<code>A</code>会先被创建。</p>
<p>创建<code>Bean</code>分三个步骤：</p>
<ol>
<li>实例化，具体在<code>AbstractAutowireCapableBeanFactory</code>的<code>createBeanInstance</code>方法。</li>
<li>属性注入，具体在<code>AbstractAutowireCapableBeanFactory</code>的<code>populateBean</code>方法。</li>
<li>初始化，具体在<code>AbstractAutowireCapableBeanFactory</code>的<code>initializeBean</code>方法。</li>
</ol>
<p>所以整个流程以<code>A</code>的创建为起点，调用<code>getBean</code>方法。该方法有两层含义：</p>
<ul>
<li>创建一个新的<code>Bean</code>。</li>
<li>从缓存中获取已创建的对象。</li>
</ul>
<p>一开始没有缓存的时候，先调用<code>getSingleton(beanName)</code>方法，该方法又会调用<code>getSingleton(beanName, true)</code>。这个方法从缓存中尝试获取<code>Bean</code>，整个缓存分为三级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>singletonObjects</code>：一级缓存，存储的是所有创建好了的单例<code>Bean</code>。</li>
<li><code>earlySingletonObjects</code>：二级缓存，存储的是完成实例化，但还没有进行属性注入和初始化的对象。</li>
<li><code>singletonFactories</code>：三级缓存，存储的是提前暴露的一个单例工厂对象，二级缓存中存储的对象就是这个从工厂获取到的。</li>
</ul>
<p>一开始无论哪个缓存中都是没有<code>A</code>的，因此会进入<code>getSingleton</code>的另一个重载方法<code>getSingleton(beanName, singletonFactory)</code>。这个方法就是用来创建<code>Bean</code>的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将beanName放入singletonsCurrentlyInCreation集合中标记该Bean正在创建中</span></span><br><span class="line">            <span class="comment">// 如果单例Bean被多次创建就会抛出BeanCurrentlyInCreationException异常</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用createBean方法创建Bean返回</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                <span class="comment">// 如果没有异常说明是第一次创建的</span></span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// catch异常代码</span></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将beanName放入singletonsCurrentlyInCreation集合中移除</span></span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">// 如果是第一次创建该Bean，将其放到一次缓存中</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以以上代码主要是创建<code>Bean</code>，将它放到一级缓存中并且返回该<code>Bean</code>。</p>
<p>完成了实例化，进行属性的注入。在属性注入之前，要将<code>Bean</code>包装为一个工厂添加到三级缓存中。对应源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">"Singleton factory must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 添加到三级缓存中</span></span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>ObjectFactory</code>这个工厂的<code>getObject</code>方法就可以得到<code>Bean</code>的实例对象。而这个对象是通过<code>getEarlyBeanReference</code>方法创建的。那么什么时候会调用<code>getObject</code>方法呢？这就要等到创建<code>B</code>的时候了。</p>
<p>将<code>A</code>添加到三级缓存后，就要开始注入属性了。在注入时，发现<code>A</code>依赖<code>B</code>，于是又去调用<code>getBean(b)</code>。在创建<code>B</code>的时候又要注入<code>A</code>，于是又回到刚才的流程。但这次会直接从三级缓存中获取。从前面的方法可以看出，添加到三级缓存中的<code>Bean</code>还不是一个完整的<code>Bean</code>，只是通过<code>getEarlyBeanReference</code>方法提前暴露出的一个对象。来看看<code>getEarlyBeanReference</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">            exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code>包裹的代码调用了后置处理器的<code>getEarlyBeanReference</code>，而真正实现了这个方法的后置处理器只有一个，就是通过<code>@EnableAspectJAutoProxy</code>注解导入的<code>AnnotationAwareAspectJAutoProxyCreator</code>。也就是说如果没有<code>AOP</code>的情况下，上述代码就相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说这个方法就直接将<code>Bean</code>对象返回了而已。那为什么还要三级缓存呢？直接放到二级缓存不也可以吗？这就要看结合<code>AOP</code>的情况了。</p>
<p>开启<code>AOP</code>的时候，相当于调用了<code>AnnotaionAwareAspectJAutoProxyCreator</code>的<code>getEarlyBeanReference</code>方法，其源码在父类<code>AbstractAutoProxyCreator</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">    <span class="comment">// 如果开启了代理，返回代理对象，否则直接返回参数中的bean对象。</span></span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们对<code>A</code>开启了<code>AOP</code>，该方法会返回<code>A</code>的代理对象。也就是说到时候注入<code>B</code>的并不是实例化阶段创建的<code>A</code>对象而是它的代理。</p>
<p>但初始化的时候明明是<code>A</code>对象，<code>Spring</code>是什么时候把代理对象放入容器中的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化完成后的对象</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// false相当于禁用三级缓存，从二级缓存中获取代理后的Bean</span></span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                <span class="comment">// 将原来的Bean替换为代理对象加入一级缓存</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说为什么要三级缓存呢？前面提到，三级缓存存储的只是一个工厂对象，这里的工厂主要是为了延迟创建代理的时机。只有当循环依赖发生的时候，才会提前生成代理对象，否则只会创建一个工厂放入三级缓存中。为啥要这样呢？</p>
<p>假设现在没有循环依赖，单独创建<code>A</code>，并且开启了<code>AOP</code>。那么<code>A</code>完成实例化之后还是会进入下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mbd.isSingleton()满足，因为A是单例的。</span></span><br><span class="line"><span class="comment">// this.allowCircularReferences也满足，此变量代表是否允许循环依赖，默认允许。</span></span><br><span class="line"><span class="comment">// isSingletonCurrentlyInCreation(beanName)：此变量表示现在是否正在创建A，所以也满足。</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                  isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                     <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建工厂放入三级缓存</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说无论有没有循环依赖的发生，<code>Spring</code>都会把<code>Bean</code>放到三级缓存中，这是因为<code>Spring</code>目前还没办法判断该<code>Bean</code>是否会出现循环依赖。</p>
<p>如果我们不使用三级缓存，那就意味着所有的<code>Bean</code>都要在这一步创建好代理对象，并且放入二级缓存。这样做有什么不好呢？这是因为这违背了<code>Spring</code>结合<code>AOP</code>跟<code>Bean</code>的生命周期的设计。<code>Spring</code>结合<code>AOP</code>跟<code>Bean</code>的生命周期是通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个后置处理器中的<code>postProcessAfterInstantiation</code>方法来完成对初始化之后的<code>Bean</code>的代理。如果发生了循环依赖，才没有办法只能在实例化之后直接创建代理对象。如果没有发生循环依赖不应该破坏原来的生命周期。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Q</code>：<code>Spring</code>如何解决循环依赖？</p>
<p><code>A</code>：<code>Spring</code>通过三级缓存解决了循环依赖。当两个<code>Bean</code>发生了循环依赖的时候，在<code>A</code>完成了实例化之后，创建它的对象工厂，添加到三级缓存中。如果<code>A</code>被代理了，后续通过这个工厂获得的对象就是代理之后的对象，否则就获得原来的对象。当<code>A</code>进行属性注入时，会去创建<code>B</code>，创建<code>B</code>的时候又会去获取<code>A</code>，但这次是从缓存里拿了。首先获取到三级缓存中的对象工厂，然后调用<code>getObject</code>方法获取对象放到二级缓存并注入到<code>B</code>，然后<code>B</code>会完成自己的生命周期，放到一级缓存中。最后<code>A</code>再注入<code>B</code>，完成自己的生命周期，也放到一级缓存中。至此，循环依赖的问题就解决了。</p>
<p><code>Q</code>：为什么要使用三级缓存呢？可以使用二级缓存吗？</p>
<p><code>A</code>：可以使用二级缓存，但这样的话所有的<code>Bean</code>都要在实例化之后就直接创建<code>AOP</code>对象放入二级缓存，这违背了<code>Spring</code>对于<code>AOP</code>的设计原则。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot笔记</title>
    <url>/2021/01/17/SpringBoot%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>SpringBoot笔记</p>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Spring Boot</code>是<code>Spring</code>开源组织下的一个子项目，提供了<code>Spring</code>组件的一站式解决方案，大大简化了<code>Spring</code>的开发难度，省去了大量繁重的配置，提供了各种启动器，实现了真正的开箱即用。</p>
<hr>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p><code>SpringBoot</code>启动类的注解是<code>@SpringBootApplication</code>，该注解包含了以下三个重要注解：</p>
<ul>
<li><code>@SpringBootConfiguration</code>：包含<code>@Configuration</code>注解，实现了配置文件的功能。</li>
<li><code>@EnableAutoConfiguration</code>：自动配置。如果要关闭某个自动配置的选项，例如关闭数据源的自动配置：<code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})</code>。</li>
<li><code>@ComponentScan</code>：组件扫描功能。</li>
</ul>
<hr>
<h3 id="JavaConfig"><a href="#JavaConfig" class="headerlink" title="JavaConfig"></a>JavaConfig</h3><p><code>Spring JavaConfig</code>是<code>Spring</code>社区的产品，提供了配置<code>Spring IoC</code>容器的<code>Java</code>方法。使用<code>JavaConfig</code>有如下好处：</p>
<ul>
<li>面向对象的配置。因为配置被定义为<code>JavaConfig</code>的类，所以可以充分的利用<code>Java</code>中面向对象的功能。一个配置类可以继承另一个，重写<code>@Bean</code>方法等等。</li>
<li>省去<code>XML</code>配置。<code>JavaConfig</code>提供了纯<code>Java</code>方法来配置与<code>XML</code>配置概念相似的<code>Spring</code>容器。</li>
<li>类型安全、重构友好。<code>JavaConfig</code>提供了一种类型安全的方法来配置<code>Spring</code>容器。由于<code>Java 5.0</code>对泛型的支持，可以按照类型而不是名称检索<code>Bean</code>，不需要任何强制转换或者基于字符串的查找。</li>
</ul>
<hr>
<h3 id="SpringBoot-自动配置原理"><a href="#SpringBoot-自动配置原理" class="headerlink" title="SpringBoot 自动配置原理"></a>SpringBoot 自动配置原理</h3><p><code>SpringBoot</code>关于自动配置的源码在<code>spring-boot-autoconfigure-x.x.x.x.jar</code>中。</p>
<p>在<code>SpringBoot</code>启动类上有一个<code>@SpringBootApplication</code>注解，它是一个复合注解，其中有一个<code>@EnableAutoConfiguration</code>注解，用于开启自动配置。<code>@EnableAutoConfiguration</code>也是一个复合注解，核心功能由<code>@Import</code>提供。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AutoConfigurationImportSelector</code>类中有一个方法<code>selectImports()</code>，通过<code>SpringFactoriesLoader.loadFactoryNames()</code>扫描所有具有<code>META-INF/spring.factories</code>的<code>jar</code>包。</p>
<p><code>spring.factories</code>的格式是一组一组的<code>key=value</code>，其中有一个<code>key</code>是<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>，它的<code>value</code>是一个<code>xxxAutoConfiguration</code>的列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>@EnableAutoConfiguration</code>注解通过<code>@SpringBootApplication</code>被标记在了<code>SpringBoot</code>启动类上，于是<code>SpringApplication.run()</code>方法就会执行<code>selectImports()</code>方法，找到所有<code>JavaConfig</code>自动配置类的全限定名对应的<code>class</code>，将所有自动配置类加载到容器中。</p>
<p>每个<code>xxxAutoConfiguration</code>自动配置类都是在某些条件下才生效的。常见的条件有以下几个：</p>
<ul>
<li><code>@ConditionalOnBean</code>：当容器内有指定的<code>Bean</code>的条件下。</li>
<li><code>@ConditionalOnMissingBean</code>：当容器内不存在指定的<code>Bean</code>的条件下。</li>
<li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下。</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下不存在指定类的条件下。</li>
<li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值。例如：<code>@ConditionalOnProperty(prefix=&quot;spring.rabbitmq&quot;, value=&quot;dynamic&quot;, matchIfMissing=true)</code>表示<code>spring.rabbitmq</code>的值为<code>dynamic</code>或者没有设置的情况下满足该条件。</li>
</ul>
<p>以<code>RabbitAutoConfiguration</code>为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; RabbitTemplate<span class="class">.<span class="keyword">class</span>, <span class="title">Channel</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">RabbitProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(<span class="title">RabbitAnnotationDrivenConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RabbitAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@EnableConfigurationProperties</code>注解用于开启配置属性，传入了<code>RabbitProperties.class</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.rabbitmq"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">5672</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT_SECURE = <span class="number">5671</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String host = <span class="string">"localhost"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String username = <span class="string">"guest"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String password = <span class="string">"guest"</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@ConfigurationProperties</code>注解用于从配置文件中绑定属性到对应的<code>Bean</code>上。我们看到这些属性有默认的值，也就是说如果我们没有在配置文件中指定这些值，<code>Spring</code>会使用默认的值，最后通过<code>@EnableConfigurationProperties</code>将<code>Bean</code>导入到<code>Spring</code>容器中。</p>
<p>总的来说，<code>SpringBoot</code>启动的时候会通过<code>@EnableAutoConfiguration</code>注解找到<code>META-INF/spring.factories</code>配置文件中的所有自动配置类，对它们进行加载。这些自动配置类都是以<code>AutoConfiguration</code>结尾来命名的，实际上就是一个<code>JavaConfig</code>形式的<code>Spring</code>容器配置类，它能通过以<code>Properties</code>结尾命名的类中获取全局配置文件中配置的属性，如：<code>spring.rabbitmq</code>。然后以<code>Properties</code>结尾命名的类通过<code>@ConfigurationProperties</code>注解将配置的属性绑定到相应的<code>Bean</code>上。</p>
<hr>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsWebFilter <span class="title">corsWebFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration configuration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">// 配置跨域</span></span><br><span class="line">        configuration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        configuration.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">        configuration.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// 允许携带cookie</span></span><br><span class="line">        configuration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 对所有访问路径注册跨域配置</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, configuration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="spring-boot-starter-parent"><a href="#spring-boot-starter-parent" class="headerlink" title="spring-boot-starter-parent"></a>spring-boot-starter-parent</h3><p><code>spring-boot-starter-parent</code>主要有以下作用：</p>
<ul>
<li>定义<code>Java</code>编译版本为<code>1.8</code>。</li>
<li>使用<code>UTF-8</code>格式编码。</li>
<li>继承自<code>spring-boot-dependencies</code>，定义了各种依赖的版本，所以我们在添加依赖的时候才不需要指定版本。</li>
<li>执行打包操作的配置。</li>
<li>自动化资源过滤。</li>
<li>自动化插件配置。</li>
</ul>
<hr>
<h3 id="SpringBoot-打包的-jar-包和普通的有什么区别？"><a href="#SpringBoot-打包的-jar-包和普通的有什么区别？" class="headerlink" title="SpringBoot 打包的 jar 包和普通的有什么区别？"></a>SpringBoot 打包的 jar 包和普通的有什么区别？</h3><p><code>SprintBoot</code>打包的<code>jar</code>包是可执行的<code>jar</code>，可以直接通过<code>java -jar xxx.jar</code>运行，而且不可以作为普通的<code>jar</code>被其他项目依赖。</p>
<p>这是因为<code>SpringBoot</code>打包的<code>jar</code>和普通的结构不同。普通的<code>jar</code>包解压之后就是包名，里面就是代码；而<code>SpringBoot</code>打包的解压之后，代码在<code>/BOOT-INF/classes</code>目录下，所以不能直接被引用。</p>
<hr>
<h3 id="SpringBoot-定时任务"><a href="#SpringBoot-定时任务" class="headerlink" title="SpringBoot 定时任务"></a>SpringBoot 定时任务</h3><p><code>SpringBoot</code>有多种方式实现定时任务的功能：</p>
<ul>
<li><code>java.util.Timer</code>定时器类。不能再指定的时间运行，用的比较少。</li>
<li><code>ScheduledExecutorService</code>：基于线程池设计的定时任务类。每个调度任务都会分配到线程池中的一个线程去执行。</li>
<li>基于<code>@Scheduled</code>的定时任务。比较轻量级，使用简单。</li>
<li><code>Quartz</code>定时器。功能比较强大，可以在指定的时间执行任务，也可以指定执行的时间间隔。</li>
</ul>
<h4 id="Scheduled"><a href="#Scheduled" class="headerlink" title="@Scheduled"></a>@Scheduled</h4><p><code>@Scheduled</code>是<code>Spring</code>提供的一个注解，有以下几个主要参数：</p>
<ul>
<li><code>fixedRate</code>：定时任务开始后再次执行的时间间隔（不需要等待上次定时任务执行完成），单位毫秒。</li>
<li><code>fixedDelay</code>：定时任务执行完成后再次执行的时间间隔（需要等待上次定时任务执行完成），单位毫秒。</li>
<li><code>initialDelay</code>：首次执行任务的延迟时间。</li>
<li><code>cron</code>：通过<code>cron</code>表达式定义定时规则。</li>
</ul>
<h5 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h5><p>一个<code>cron</code>表达式有<code>6</code>个或<code>7</code>个用空格间隔的时间元素。</p>
<ul>
<li>秒（<code>0-59</code>）</li>
<li>分（<code>0-59</code>）</li>
<li>时（<code>0-23</code>）</li>
<li>天（<code>1-31</code>）</li>
<li>月（<code>1-12</code>或<code>JAN-DEC</code>）</li>
<li>星期（<code>1-7</code>或<code>SUN-SAT</code>）</li>
<li>年份（<code>1970-2099</code>）</li>
</ul>
<p>每个元素可以是一个值（<code>5</code>）、一个区间（<code>5-10</code>）、一个间隔时间（<code>5-10/2</code>，时的话表示每隔两小时）、一个列表（<code>1,3,5</code>）或者通配符。</p>
<ul>
<li><code>*</code>表示所有可能的值。</li>
<li><code>/</code>表示指定数值的增量。</li>
<li><code>?</code>表示不指定值。仅用于日期和星期字段。</li>
<li><code>L</code>表示最后的意思。仅用于日期和星期字段。</li>
<li><code>W</code>表示离该日期最近的工作日。仅用于日期字段。</li>
<li><code>#</code>表示当月某个日期。仅在星期字段使用。</li>
<li><code>C</code>表示计划所关联的日期。如果日期没有被关联，就相当于日历中所有日期。仅用于日期和星期字段。</li>
</ul>
<p>示例：</p>
<p><img src="cron%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt=""></p>
<h4 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h4><p><code>Spring Boot 2.0.0</code>之后，在<code>spring-boot-starter</code>中包含了<code>quartz</code>依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建业务类，继承<code>QuartzJobBean</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestQuartz</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体业务逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"quartz task: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给TestQuartz创建定时任务</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">jobDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        return JobBuilder.newJob(TestQuartz.class).withIdentity("test").storeDurably().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务触发器，每5秒触发一次。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">trigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger().forJob(jobDetail()).withIdentity(<span class="string">"test"</span>).withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"/5 * * * * ?"</span>)).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动类添加注解开启定时任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(QuartzDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序可以看到每<code>5</code>秒执行一次任务。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>netty学习笔记</title>
    <url>/2021/02/20/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>netty 学习笔记</p>
<a id="more"></a>

<h3 id="NIO-基本概念"><a href="#NIO-基本概念" class="headerlink" title="NIO 基本概念"></a>NIO 基本概念</h3><h4 id="阻塞、非阻塞"><a href="#阻塞、非阻塞" class="headerlink" title="阻塞、非阻塞"></a>阻塞、非阻塞</h4><p>阻塞于非阻塞指的是进程访问数据的时候当数据没有准备就绪时的处理方式。</p>
<ul>
<li>阻塞：需要等到缓冲区中的数据准备好才去处理其他事情，否则一直等在原地。</li>
<li>非阻塞：无论数据有没有准备好，都直接返回，不会等待。</li>
</ul>
<h4 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h4><p>同步和异步指的是进程和操作系统处理<code>IO</code>事件的方式。</p>
<ul>
<li>同步：应用程序直接参与<code>IO</code>读写的操作，必须阻塞等待<code>IO</code>事件的完成（阻塞或者轮询）。</li>
<li>异步：把<code>IO</code>事件交给操作系统处理，应用程序等待通知。在等待的期间可以去完成其他的操作。</li>
</ul>
<h4 id="Java-BIO-与-NIO"><a href="#Java-BIO-与-NIO" class="headerlink" title="Java BIO 与 NIO"></a>Java BIO 与 NIO</h4><h5 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h5><p><code>BIO</code>是<code>Java</code>传统的<code>IO</code>模型，基于同步阻塞的<code>IO</code>模式，所以所有的交互都是同步并且阻塞的。</p>
<h5 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h5><p><code>NIO</code>是<code>Java 1.4</code>引入的，基于同步非阻塞的<code>IO</code>模式，提供了<code>Channel</code>、<code>Selector</code>、<code>Buffer</code>等抽象。对于高并发的场景，应该使用<code>NIO</code>模式来开发应用。</p>
<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><table>
<thead>
<tr>
<th>IO 模型</th>
<th>通信</th>
<th>处理</th>
<th>触发</th>
</tr>
</thead>
<tbody><tr>
<td>BIO</td>
<td>面向流</td>
<td>阻塞 IO</td>
<td>无</td>
</tr>
<tr>
<td>NIO</td>
<td>面向缓冲</td>
<td>非阻塞 IO</td>
<td>选择器</td>
</tr>
</tbody></table>
<hr>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>Netty</code>是一个基于<code>NIO</code>的客户端服务器框架，用于快速开发高性能的应用程序。</p>
<p><code>Netty</code>的主要执行流程：</p>
<ul>
<li>启动<code>Server</code>，<code>Netty</code>从<code>ParentGroup</code>中选出一个<code>NioEventLoop</code>监听指定的端口。</li>
<li>启动<code>Client</code>，<code>Netty</code>从<code>EventLoopGroup</code>中选出一个<code>NioEventLoop</code>连接<code>Server</code>并处理<code>Server</code>发送的数据。</li>
<li><code>Client</code>连接到<code>Server</code>，创建<code>Channel</code>。</li>
<li><code>Netty</code>从<code>ChildGroup</code>中选出一个<code>NioEventLoop</code>和该<code>Channel</code>绑定，处理<code>Channel</code>中所有的操作。</li>
<li><code>Client</code>通过<code>Channel</code>向<code>Server</code>发送数据。</li>
<li><code>Pipeline</code>中的处理器一次对<code>Channel</code>中的数据包进行处理。</li>
<li><code>Server</code>如果要向<code>Client</code>发送数据，要将数据经过<code>Pipeline</code>的处理器处理封装为<code>ByteBuf</code>数据包进行传输。</li>
<li><code>Server</code>通过<code>Channel</code>将数据包发送给<code>Client</code>。</li>
<li><code>Pipeline</code>中的处理器一次对<code>Channel</code>中的数据包进行处理。</li>
</ul>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><h5 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h5><p><code>Channel</code>可以看作是数据传输的媒介，服务器和客户端通过<code>Channel</code>进行数据的发送和接收。因此，它可以被打开或关闭、连接或断开连接。</p>
<h5 id="EventLoop-和-EventLoopGroup"><a href="#EventLoop-和-EventLoopGroup" class="headerlink" title="EventLoop 和 EventLoopGroup"></a>EventLoop 和 EventLoopGroup</h5><p><code>EventLoop</code>定义了<code>Netty</code>的核心抽象，用来处理连接的生命周期中发生的事件，在内部，为每一个<code>Channel</code>分配一个<code>EventLoop</code>。而<code>EventLoopGroup</code>是一个<code>EventLoop</code>池，包含很多<code>EventLoop</code>。</p>
<p><code>Netty</code>给每个<code>Channel</code>分配一个<code>EventLoop</code>，处理用户连接请求、对用户请求进行处理。<code>EventLoop</code>只是一个线程驱动，在其生命周期内只会绑定一个线程，让该线程处理一个<code>Channel</code>的所有<code>IO</code>事件。</p>
<p>一个<code>Channel</code>一旦和一个<code>EventLoop</code>绑定，那么整个生命周期内是不可改变的。一个<code>EventLoop</code>可以和多个<code>Channel</code>绑定。</p>
<h5 id="ServerBootstrap-和-Bootstrap"><a href="#ServerBootstrap-和-Bootstrap" class="headerlink" title="ServerBootstrap 和 Bootstrap"></a>ServerBootstrap 和 Bootstrap</h5><p><code>ServerBootstrap</code>和<code>Bootstrap</code>被称为引导类，指对应用程序进行配置，使其运行起来的过程。<code>Netty</code>处理引导的方式是使应用程序和网络层相互隔离。</p>
<p><code>Bootstrap</code>是客户端的引导类，在调用<code>bind()</code>（连接<code>UDP</code>）和<code>connect()</code>（连接<code>TCP</code>）时，会创建一个<code>Channel</code>，仅创建一个独立的、没有父<code>Channel</code>的<code>Channel</code>来实现网络交换。</p>
<p><code>ServerBootstrap</code>是服务端的引导类，在调用<code>bind()</code>时会创建一个<code>ServerChannel</code>接收来自客户端的连接请求，该<code>ServerChannel</code>管理了多个子<code>Channel</code>用于和客户端之间的通信。</p>
<h5 id="ChannelHandler-和-ChannelPipeline"><a href="#ChannelHandler-和-ChannelPipeline" class="headerlink" title="ChannelHandler 和 ChannelPipeline"></a>ChannelHandler 和 ChannelPipeline</h5><p><code>ChannelHandler</code>是对<code>Channel</code>中的数据的处理器，这些处理器可以是系统定义好的也可以是自定义的。这些处理器会被统一添加到一个<code>ChannelPipeline</code>对象中，按照添加的顺序对<code>Channel</code>中的数据依次进行处理。</p>
<h5 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h5><p><code>Netty</code>中的<code>IO</code>操作是异步的，所以操作并不会立刻得到返回结果。<code>Netty</code>定义了一个<code>ChannelFuture</code>对象表示异步操作。如果想获得异步操作的返回值，可以通过这个对象的<code>addListener()</code>方法为该异步操作添加监听器，注册回调。</p>
<p><code>Netty</code>的异步编程模型都是建立在<code>Future</code>与回调概念之上。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat笔记</title>
    <url>/2021/02/20/tomcat%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>tomcat 笔记</p>
<a id="more"></a>

<h3 id="Tomcat-是什么"><a href="#Tomcat-是什么" class="headerlink" title="Tomcat 是什么"></a>Tomcat 是什么</h3><p><code>Tomcat</code>是一款<code>Apache</code>开源的<code>web</code>应用服务器，属于轻量级应用服务器，提供了对<code>jsp</code>和<code>servlet</code>的支持。</p>
<hr>
<h3 id="Tomcat-默认端口"><a href="#Tomcat-默认端口" class="headerlink" title="Tomcat 默认端口"></a>Tomcat 默认端口</h3><p>在<code>Tomcat</code>目录下的<code>conf</code>文件夹下的<code>server.xml</code>文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认端口为<code>8080</code>。</p>
<hr>
<h3 id="Connector-运行模式"><a href="#Connector-运行模式" class="headerlink" title="Connector 运行模式"></a>Connector 运行模式</h3><ul>
<li><code>BIO</code>：同步阻塞。一个线程处理一个请求。<code>Tomcat 7</code>之前<code>Linux</code>默认使用这种模式。当并发量高的时候，线程数过多，比较浪费资源。配置：<code>protocol=&quot;HTTP/1.1&quot;</code>。</li>
<li><code>NIO</code>：同步非阻塞。可以通过少量的线程处理大量请求，相当于复用同一个线程处理多个连接请求。<code>Tomcat 8</code>在<code>Linux</code>系统中默认使用这种模式。配置：<code>protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</code>。</li>
<li><code>APR</code>：<code>Apache Portable Runtime</code>，从操作系统层面解决<code>IO</code>阻塞问题，大幅度提高服务器的处理和响应性能，相当于异步非阻塞。配置：<code>protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</code>。</li>
</ul>
<hr>
<h3 id="Tomcat-如何创建-servlet-实例"><a href="#Tomcat-如何创建-servlet-实例" class="headerlink" title="Tomcat 如何创建 servlet 实例"></a>Tomcat 如何创建 servlet 实例</h3><p>当容器启动时，会读取<code>webapps</code>目录下所有的<code>web</code>应用中的<code>web.xml</code>文件，对其进行解析，读取<code>servlet</code>注册信息。然后将每个应用中注册的<code>servlet</code>类进行加载，通过反射的方式创建实例。</p>
<p>如果<code>servlet</code>注册时设置的<code>loadOnStartup</code>小于<code>0</code>，那么<code>servlet</code>在第一次被调用的时候才会实例化。如果大于<code>0</code>，则是在<code>web</code>容器启动时候实例化，并且按照数字的大小由小到大按顺序实例化。如果等于<code>0</code>，相当于最大整数，意味着会在最后被实例化。</p>
<hr>
<h3 id="Tomcat-顶层架构"><a href="#Tomcat-顶层架构" class="headerlink" title="Tomcat 顶层架构"></a>Tomcat 顶层架构</h3><p><code>Tomcat</code>顶层架构图如下：</p>
<p><img src="tomcat%E6%9E%B6%E6%9E%84.png" alt=""></p>
<p>最顶层的是<code>Server</code>，表示服务器，每个服务器最少有一个<code>Service</code>，用于提供具体的服务。<code>Service</code>主要包含<code>Connector</code>和<code>Container</code>两个核心组件。</p>
<ul>
<li><code>Connector</code>：用于处理连接相关的事情，提供<code>Socket</code>与<code>Request</code>请求和<code>Response</code>响应相关的转化。</li>
<li><code>Container</code>：用于封装、管理<code>Servlet</code>，以及具体处理<code>Request</code>请求。</li>
</ul>
<p>一个<code>Tomcat</code>只有一个<code>Server</code>，一个<code>Server</code>可以包含多个<code>Service</code>。而一个<code>Service</code>只有一个<code>Container</code>，但是可以有多个<code>Connector</code>，用于处理多个连接。</p>
<p>整个结构可以在<code>server.xml</code>文件中体现出来：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>一个<code>Tomcat</code>只有一个<code>Server</code>，一个<code>Server</code>可以有多个<code>Service</code>，一个<code>Service</code>可以有多个<code>Connector</code>和一个<code>Container</code>。</li>
<li><code>Server</code>管理整个<code>Tomcat</code>的生命周期。</li>
<li><code>Service</code>对外提供服务。</li>
<li><code>Connector</code>用于接收请求并将请求封装为<code>Request</code>和<code>Response</code>进行具体的处理。</li>
<li><code>Container</code>用于封装和管理<code>Servlet</code>，以及具体处理请求。</li>
</ul>
<hr>
<h3 id="Connector-和-Container"><a href="#Connector-和-Container" class="headerlink" title="Connector 和 Container"></a>Connector 和 Container</h3><p><code>Connector</code>底层使用<code>Socket</code>进行连接，而<code>Request</code>和<code>Response</code>使用<code>HTTP</code>协议进行封装。所以<code>Connector</code>需要实现<code>TCP/IP</code>协议以及<code>HTTP</code>协议。</p>
<p><code>Connector</code>主要作用是接收请求，封装为<code>Request</code>和<code>Response</code>然后交给<code>Container</code>处理。那么问题来了：</p>
<ul>
<li><code>Connector</code>如何接收请求？</li>
<li><code>Connector</code>如何将请求封装为<code>Request</code>和<code>Response</code>？</li>
<li><code>Connector</code>封装完之后如何交给<code>Container</code>处理？</li>
<li><code>Container</code>处理完之后如何返回给<code>Connector</code>并返回给客户端？</li>
</ul>
<p>先看一下<code>Connector</code>的结构图：</p>
<p><img src="connector%E7%BB%93%E6%9E%84.png" alt=""></p>
<p><code>Connector</code>使用<code>ProtocolHandler</code>处理请求，不同的<code>ProtocolHandler</code>代表不同的连接类型。比如前面的<code>Http11NioProtocol</code>使用的是<code>NIOSocket</code>连接的，<code>Http11AprProtocol</code>使用的是<code>AIOSocket</code>连接的。而<code>ProtocolHandler</code>又包含了三个组件：<code>Endpoint</code>、<code>Processor</code>、<code>Adapter</code>。</p>
<ul>
<li><code>Endpoint</code>用于处理底层<code>Socket</code>的网络连接，<code>Processor</code>将<code>Endpoint</code>接收到的请求封装为<code>Request</code>，<code>Adapter</code>将<code>Request</code>交给<code>Container</code>进行处理。</li>
<li><code>Endpoint</code>用于实现<code>TCP/IP</code>协议，而<code>Processor</code>实现<code>HTTP</code>协议，所以<code>Adapter</code>将请求适配到<code>Servlet</code>容器中进行处理。</li>
<li><code>Endpoint</code>的抽象实现<code>AbstractEndpoint</code>里面定义了<code>Acceptor</code>和<code>AsyncTimeout</code>两个内部类和一个<code>Handler</code>接口。<code>Acceptor</code>监听请求，<code>AsyncTimeout</code>用于检查异步<code>Request</code>的超时，<code>Handler</code>处理接收到的<code>Socket</code>，然后调用<code>Processor</code>进行处理。</li>
</ul>
<p>最后，<code>Container</code>是如何处理请求并且返回给<code>Connector</code>呢？</p>
<p>首先，<code>Container</code>结构图如下：</p>
<p><img src="container%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p><code>Container</code>内部包含了<code>4</code>个子容器，分别是：</p>
<ul>
<li><code>Engine</code>：引擎，用来管理多个站点，一个<code>Service</code>最多只能有一个<code>Engine</code>。</li>
<li><code>Host</code>：表示一个站点，也可以叫虚拟主机，通过配置<code>Host</code>就可以添加站点。</li>
<li><code>Context</code>：代表一个应用程序，对应平时开发的程序或者<code>WEB-INF</code>目录以及下面的<code>web.xml</code>文件。</li>
<li><code>Wrapper</code>：每个<code>Wrapper</code>封装着一个<code>Servlet</code>。</li>
</ul>
<p><code>Host</code>与<code>Context</code>的区别就是<code>Context</code>表示一个应用，<code>Tomcat</code>默认配置下<code>webapps</code>目录下的每一个目录都是一个<code>Context</code>，<code>ROOT</code>目录存放主应用，其他目录存放子应用，整个<code>webapps</code>就是一个<code>Host</code>。</p>
<p><code>Container</code>处理请求是通过<code>Pipeline-Valve</code>管道来处理的。<code>Pipeline-Valve</code>采用责任链模式，一个请求会有很多处理者依次进行处理，每个处理者负责自己的部分，处理完将结果返回，传给下一个处理者继续处理。</p>
<p>但是<code>Pipeline-Valve</code>使用的责任链模式与普通的有些不同，主要有以下两点：</p>
<ul>
<li>每个<code>Pipeline</code>都有自己的<code>Valve</code>，而且是在管道的最后执行，这个<code>Valve</code>叫做<code>BaseValve</code>，不可删除。</li>
<li>上层容器的管道的<code>BaseValve</code>会调用下层容器的管道。</li>
</ul>
<p><code>Container</code>包含的<code>4</code>个子容器对应的<code>BaseValve</code>是<code>StandardEngineValve</code>、<code>StandardHostValve</code>、<code>StandardContextValve</code>、<code>StandardWrapperValve</code>。所以<code>Pipeline</code>的处理流程图如下：</p>
<p><img src="pipeline%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt=""></p>
<ul>
<li><code>Connector</code>接收到请求后首先调用顶层容器的<code>Pipeline</code>处理，也就是<code>EnginePipeline</code>。</li>
<li>在<code>Engine</code>管道中会依次执行<code>EngineValve1</code>、<code>EngineValve2</code>等等，最后执行<code>StandardEngineValve</code>，调用<code>Host</code>管道。</li>
<li>相同的步骤一直执行到<code>StandardWrapperValve</code>，会创建<code>FilterChain</code>，调用<code>doFilter</code>方法处理请求。<code>doFilter</code>包含配置的与请求相匹配的<code>Filter</code>和<code>Servlet</code>，会依次调用所有<code>Filter</code>的<code>doFilter</code>方法和<code>Servlet</code>的<code>service</code>方法，这样请求就得到了处理。</li>
<li>当所有的<code>Pipeline-Valve</code>执行完后，<code>Container</code>处理完请求就将结果返回给<code>Connector</code>，<code>Connector</code>通过<code>Socket</code>将结果返回给客户端。</li>
</ul>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>全栈性能调优</title>
    <url>/2021/02/22/%E5%85%A8%E6%A0%88%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p>全栈性能调优</p>
<a id="more"></a>

<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="优化层面"><a href="#优化层面" class="headerlink" title="优化层面"></a>优化层面</h4><p><code>MySQL</code>数据库优化层面：</p>
<ul>
<li>商业需求：不合理需求造成资源投入产出比过低；无用功能堆积使得系统过度复杂影响整体性能。</li>
<li>系统架构：数据库中存放的数据是否都合适在数据库中存放？是否合理利用了应用层<code>Cache</code>机制？数据层实现是否是最精简的？</li>
<li><code>SQL</code>及索引优化：根据需求写出良好的<code>SQL</code>语句，创建有效的索引，了解<code>SQL</code>优化；优化的目的是减少中间结果集，降低物理<code>IO</code>。</li>
<li>数据库表结构优化：根据数据库的范式，设计表结构；适当将表进行拆分，原本需要<code>join</code>查询只需要单表查询即可。</li>
<li>系统配置优化：大多运行在<code>Linux</code>系统上，如<code>tcp</code>连接数限制、打开文件数限制、安全性的限制。</li>
<li>硬件配置优化：数据库主机的<code>IO</code>性能是最需要优先考虑的因素；数据库主机和普通的应用程序服务器相比，资源要相对集中很多，单台主机所需要进行的计算量也大很多，所以数据库主机的<code>CPU</code>处理能力也是一个重要的因素。同时数据库主机的网络设备的性能也会成为系统的瓶颈。</li>
</ul>
<h4 id="SQL-慢查询"><a href="#SQL-慢查询" class="headerlink" title="SQL 慢查询"></a>SQL 慢查询</h4><p>首先我们要对对有问题的<code>SQL</code>进行筛选。</p>
<p>查看是否开启了慢查询：<code>SHOW VARIABLES LIKE &#39;%slow_query_log%;&#39;</code>。<code>slow_query_log_file</code>为慢查询日志的位置。慢查询标准为<code>10s</code>，可以通过<code>SHOW VARIABLES LIKE &#39;%long_query%&#39;;</code>查看。</p>
<p>开启慢查询：<code>SET GLOBAL slow_query_log=ON;</code>。模拟慢查询：<code>SELECT SLEEP(12)</code>。查看日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Time: 2021-02-23T13:50:29.748865Z</span><br><span class="line"># User@Host: root[root] @  [localhost]  Id: 21457</span><br><span class="line"># Query_time: 12.001965  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 1</span><br><span class="line">use vhr;</span><br><span class="line">SET timestamp&#x3D;1614088217;</span><br><span class="line">SELECT SLEEP(12);</span><br></pre></td></tr></table></figure>

<p>来看一个实际情况。</p>
<p>我们可以设置自定义慢查询时间：<code>SET GLOBAL long_query_time=1;</code>。</p>
<p>创建一个数据库以及数据表。再写一个存储过程创建<code>100000</code>条数据，类似下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop PROCEDURE if EXISTS test;</span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line"></span><br><span class="line">create PROCEDURE test()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i int;</span><br><span class="line">set i &#x3D; 2;</span><br><span class="line">while i &lt; 100000 DO</span><br><span class="line">			INSERT INTO test(name) VALUES (CONCAT(&quot;test&quot;,i));</span><br><span class="line">			set i &#x3D; i + 1;</span><br><span class="line">end while;</span><br><span class="line">END</span><br><span class="line">$$</span><br><span class="line">delimiter ;</span><br><span class="line">CALL test();</span><br></pre></td></tr></table></figure>

<p>执行<code>UPDATE test SET name=testtest;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Time: 2021-02-23T15:02:12.010783Z</span><br><span class="line"># User@Host: root[root] @  [localhost]  Id: 21476</span><br><span class="line"># Query_time: 1.136371  Lock_time: 0.000260 Rows_sent: 0  Rows_examined: 100000</span><br><span class="line">SET timestamp&#x3D;1614092530;</span><br><span class="line">UPDATE test SET name&#x3D;&#39;testtest&#39;;</span><br></pre></td></tr></table></figure>

<p>查询的时间是<code>1.136371s</code>，锁定时间仅为<code>0.000260s</code>，一共检测了<code>100000</code>条数据，发送<code>0</code>条数据。</p>
<p>在实际生产环境中，可能会产生大量的慢查询日志。这时我们可以通过对日志的分析生成报表，通过报表进行优化。</p>
<h5 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h5><p><code>mysqldumpslow</code>是<code>mysql</code>自带的用来分析慢查询的工具。主要有以下参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]</span><br><span class="line"></span><br><span class="line">Parse and summarize the MySQL slow query log. Options are</span><br><span class="line"></span><br><span class="line">  --verbose    verbose</span><br><span class="line">  --debug      debug</span><br><span class="line">  --help       write this text to standard output</span><br><span class="line"></span><br><span class="line">  -v           verbose</span><br><span class="line">  -d           debug</span><br><span class="line">  -s ORDER     what to sort by (al, at, ar, c, l, r, t), &#39;at&#39; is default</span><br><span class="line">                al: average lock time</span><br><span class="line">                ar: average rows sent</span><br><span class="line">                at: average query time</span><br><span class="line">                 c: count</span><br><span class="line">                 l: lock time</span><br><span class="line">                 r: rows sent</span><br><span class="line">                 t: query time  </span><br><span class="line">  -r           reverse the sort order (largest last instead of first)</span><br><span class="line">  -t NUM       just show the top n queries</span><br><span class="line">  -a           don&#39;t abstract all numbers to N and strings to &#39;S&#39;</span><br><span class="line">  -n NUM       abstract numbers with at least n digits within names</span><br><span class="line">  -g PATTERN   grep: only consider stmts that include this string</span><br><span class="line">  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),</span><br><span class="line">               default is &#39;*&#39;, i.e. match all</span><br><span class="line">  -i NAME      name of server instance (if using mysql.server startup script)</span><br><span class="line">  -l           don&#39;t subtract lock time from total time</span><br></pre></td></tr></table></figure>

<p>命令行输入<code>mysqldumpslow --verbose 日志路径</code>可以看到类似的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reading mysql slow query log from &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;11e359f0dd39-slow.log</span><br><span class="line">Count: 1  Time&#x3D;803.70s (803s)  Lock&#x3D;0.00s (0s)  Rows&#x3D;0.0 (0), root[root]@[localhost]</span><br><span class="line">  CALL test()</span><br><span class="line"></span><br><span class="line">Count: 1  Time&#x3D;12.00s (12s)  Lock&#x3D;0.00s (0s)  Rows&#x3D;1.0 (1), root[root]@[localhost]</span><br><span class="line">  select SLEEP(N)</span><br><span class="line"></span><br><span class="line">Count: 1  Time&#x3D;1.02s (1s)  Lock&#x3D;0.01s (0s)  Rows&#x3D;0.0 (0), root[root]@[localhost]</span><br><span class="line">  update test set name &#x3D; &#39;S&#39;</span><br></pre></td></tr></table></figure>

<p>默认按照执行时间排序。</p>
<p><code>mysqldumpslow</code>使用很方便，但是提供的信息较少，比如<code>CPU</code>、<code>IO</code>等信息都没有。</p>
<h5 id="pt-query-digest"><a href="#pt-query-digest" class="headerlink" title="pt-query-digest"></a>pt-query-digest</h5><p><code>pt-query-digest</code>是用于分析慢查询的一个第三方工具。</p>
<p><code>pt-summary</code>可以获得服务器相关的数据，包括<code>CPU</code>、网卡、内存、硬盘等信息。</p>
<p><code>pt-diskstats</code>输出的是磁盘的<code>IO</code>数据。</p>
<p><code>pt-mysql-summary</code>可以输出数据库的相关数据。</p>
<h6 id="pt-query-digest-1"><a href="#pt-query-digest-1" class="headerlink" title="pt-query-digest"></a>pt-query-digest</h6><p>执行<code>pt-query-digest XXX.log</code>会有和下面类似的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 140ms user time, 20ms system time, 25.94M rss, 220.49M vsz</span><br><span class="line"># Current date: Wed Feb 24 01:51:42 2021</span><br><span class="line"># Hostname: irvlin</span><br><span class="line"># Files: 11e359f0dd39-slow.log</span><br><span class="line"># Overall: 4 total, 4 unique, 0.00 QPS, 0.15x concurrency ________________</span><br><span class="line"># Time range: 2021-02-23T13:50:29 to 2021-02-23T15:23:45</span><br><span class="line"># Attribute          total     min     max     avg     95%  stddev  median</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;     &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Exec time           818s      1s    804s    204s    793s    342s    403s</span><br><span class="line"># Lock time           12ms       0    11ms     3ms    11ms     5ms     6ms</span><br><span class="line"># Rows sent              1       0       1    0.25    0.99    0.43       0</span><br><span class="line"># Rows examine     195.31k       0  97.66k  48.83k  97.04k  48.52k  97.04k</span><br><span class="line"># Query size            85      11      29   21.25   28.75    8.01   28.75</span><br><span class="line"></span><br><span class="line"># Profile</span><br><span class="line"># Rank Query ID                            Response time  Calls R&#x2F;Call   V</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;</span><br><span class="line">#    1 0x7370C957789053F565147B44C0D599A5  803.6994 98.3%     1 803.6994  0.00 CALL test</span><br><span class="line"># MISC 0xMISC                               14.1655  1.7%     3   4.7218   0.0 &lt;3 ITEMS&gt;</span><br><span class="line"></span><br><span class="line"># Query 1: 0 QPS, 0x concurrency, ID 0x7370C957789053F565147B44C0D599A5 at byte 400</span><br><span class="line"># This item is included in the report because it matches --limit.</span><br><span class="line"># Scores: V&#x2F;M &#x3D; 0.00</span><br><span class="line"># Time range: all events occurred at 2021-02-23T14:42:01</span><br><span class="line">#    属性      百分比  总数      最小     最大    平均           标准差   中位数</span><br><span class="line"># Attribute    pct   total     min     max     avg     95%  stddev  median</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Count         25       1</span><br><span class="line"># Exec time     98    804s    804s    804s    804s    804s       0    804s</span><br><span class="line"># Lock time      1   149us   149us   149us   149us   149us       0   149us</span><br><span class="line"># Rows sent      0       0       0       0       0       0       0       0</span><br><span class="line"># Rows examine   0       0       0       0       0       0       0       0</span><br><span class="line"># Query size    12      11      11      11      11      11       0      11</span><br><span class="line"># String:</span><br><span class="line"># Databases    test</span><br><span class="line"># Hosts        localhost</span><br><span class="line"># Users        root</span><br><span class="line"># Query_time distribution                                      执行时间分布</span><br><span class="line">#   1us</span><br><span class="line">#  10us</span><br><span class="line"># 100us</span><br><span class="line">#   1ms</span><br><span class="line">#  10ms</span><br><span class="line"># 100ms</span><br><span class="line">#    1s</span><br><span class="line">#  10s+  ################################################################</span><br><span class="line">CALL test()\G</span><br></pre></td></tr></table></figure>

<p>以上输出分为两部分，前面是总的执行数据，后面是具体每一次的数据。如果要全部显示可以添加参数<code>--limit=100%</code>。</p>
<h6 id="pt-index-usage"><a href="#pt-index-usage" class="headerlink" title="pt-index-usage"></a>pt-index-usage</h6><p><code>pt-index-usage</code>用于分析索引的使用情况。</p>
<h6 id="pt-duplicate-key-checker"><a href="#pt-duplicate-key-checker" class="headerlink" title="pt-duplicate-key-checker"></a>pt-duplicate-key-checker</h6><p><code>pt-duplicate-key-checker</code>用于检查重复索引。</p>
<h6 id="pt-ioprofile"><a href="#pt-ioprofile" class="headerlink" title="pt-ioprofile"></a>pt-ioprofile</h6><p><code>pt-ioprofile</code>用于观察特定进程的<code>IO</code>信息，其原理是对某个<code>PID</code>加一个<code>strace</code>进程进行<code>IO</code>分析。</p>
<h6 id="pt-config-diff"><a href="#pt-config-diff" class="headerlink" title="pt-config-diff"></a>pt-config-diff</h6><p><code>pt-config-diff</code>用于比较两个配置文件的差异。</p>
<h6 id="pt-find"><a href="#pt-find" class="headerlink" title="pt-find"></a>pt-find</h6><p><code>pt-find</code>用于查找表和执行命令。例如<code>pt-find --user=root --password=123 --tablesize +1M</code>可以找出数据库中大于<code>1M</code>的表。</p>
<h6 id="pt-kill"><a href="#pt-kill" class="headerlink" title="pt-kill"></a>pt-kill</h6><p><code>pt-kill</code>可以杀死符合标准的<code>mysql</code>进程。例如<code>pt-kill --user=root --password=123 --busy-time 3 --kill</code>可以杀死大于<code>3</code>秒的查询。</p>
<h6 id="pt-show-grants"><a href="#pt-show-grants" class="headerlink" title="pt-show-grants"></a>pt-show-grants</h6><p><code>pt-show-grants</code>用于查看<code>mysql</code>授权（集群常用，授权复制）。</p>
<h6 id="pt-table-checksum"><a href="#pt-table-checksum" class="headerlink" title="pt-table-checksum"></a>pt-table-checksum</h6><p><code>pt-table-checksum</code>用于验证数据库复制的完整性（集群常用，主从复制后检验）。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>三大类有问题的<code>SQL</code>语句：</p>
<ul>
<li>查询次数多且每次查询耗时长的<code>sql</code>。通过<code>pt-query-digest</code>命令可以查看。</li>
<li><code>IO</code>大的<code>sql</code>。检测的数据量越大，<code>IO</code>量也就越大。</li>
<li>未命中索引的<code>sql</code>。如果<code>Rows examine</code>与<code>Rows Sent</code>数量差距过大，说明该<code>sql</code>索引的命中率不高，应该调整索引。</li>
</ul>
<h4 id="explain-分析-SQL-执行计划"><a href="#explain-分析-SQL-执行计划" class="headerlink" title="explain 分析 SQL 执行计划"></a>explain 分析 SQL 执行计划</h4><p>前面我们通过慢查询找出了有问题的<code>sql</code>，现在我们可以使用<code>explain</code>分析<code>sql</code>的执行效率。</p>
<p>在<code>sql</code>语句前面加上<code>explain</code>即可，例如：<code>EXPLAIN SELECT * FROM test</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 100241</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>id</code>：数字越大越先执行，如果数字一样大，就从上往下依次执行。如果该列为<code>null</code>表示这是一个结果集，不需要使用它进行查询。</p>
</li>
<li><p><code>select_type</code>：</p>
<ul>
<li><code>SIMPLE</code>：表示没有<code>UNION</code>操作或者不包含子查询的简单<code>SELECT</code>查询。有连接查询时，最外层的查询为<code>SIMPLE</code>。</li>
<li><code>PRIMARY</code>：需要<code>UNION</code>操作或者包含子查询的<code>SELECT</code>查询，位于最外层的查询为<code>PRIMARY</code>。</li>
<li><code>UNION</code>：<code>UNION</code>连接的两个<code>SELECT</code>查询，第一个查询是<code>DERVIED</code>派生表，除了第一个表外，第二个以后的表都是<code>UNION</code>。</li>
<li><code>UNION RESULT</code>：包含<code>UNION</code>的结果集，在<code>UNION</code>和<code>UNION ALL</code>语句中，因为不需要参与查询，所以<code>id</code>为<code>null</code>。</li>
<li><code>DEPENDENT RESULT</code>：和<code>UNION</code>一样，出现在<code>UNION</code>和<code>UNION ALL</code>语句中，但是这个查询受到外部查询的影响。</li>
<li><code>SUBQUERY</code>：除了<code>FROM</code>中包含的子查询外，其他地方出现的子查询都可能是<code>SUBQUERY</code>。</li>
<li><code>DEPENDENT SUBQUERY</code>：表示这个<code>SUBQUERY</code>的查询受到外部表查询的影响。</li>
<li><code>DERIVED</code>：<code>FROM</code>中出现的子查询，也叫做派生表。</li>
<li><code>MATERIALIZATION</code>：物化通过将子查询结果作为一个临时表来加快查询执行的速度，正常来说是常驻内存，下次查询会再次引用临时表。</li>
</ul>
</li>
<li><p><code>table</code>：显示查询的表名，如果查询使用了别名，这里显示的是别名；如果不涉及对数据表的操作，显示<code>null</code>；如果显示的是尖括号<code>&lt;derived N&gt;</code>就表示这个是临时表，<code>N</code>是执行计划中的<code>id</code>，表示结果来自于这个查询产生。</p>
</li>
<li><p><code>type</code>：</p>
<ul>
<li><code>SYSTEM</code>：表中只有一行数据或者是空表，且只能用于<code>myisam</code>和<code>memory</code>表，如果是<code>InnoDB</code>表，显示的是<code>ALL</code>或<code>INDEX</code>。</li>
<li><code>CONST</code>：使用唯一索引或主键，返回的记录一定是<code>1</code>行的等值<code>WHERE</code>条件时，<code>type</code>为<code>CONST</code>。</li>
<li><code>EQ_REF</code>：出现在连接多表的查询计划中，驱动表循环获取数据，这行数据是第二个表的主键或者唯一索引，作为条件查询只能返回一条数据，且必须为<code>null</code>。唯一索引和主键是多列时，只有所有的列都用作比较时才会出现<code>eq_ref</code>。</li>
<li><code>REF</code>：不要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现。</li>
<li><code>FULLTEXT</code>：全文索引检索。全文索引的优先级高，如果全文索引和普通索引同时存在，<code>MySQL</code>会优先使用全文索引。</li>
<li><code>REF_OR_NULL</code>：和<code>ref</code>类似，只是增加了<code>null</code>值的比较，实际用的不多。</li>
<li><code>UNIQUE_SUBQUERY</code>：用于<code>WHERE</code>中的<code>IN</code>子查询，子查询返回不重复唯一值。</li>
<li><code>INDEX_SUBQUERY</code>：用于<code>IN</code>子查询使用到了辅助索引或者<code>IN</code>常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</li>
<li><code>RANGE</code>：索引返回扫描，常见于使用<code>&gt;, &lt;, is null, between, in, like</code>等运算符的查询中。</li>
<li><code>INDEX_MERGE</code>：表示查询使用了两个以上的索引，最后取交集或并集，常见<code>AND</code>、<code>OR</code>的条件使用了不同的索引。</li>
<li><code>INDEX</code>：索引全表扫描。把索引从头到尾扫描一遍，常见于使用索引列就可以处理不需要读取数据文件的查询，可以使用索引排序或分组的查询。</li>
<li><code>ALL</code>：扫描全表，然后在<code>server</code>层进行过滤返回符合要求的记录。</li>
</ul>
<p>以上几种<code>type</code>的效率由高到低，也就是说<code>ALL</code>的性能是最差的。一般达到<code>RANGE</code>的语句性能是比较好的。</p>
</li>
<li><p><code>possible_keys</code>：查询可能使用到的索引。</p>
</li>
<li><p><code>key</code>：查询实际使用到的索引。</p>
</li>
<li><p><code>key_len</code>：用于处理查询的索引长度，如果是单列索引，那就是整个索引的长度；如果是多列索引，那么查询不一定都能使用到所有的列，具体使用了哪些列就会计算进去。另外，<code>key_len</code>只计算<code>WHERE</code>条件用到的索引长度。</p>
</li>
<li><p><code>ref</code>：如果使用的常数等值查询，会显示<code>CONST</code>，如果是连接查询，被驱动表的执行计划会显示驱动表的关联字段；如果是条件使用了表达式或函数，或者条件列发生了内部隐式转换，这里可能显示为<code>FUNC</code>。</p>
</li>
<li><p><code>rows</code>：估算的扫描行数。</p>
</li>
<li><p><code>extra</code>：</p>
<ul>
<li><code>No tables used</code>：不带<code>FROM</code>的查询或者<code>FROM dual</code>查询。</li>
<li><code>NULL</code>：查询的列没有被索引覆盖，并且<code>WHERE</code>筛选条件是索引的前导列。意味着使用了索引，带式部分字段未被索引覆盖。</li>
<li><code>Using index</code>：查询时直接通过索引就可以获取数据。</li>
<li><code>Using where</code>：查询的列没有被索引覆盖，<code>WHERE</code>筛选条件非索引的前导列。</li>
<li><code>Using where; Using index</code>：查询的列被索引覆盖，并且<code>WHERE</code>筛选条件是索引列之一但不是索引的前导列。</li>
<li><code>Using index condition</code>：查询的列不完全被索引覆盖，<code>WHERE</code>条件是一个前导列的范围。</li>
<li><code>Using temporary</code>：使用临时表存储中间结果。</li>
<li><code>Using filesort</code>：对结果使用一个外部索引排序。</li>
<li><code>Using intersect</code>：使用<code>AND</code>的各个索引的条件时，该信息表示从处理结果中获取交集。</li>
<li><code>Using union</code>：使用<code>OR</code>连接各个使用索引的条件时，该信息表示从处理结果中获取并集。</li>
<li><code>Using sort_union</code>、<code>Using_sort_intersection</code>：用<code>AND</code>和<code>OR</code>查询信息量大时，先查询主键，然后进行排序合并后返回结果。</li>
</ul>
</li>
</ul>
<h4 id="慢查询优化思路"><a href="#慢查询优化思路" class="headerlink" title="慢查询优化思路"></a>慢查询优化思路</h4><ul>
<li>优化更需要优化的<code>sql</code>，比如那些高并发的<code>sql</code>。</li>
<li>定位优化对象的性能瓶颈。</li>
<li>明确的优化目标。</li>
<li>从执行计划入手。</li>
<li>永远用小结果集驱动大结果集。</li>
<li>尽可能在索引中完成排序。</li>
<li>只取出自己需要的列，不要用<code>SELECT *</code>。</li>
<li>仅使用最有效的过滤条件。</li>
<li>尽可能避免复杂的<code>JOIN</code>和子查询。</li>
<li>小心使用<code>ORDER BY</code>、<code>GROUP BY</code>、<code>DISTINCT</code>，尽量使用索引。</li>
<li>合理设计并使用索引。</li>
</ul>
<h5 id="join-语句优化"><a href="#join-语句优化" class="headerlink" title="join 语句优化"></a>join 语句优化</h5><p><code>mysql</code>关联查询使用的算法是<code>Nested-Loop Join</code>，通过驱动表的结果集作为循环的基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据，最后合并结果。所以我们要尽量减少<code>Nested-Loop</code>的次数。</p>
<p><code>Nested-Loop Join</code>有三种变种：</p>
<ul>
<li><code>Simple Nested-Loop Join</code>：简单嵌套循环连接，非常暴力，效率差。</li>
<li><code>Index Nested-Loop Join</code>：索引嵌套循环连接。当被驱动表<code>JOIN</code>的列有索引时，可以减少被驱动表的匹配次数，提升性能。但如果索引是辅助索引且返回的数据还包含其他数据，则会回表查询数据，增加了一些<code>IO</code>。</li>
<li><code>Block Nested-Loop Join</code>：块嵌套循环连接。是对简单嵌套循环连接的优化，相当于加了一块缓冲区，把参与查询的列缓存到缓冲区中，然后拿缓冲区中的数据批量与被驱动表的数据进行匹配，减少了被驱动表循环的次数。缓冲区默认的大小是<code>256K</code>。</li>
</ul>
<p>综上，对于<code>JOIN</code>语句的优化思路有以下几个：</p>
<ul>
<li>尽可能减少<code>Nested-Loop</code>的次数。</li>
<li>优先优化<code>Nested-Loop</code>的内层循环。</li>
<li>保证<code>JOIN</code>语句中被驱动表的<code>JOIN</code>字段已加索引。</li>
<li>如果无法加索引就使用块嵌套循环连接，减少内层循环次数。</li>
<li>并发量大时，尽量不使用<code>JOIN</code>，<code>JOIN</code>语句锁定的资源过多，会阻塞其他线程。</li>
<li>复杂的<code>QUERY</code>语句可以拆分成多个简单的<code>QUERY</code>语句分步执行。</li>
</ul>
<h5 id="order-by-语句优化"><a href="#order-by-语句优化" class="headerlink" title="order by 语句优化"></a>order by 语句优化</h5><ul>
<li><code>ORDER BY</code>排序可以使用索引进行优化，只要是索引的前导列都可以使索引生效，这样就不需要在额外的内存或文件中排序。</li>
<li>对于不能利用索引避免排序的<code>SQL</code>语句，数据库有自己的排序功能满足需求，这时执行计划是<code>Using filesort</code>。<code>MySQL</code>有一个参数<code>sort_buffer_size</code>，默认值为<code>256K</code>，如果要排序的数据小于这个值，就可以在缓冲区中排序，否则就要使用额外的内存或文件了。</li>
<li>分别在查询字段、<code>WHERE</code>条件、排序字段上做出各种可能的组合，主要就是看有没有索引，索引在以上三个关注点上的生效情况。</li>
</ul>
<h5 id="group-by-语句优化"><a href="#group-by-语句优化" class="headerlink" title="group by 语句优化"></a>group by 语句优化</h5><p><code>GROUP BY</code>语句本质上也进行了排序操作（<code>mysql 8</code>优化了，默认不进行排序）。</p>
<p><code>GROUP BY</code>一共有三种类型：</p>
<ul>
<li><code>Loose Index Scan</code>：先执行<code>GROUP BY</code>，再执行<code>WHERE</code>条件。仅读取<code>GROUP BY</code>条件中有的索引键，再根据<code>WHERE</code>条件进行筛选。</li>
<li><code>Tight Index Scan</code>：先执行<code>WHERE</code>条件，再执行<code>GROUP BY</code>。读取所有满足条件的索引键，然后再根据读取的数据完成<code>GROUP BY</code>操作。</li>
<li><code>Using temporary</code>：当<code>MySQL</code>找不到索引完成<code>GROUP BY</code>操作时，会使用临时表来完成。效率低下。</li>
</ul>
<h5 id="distinct-语句优化"><a href="#distinct-语句优化" class="headerlink" title="distinct 语句优化"></a>distinct 语句优化</h5><p><code>DISTINCT</code>和<code>GROUP BY</code>的操作很相似，就是分组后在每组只取出一条记录，达到去重的目的。</p>
<h4 id="索引种类"><a href="#索引种类" class="headerlink" title="索引种类"></a>索引种类</h4><ul>
<li><code>B-Tree</code>索引，使用最频繁。</li>
<li><code>Hash</code>索引，效率高。</li>
<li><code>Fulltext</code>索引，目前只有<code>char</code>、<code>varchar</code>、<code>text</code>类型可以。</li>
<li><code>R-Tree</code>索引，比较少见，主要用于空间数据检索。</li>
</ul>
<h4 id="判断是否需要创建索引"><a href="#判断是否需要创建索引" class="headerlink" title="判断是否需要创建索引"></a>判断是否需要创建索引</h4><ul>
<li>较频繁的作为查询条件的字段应该创建索引。</li>
<li>唯一性太差的字段不应单独创建索引，可以作为复合索引。</li>
<li>更新频繁的字段不应创建索引。</li>
<li>不会在<code>WHERE</code>子句中出现的字段不应创建索引。</li>
</ul>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul>
<li>复合索引尽量全匹配</li>
<li>最左匹配原则（带头索引不能死，中间索引不能断）</li>
<li>不要在索引上做任何操作，比如计算、函数等等。</li>
<li>不使用范围条件。</li>
<li>只查询需要查询的列。减少<code>SELECT *</code>。</li>
<li>使用<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>判断时会导致索引失效。</li>
<li>索引字段使用<code>LIKE</code>以通配符开头匹配时，会导致索引失效。</li>
<li>索引字段是字符串，但查询时不加单引号，会导致索引失效。</li>
<li>索引字段使用<code>OR</code>时，会导致索引失效。</li>
</ul>
<h4 id="数据量大时的优化思路"><a href="#数据量大时的优化思路" class="headerlink" title="数据量大时的优化思路"></a>数据量大时的优化思路</h4><ul>
<li>当数据量大时，比如已经达到了百万级别，应该放弃在<code>MySQL</code>中做<code>JOIN</code>操作，那样会锁住大量资源。建议根据索引单表取出数据，然后在程序里进行逻辑处理。</li>
<li>使用<code>nosql</code>，例如<code>redis</code>进行缓存数据，减轻<code>MySQL</code>的压力。</li>
</ul>
<h4 id="其他优化原则"><a href="#其他优化原则" class="headerlink" title="其他优化原则"></a>其他优化原则</h4><ul>
<li>不在数据库做运算。</li>
<li>控制列的数量。</li>
<li>平衡范式和冗余。</li>
<li>拒绝大<code>SQL</code>、事务、批量。</li>
<li>用合适的字段节约空间。</li>
<li>避免使用<code>NULL</code>字段。</li>
<li>少用<code>text</code>类型。</li>
<li>分页<code>LIMIT</code>优化（偏移量越大，执行越慢）。</li>
</ul>
<h4 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h4><ul>
<li>表范式化原则。一般情况下设计表要符合三大范式。</li>
<li>反范式化原则。当数据量大或者并发高的时候，可以适当给数据表添加一些冗余字段，减少数据库的<code>JOIN</code>等操作。</li>
<li>垂直拆分原则。不常用的字段单独放到一个表中。大字段单独放到一个表中。经常使用的字段放到一起。</li>
<li>水平拆分原则。水平拆分是为了解决单表的数据量过大的问题。通常是对<code>id</code>列进行<code>hash</code>运算，如果要分成<code>5</code>个表就对<code>5</code>取模。</li>
</ul>
<hr>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p><code>Tomcat</code>是经常使用的<code>Servlet</code>容器之一，很多线上产品都使用<code>Tomcat</code>充当服务器，所以<code>Tomcat</code>的优化也尤为重要。</p>
<p>首先进入<code>Tomcat conf</code>目录下的<code>tomcat-users.xml</code>文件，添加配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"tomcat"</span> <span class="attr">password</span>=<span class="string">"tomcat"</span> <span class="attr">roles</span>=<span class="string">"admin-gui,admin,manager-gui,manager"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动<code>Tomcat</code>，访问<code>localhost:8080/manager/status</code>输入上面配置的用户名和密码，就可以看到页面了。里面包含<code>JVM</code>、线程、以及服务器的一些状态。</p>
<h4 id="执行器（线程池）"><a href="#执行器（线程池）" class="headerlink" title="执行器（线程池）"></a>执行器（线程池）</h4><ul>
<li>每个请求都是一个线程，我们可以打开线程池提高性能。在<code>conf</code>目录中的<code>server.xml</code>文件中，去掉注释：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">minSpareThreads</span>=<span class="string">"4"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后将之前的<code>Connector</code>注释掉，打开带线程池的<code>Connector</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;Connector port="8080" protocol="HTTP/1.1"</span></span><br><span class="line"><span class="comment">           connectionTimeout="20000"</span></span><br><span class="line"><span class="comment">           redirectPort="8443" /&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>重启<code>Tomcat</code>访问<code>localhost:8080/manager/status</code>：</p>
<p><img src="tomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt=""></p>
<p>可以看到当前线程数是我们设置的<code>minSpareThreads</code>。</p>
<h4 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h4><ul>
<li><code>BIO</code>：<code>Tomcat 7</code>之前的默认的阻塞模式，性能低下，之后的版本已经抛弃了这种模式。</li>
<li><code>NIO</code>：同步非阻塞模式，<code>Tomcat</code>内部实现了<code>reactor</code>线程模型，性能较高。</li>
<li><code>NIO2</code>：纯异步模式，<code>Tomcat</code>内部实现了<code>preactor</code>线程模型。</li>
<li><code>APR</code>：从操作系统层面解决了异步<code>IO</code>问题，大幅提升性能。</li>
</ul>
<h5 id="BIO、NIO"><a href="#BIO、NIO" class="headerlink" title="BIO、NIO"></a>BIO、NIO</h5><p>我们使用<code>Tomcat 7</code>测试<code>BIO</code>运行模式。</p>
<p>启动<code>Tomcat 7</code>，访问<code>localhost:8080/manager/status</code>可以看到默认是<code>BIO</code>模型。使用<code>jmeter</code>进行压测，一秒内发送给<code>localhost:8080</code>根路径<code>10000</code>个请求，循环<code>10</code>次。</p>
<p><img src="%E7%BA%BF%E7%A8%8B%E7%BB%84.png" alt=""></p>
<p><img src="http%E8%AF%B7%E6%B1%82.png" alt=""></p>
<p><img src="BIO.png" alt=""></p>
<p>可以看到吞吐量大概是<code>2900</code>左右。</p>
<p>然后我们再使用<code>Tomcat 9</code>进行压测。</p>
<p><img src="NIO.png" alt=""></p>
<p>使用<code>NIO</code>的吞吐量达到了<code>7500</code>。</p>
<h5 id="NIO2"><a href="#NIO2" class="headerlink" title="NIO2"></a>NIO2</h5><p>在<code>server.xml</code>中修改配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11Nio2Protocol"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><h5 id="main-线程"><a href="#main-线程" class="headerlink" title="main 线程"></a>main 线程</h5><ul>
<li><code>main</code>线程是<code>Tomcat</code>主要线程，主要作用是通过启动包来对容器进行点火。</li>
<li><code>main</code>的作用是把容器组件拉起来，然后阻塞在<code>8005</code>端口，等待关闭。</li>
</ul>
<h5 id="startStop-线程"><a href="#startStop-线程" class="headerlink" title="startStop 线程"></a>startStop 线程</h5><ul>
<li><code>Tomcat 9</code>中已经没有<code>startStop</code>线程了。</li>
<li><code>Tomcat</code>按照层级进行异步启动，对于每一层级的组件都是采用<code>startStop</code>线程进行启动。</li>
<li>当组件启动完成后，该线程就退出了，生命周期仅限于此。</li>
</ul>
<h5 id="AsyncFileHandlerWriter-线程"><a href="#AsyncFileHandlerWriter-线程" class="headerlink" title="AsyncFileHandlerWriter 线程"></a>AsyncFileHandlerWriter 线程</h5><p>专门用于处理日志的线程。</p>
<h5 id="ContainerBackgroundProcessor-线程"><a href="#ContainerBackgroundProcessor-线程" class="headerlink" title="ContainerBackgroundProcessor 线程"></a>ContainerBackgroundProcessor 线程</h5><ul>
<li><code>Tomcat 9</code>中已经没有<code>ContainerBackgroundProcessor</code>线程了。</li>
<li>主要负责实时扫描<code>Tomcat</code>容器的变化，在一些时刻触发某些事件，例如在热部署开启时<code>reload</code>工程等。</li>
</ul>
<h5 id="Catalina-Utility-线程"><a href="#Catalina-Utility-线程" class="headerlink" title="Catalina-Utility 线程"></a>Catalina-Utility 线程</h5><ul>
<li>将<code>Tomcat 8</code>中的<code>startStop</code>线程和<code>ContainerBackgroundProcessor</code>线程合并了。</li>
</ul>
<h5 id="Acceptor-线程"><a href="#Acceptor-线程" class="headerlink" title="Acceptor 线程"></a>Acceptor 线程</h5><ul>
<li><code>Tomcat</code>前端最外层的线程，负责统一接受<code>socket</code>请求。</li>
<li><code>Acceptor</code>处理完之后的连接线程在<code>BIO</code>和<code>NIO</code>模式中略有差异。<code>BIO</code>模式下，<code>Acceptor</code>直接把任务丢给工作线程处理，所以会阻塞；而<code>NIO</code>模式下，<code>Acceptor</code>线程会把任务交给<code>poller</code>线程，<code>poller</code>线程调用底层的<code>epoll()</code>进行轮询，把准备就绪的事件丢给工作线程进行处理，所以是非阻塞的。</li>
</ul>
<h5 id="ClientPoller-线程"><a href="#ClientPoller-线程" class="headerlink" title="ClientPoller 线程"></a>ClientPoller 线程</h5><ul>
<li><code>NIO</code>模式特有的线程，<code>reactor</code>模式的实现者。</li>
<li>具体负责接收<code>acceptor</code>线程交接过来的事件，对事件轮询后交给工作线程处理。</li>
</ul>
<h5 id="Exec-线程"><a href="#Exec-线程" class="headerlink" title="Exec 线程"></a>Exec 线程</h5><ul>
<li><code>Tomcat</code>的主要工作线程，默认开启<code>10</code>个，接收<code>poller</code>线程丢过来的事件。</li>
<li>主要工作是<code>HTTP</code>协议解析，攒出<code>request</code>和<code>response</code>，然后调用后端的容器。</li>
</ul>
<h5 id="BlockPoller-线程"><a href="#BlockPoller-线程" class="headerlink" title="BlockPoller 线程"></a>BlockPoller 线程</h5><ul>
<li>负责<code>Servlet</code>的输入和输出。</li>
</ul>
<h5 id="AsyncTimeout-线程"><a href="#AsyncTimeout-线程" class="headerlink" title="AsyncTimeout 线程"></a>AsyncTimeout 线程</h5><ul>
<li>主要检测异步<code>request</code>请求时，触发超时，并将该请求再转发到工作线程池处理。</li>
</ul>
<h4 id="NIO-总体流程"><a href="#NIO-总体流程" class="headerlink" title="NIO 总体流程"></a>NIO 总体流程</h4><p><code>NIO</code>前端框架主要由三个不同的线程依次分工协作：</p>
<ul>
<li><code>Acceptor</code>线程将<code>SocketChannel</code>取出，传给<code>Poller</code>线程（会产生阻塞，所以包装成<code>PollEvent</code>加入缓存队列）。</li>
<li><code>Poller</code>线程轮询从通道中拿到感兴趣的事件，然后把感兴趣的<code>key</code>和<code>attachment</code>传递给<code>Exec</code>线程处理。</li>
<li><code>Exec</code>线程调用<code>http11ConnectionHandler</code>解析<code>HTTP</code>协议，将解析出来的内容包装成<code>request</code>和<code>response</code>，传递给<code>CoyoteAdapter</code>，最终执行到业务中。</li>
<li>执行完业务后需要进行<code>Servlet</code>回写。第一次使用的是<code>NioSelectorPool</code>内部的<code>sharedSelector</code>，执行的是非阻塞写，如果没有写成功，则会使用<code>NioBlockingSelector</code>的<code>BlockPoller</code>重新进行阻塞写。</li>
</ul>
<p><img src="nio_connector%E7%BB%93%E6%9E%84.png" alt=""></p>
<h4 id="BIO-总体流程"><a href="#BIO-总体流程" class="headerlink" title="BIO 总体流程"></a>BIO 总体流程</h4><p>相比于<code>NIO</code>，<code>BIO</code>的<code>Connector</code>少了很重要的<code>Poller</code>线程，使得工作效率低下。</p>
<p><code>BIO</code>流程和<code>NIO</code>大致一样，整体使用<code>ServerSocket</code>进行通信，一个请求一个线程。但由于缺少了<code>Selector</code>和轮询，导致效率低下，<code>Tomcat</code>在<code>8.5</code>版本后抛弃了<code>BIO</code>通道。</p>
<p><img src="bio_connector%E7%BB%93%E6%9E%84.png" alt=""></p>
<h4 id="NIO2-总体流程"><a href="#NIO2-总体流程" class="headerlink" title="NIO2 总体流程"></a>NIO2 总体流程</h4><p><code>NIO2</code>相比于<code>NIO</code>，少了<code>Poller</code>线程，多了<code>completionHandler</code>，实现了真正的异步操作，不用再轮询，而是给操作系统一个回调方法，操作系统准备好数据会主动将数据拷贝至用户空间，调用方法执行业务逻辑。</p>
<p><img src="nio2_connector%E7%BB%93%E6%9E%84.png" alt=""></p>
<h4 id="Tomcat-各通道的-sendfile-支持"><a href="#Tomcat-各通道的-sendfile-支持" class="headerlink" title="Tomcat 各通道的 sendfile 支持"></a>Tomcat 各通道的 sendfile 支持</h4><p><code>sendfile</code>是<code>linux</code>系统的一项优化技术，发送文件和网络通信时，减少用户空间和磁盘之间数据的交换，直接在内核空间做数据拷贝。这项技术是<code>linux 2.4</code>之后就有的了。</p>
<p><code>sendfile</code>实际是作用于数据拷贝在两个文件描述符之间的操作函数。这个拷贝的操作是在内核中完成的，所以也叫做<strong>零拷贝</strong>。<code>sendfile</code>比<code>read</code>和<code>write</code>要高效得多，因为<code>read</code>和<code>write</code>要把数据拷贝到用户空间进行操作，相当于：</p>
<p><img src="read%E3%80%81write.png" alt=""></p>
<p>而<code>sendfile</code>不会经过用户态：</p>
<p><img src="sendfile.png" alt=""></p>
<p>在<code>Tomcat</code>中，也用到了零拷贝的技术。对于<code>BIO</code>，<code>Tomcat</code>是不支持<code>sendfile</code>的。而对于<code>NIO</code>和<code>APR</code>，默认都是使用<code>sendfile</code>的，可以通过<code>Connector</code>的一个属性<code>useSendFile</code>设置。但是对于这两种模式，<code>sendfile</code>的实现略有不同：</p>
<ul>
<li>对于<code>NIO</code>，<code>sendfile</code>分为三个阶段：<ul>
<li>对<code>request</code>的<code>sendfile</code>属性进行设置，证明该请求是<code>sendfile</code>请求。</li>
<li><code>servlet</code>处理完之后，对应的<code>response</code>就要回写了。在<code>response</code>准备阶段，会初始化<code>SendFileData</code>这个数据结构。</li>
<li>我们记得<code>NIO</code>的<code>Acceptor</code>、<code>Poller</code>、<code>Exec</code>线程是相互配合的，当工作线程完成任务后，返回给客户端，依然要通过<code>Poller</code>线程，也就是会重新注册<code>KeyEvent</code>，读取<code>KeyAttachment</code>，此时若为<code>sendfile</code>，前面初始化的<code>SendFileData</code>就会注册在<code>KeyAttachment</code>上，<code>Poller</code>线程取出<code>SendFileData</code>中的<code>file</code>，通过<code>FileChannel</code>的<code>transferTo</code>方法，调用底层的零拷贝。</li>
</ul>
</li>
<li>对于<code>APR</code>，则进一步优化了<code>sendfile</code>。<code>NIO</code>的<code>sendfile</code>，实际上是通过每个<code>Poller</code>线程中的<code>FileChannel</code>的<code>transferTo</code>方法实现的，而这个方法是阻塞的。我们知道<code>Poller</code>线程实际是很珍贵的，不应该为了<code>sendfile</code>服务就阻塞住。所以<code>APR</code>为<code>sendfile</code>单独开辟了一个线程，这样的话<code>Poller</code>线程就不会阻塞了。</li>
</ul>
<h4 id="压缩属性"><a href="#压缩属性" class="headerlink" title="压缩属性"></a>压缩属性</h4><p>网络带宽是很珍贵的资源，所以对传输的数据进行压缩是很有必要的。</p>
<p><code>HTTP</code>响应头中压缩相关的属性有：</p>
<ul>
<li>传输内容编码：<code>Content-Encoding</code>，内容编码，即整个数据信息在服务端经过怎样的编码处理，然后客户端以怎样的编码来解码得到原始数据。这里的内容编码主要是指压缩编码，也就是服务端压缩，客户端解压。主要有<code>gzip</code>、<code>compress</code>、<code>deflate</code>、<code>identity</code>。通常压缩格式是<code>gzip</code>。</li>
<li>传输数据编码：<code>Transfer-Encoding</code>，表示数据在网络传输中，使用什么方式来保证数据是安全成功地传输处理。可以是分段传输，也可以不分段，直接使用原数据进行传输。有效值可以是<code>chunked</code>和<code>identity</code>。</li>
<li>传输内容格式：<code>Content-Type</code>，即接收到的数据最终是以什么形式显示在浏览器上。可以是图片、文本或是<code>html</code>等等。</li>
</ul>
<p><code>Tomcat</code>中压缩的实现具体有三个步骤：</p>
<ul>
<li><code>Http11Processor.prepareResponse()</code>：用于检查是否配置了压缩属性。</li>
<li>如果配置了压缩属性，则<code>GzipOutputFilter</code>生效。</li>
<li><code>GzipOutputFilter</code>会加入<code>GzipOutputStream</code>，压缩就是由他来完成。</li>
</ul>
<p>在<code>Tomcat</code>中，我们可以通过设置<code>Connector</code>属性来实现压缩。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">useSendfile</span>=<span class="string">"false"</span> <span class="attr">compression</span>=<span class="string">"on"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们必须同时设置<code>useSendfile</code>和<code>compresion</code>，并且<strong>互斥</strong>。这是因为我们必须要在用户空间中对文件进行压缩，而<code>sendfile</code>正好不会经过用户空间，所以两者是矛盾的。</p>
<h4 id="deferAccept-参数优化"><a href="#deferAccept-参数优化" class="headerlink" title="deferAccept 参数优化"></a>deferAccept 参数优化</h4><p>我们知道客户端与服务器进行通信首先要经过三次握手，大致流程如下：</p>
<p><img src="tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt=""></p>
<p>首先客户端发出一个<code>SYN</code>包，告诉服务端我要尝试进行连接。如果服务端存在，会基于这个<code>SYN</code>包，回复一个<code>SYN+ACK</code>包，告诉客户端我存在，允许连接。然后客户端回复<code>ACK</code>，告诉服务端我准备发送数据了。接下来进入数据传输的第二个阶段了。</p>
<p>我们关注红色标记的部分。服务端知道客户端要发送数据了，就会通过内核的协调，唤醒一个数据接收进程，这个<code>Acceptor</code>进程会绑定一个<code>IO</code>句柄用于接收。但实际上，在服务端的<code>ESTABLISHED</code>建立后，离数据的传输可能还有一段时间，比如客户端的程序阻塞了，加上网络延时，那这个时间差就会很大。这样的话，服务端相当于一直在白白消耗资源。</p>
<p>对于这个问题，服务端提供了一种机制，使得服务端对于最后一个<code>ACK</code>视而不见，等到客户端真正把数据传输过来了，才去开启<code>Acceptor</code>进程。这个优化，就是<code>TCP_DEFER_ACCEPT</code>属性。这个属性只在<code>APR</code>通道有效，默认开启。</p>
<h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>在早期的<code>HTTP</code>协议中，每开启一个<code>HTTP</code>连接都要开启一个<code>TCP</code>连接。这样极其浪费资源，且效率低下。<code>HTTP1.1</code>之后使用<code>keep-alive</code>机制改善了这种情况，一次<code>TCP</code>连接就可以多次传输数据而不会断开连接。</p>
<p>在服务器中，一般和<code>keep-alive</code>相关的有两个参数：</p>
<ul>
<li><code>keepAliveTimeout</code>：此时间过后的连接就<code>closed</code>了。单位是<code>ms</code>。</li>
<li><code>maxKeepAliveRequests</code>：最大长连接的个数（<code>1</code>表示禁用，<code>-1</code>表示不限制个数，默认为<code>100</code>个，一般设置在<code>100 - 200</code>之间）</li>
</ul>
<p>在<code>Tomcat</code>中，<code>HTTP1.1</code>之后是默认开启<code>keep-alive</code>的。</p>
<hr>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="JVM-运行参数"><a href="#JVM-运行参数" class="headerlink" title="JVM 运行参数"></a>JVM 运行参数</h4><ul>
<li>标准参数：<code>-help</code>、<code>-version</code></li>
<li><code>-X</code>参数（非标准参数）：<code>-Xint</code>、<code>-Xcomp</code></li>
<li><code>-XX</code>参数（使用率高）：<code>-XX:newSize</code>、<code>-XX:+UseSerialGC</code></li>
</ul>
<h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p><img src="JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p><code>jstat</code>是<code>JDK</code>自带的轻量级工具，可以对<code>Java</code>进程的资源和性能进行监控，包括堆内存、<code>GC</code>情况等等信息。</p>
<p><code>jstat</code>主要有以下几个<code>options</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-class</span><br><span class="line">-compiler</span><br><span class="line">-gc</span><br><span class="line">-gccapacity</span><br><span class="line">-gccause</span><br><span class="line">-gcmetacapacity</span><br><span class="line">-gcnew</span><br><span class="line">-gcnewcapacity</span><br><span class="line">-gcold</span><br><span class="line">-gcoldcapacity</span><br><span class="line">-gcutil</span><br><span class="line">-printcompilation</span><br></pre></td></tr></table></figure>

<ul>
<li><code>jstat -class &lt;pid&gt;</code>：用于查看当前进程的类加载信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已加载数量 占用空间 未加载数量 占用空间  时间</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line">  3371  6840.0        0     0.0       0.73</span><br></pre></td></tr></table></figure>

<ul>
<li><code>jstat -compiler &lt;pid&gt;</code>：查看编译的信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已编译数量 失败数量 无效数量  时间    失败类型     失败方法</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    3980      0       0    14.20          0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>jstat -gc &lt;pid&gt;</code>：查看<code>GC</code>情况。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S0大小 S1大小 S0已使用 S1已使用 Eden区大小 Eden区已使用 Old区大小 Old区已使用 方法区大小 方法区已使用</span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU        MC         MU</span><br><span class="line">0.0   1024.0  0.0   1024.0 80896.0  40960.0   51200.0     8109.4    16768.0     15716.0</span><br><span class="line">压缩空间 压缩空间已使用 年轻代GC次数 年轻代GC耗时 fullgc次数 fullgc耗时  总耗时</span><br><span class="line">CCSC       CCSU       YGC       YGCT        FGC       FGCT       GCT</span><br><span class="line">1920.0     1582.6     20        0.461       0         0.000      0.461</span><br></pre></td></tr></table></figure>

<h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p><code>jmap</code>可以查出某个<code>Java</code>进程（使用<code>pid</code>）内存内的，所有对象的情况。</p>
<ul>
<li><code>jmap -heap &lt;pid&gt;</code>：查看内存的使用情况。<code>JDK 1.8</code>之后需要使用<code>jhsdb jmap --heap --pid &lt;pid&gt;</code>命令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using thread-local object allocation.</span><br><span class="line">Garbage-First (G1) GC with 8 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         &#x3D; 40</span><br><span class="line">   MaxHeapFreeRatio         &#x3D; 70</span><br><span class="line">   MaxHeapSize              &#x3D; 2147483648 (2048.0MB)</span><br><span class="line">   NewSize                  &#x3D; 1363144 (1.2999954223632812MB)</span><br><span class="line">   MaxNewSize               &#x3D; 1287651328 (1228.0MB)</span><br><span class="line">   OldSize                  &#x3D; 5452592 (5.1999969482421875MB)</span><br><span class="line">   NewRatio                 &#x3D; 2</span><br><span class="line">   SurvivorRatio            &#x3D; 8</span><br><span class="line">   MetaspaceSize            &#x3D; 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         &#x3D; 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         &#x3D; 1048576 (1.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">G1 Heap:</span><br><span class="line">   regions  &#x3D; 2048</span><br><span class="line">   capacity &#x3D; 2147483648 (2048.0MB)</span><br><span class="line">   used     &#x3D; 68242944 (65.08154296875MB)</span><br><span class="line">   free     &#x3D; 2079240704 (1982.91845703125MB)</span><br><span class="line">   3.177809715270996% used</span><br><span class="line">G1 Young Generation:</span><br><span class="line">Eden Space:</span><br><span class="line">   regions  &#x3D; 60</span><br><span class="line">   capacity &#x3D; 80740352 (77.0MB)</span><br><span class="line">   used     &#x3D; 62914560 (60.0MB)</span><br><span class="line">   free     &#x3D; 17825792 (17.0MB)</span><br><span class="line">   77.92207792207792% used</span><br><span class="line">Survivor Space:</span><br><span class="line">   regions  &#x3D; 3</span><br><span class="line">   capacity &#x3D; 3145728 (3.0MB)</span><br><span class="line">   used     &#x3D; 3145728 (3.0MB)</span><br><span class="line">   free     &#x3D; 0 (0.0MB)</span><br><span class="line">   100.0% used</span><br><span class="line">G1 Old Generation:</span><br><span class="line">   regions  &#x3D; 4</span><br><span class="line">   capacity &#x3D; 52428800 (50.0MB)</span><br><span class="line">   used     &#x3D; 2182656 (2.08154296875MB)</span><br><span class="line">   free     &#x3D; 50246144 (47.91845703125MB)</span><br><span class="line">   4.1630859375% used</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>jmap -histo &lt;pid&gt;</code>：查看内存中对象数量及大小。</p>
</li>
<li><p><code>jmap -dump:format=b,file=filename &lt;pid&gt;</code>：将内存的使用情况以二进制的形式<code>dump</code>到文件中。</p>
</li>
<li><p><code>jhat -port 8888 filename</code>：上个命令<code>dump</code>出来的是二进制文件，不方便查看，所以我们可以使用<code>jhat</code>命令进行查看。</p>
</li>
</ul>
<h4 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h4><p><code>MAT(Memory Analyzer Tool)</code>是一款基于<code>Eclipse</code>的内存分析工具，是一款快速、功能丰富的<code>Java heap</code>分析工具，可以帮助我们查找内存泄漏，减少内存消耗。</p>
<p>首先，模拟堆内存溢出的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置<code>VM</code>参数：<code>-Xmx32M -Xms32M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</code>，意思是最大堆内存为<code>32M</code>，然后将错误信息<code>dump</code>到当前项目的根目录下。运行一段时间就可以看到错误信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to .&#x2F;java_pid64042.hprof ...</span><br><span class="line">Heap dump file created [33925906 bytes in 0.150 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">	at java.util.ArrayList.grow(ArrayList.java:267)</span><br><span class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:241)</span><br><span class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:233)</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:464)</span><br><span class="line">	at test.Test.main(Metaspace.java:52)</span><br></pre></td></tr></table></figure>

<p>打开<code>MAT</code>，导入<code>hprof</code>文件，点击<code>Leak Suspects</code>，可以看到和下面类似的图：</p>
<p><img src="mat%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<p>主线程持有的变量大小已经占了内存的<code>98.02%</code>，所以报了堆内存溢出的异常。</p>
<h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p><code>jstack</code>是<code>JVM</code>自带的一款堆栈跟踪工具。</p>
<p>模拟死锁的发生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"拿到对象锁"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (Test<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"拿到类锁"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Test<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"拿到类锁"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"拿到对象锁"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发现已经发生了死锁。</p>
<p>运行<code>jstack &lt;pid&gt;</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;t2&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007ff8470104a8 (object 0x00000007bf72ba68, a java.lang.Object),</span><br><span class="line">  which is held by &quot;t1&quot;</span><br><span class="line">&quot;t1&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007ff84700dc18 (object 0x00000007bf728cb8, a java.lang.Class),</span><br><span class="line">  which is held by &quot;t2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;t2&quot;:</span><br><span class="line">	at test.Test.lambda$main$1(Metaspace.java:71)</span><br><span class="line">	- waiting to lock &lt;0x00000007bf72ba68&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x00000007bf728cb8&gt; (a java.lang.Class for test.Test)</span><br><span class="line">	at test.Test$$Lambda$2&#x2F;764977973.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;t1&quot;:</span><br><span class="line">	at test.Test.lambda$main$0(Metaspace.java:58)</span><br><span class="line">	- waiting to lock &lt;0x00000007bf728cb8&gt; (a java.lang.Class for test.Test)</span><br><span class="line">	- locked &lt;0x00000007bf72ba68&gt; (a java.lang.Object)</span><br><span class="line">	at test.Test$$Lambda$1&#x2F;1452126962.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p><code>jstack</code>已经帮我们显示了死锁的具体信息。</p>
<h4 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h4><p>使用<code>jvisualvm</code>可以监控线程、内存情况，查看方法的<code>CPU</code>时间和内存中的对象，已被<code>GC</code>的对象，反向查看分配的堆栈。</p>
<p><code>jvisualvm</code>使用简单，几乎<code>0</code>配置，功能丰富，几乎囊括了其他<code>JDK</code>自带命令的所有功能。</p>
<h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>假设有一个对象<code>A</code>，任何一个对象对<code>A</code>的引用，那么对象<code>A</code>的引用计数器<code>+1</code>；引用失败时，计数器<code>-1</code>。如果计数器的值为<code>0</code>，说明对象<code>A</code>没有引用了，即可以被回收。</p>
<p>引用计数法不能解决<strong>循环引用</strong>的问题。</p>
<h5 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h5><p>标记清除算法将垃圾回收分为两阶段：标记和清除。</p>
<ul>
<li>标记：从根节点开始标记引用的对象。</li>
<li>清除：未被标记的对象就是垃圾对象，可以被清除。</li>
</ul>
<p>标记清除算法解决了循环引用的问题，但是效率较低，因为标记和清除都要遍历所有对象，在<code>GC</code>的时候要停止应用程序，对于交互性要求高的应用来说这个体验很差。同时，通过标记清除算法清理后的内存，碎片化严重，因为被回收的对象可能存在于内存的各个角落，是不连贯的。</p>
<h5 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h5><p>标记压缩算法（也叫标记整理算法）在标记清除算法的基础上，将清理后的存活的对象压缩到一起，解决了内存碎片化的问题，大大提升了内存空间的利用率。</p>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>复制算法将内存空间一分为二，每次只对外提供内存空间的一半，当内存快满时，触发<code>GC</code>，将存活的对象全部复制到内存的另一半，并且清除自己的内存。然后将两块内存空间互换角色。重复几次之后，会把存活的对象放到老年代中 。</p>
<p>复制算法在垃圾对象多的情况下，效率较高，因为需要复制的对象较少。但是由于每次只提供一半的内存，内存的使用率是很低的。</p>
<h5 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h5><p>根据回收对象的特点进行选择，在<code>JVM</code>中，年轻代适合复制算法，老年代适合标记清除或者标记压缩算法。</p>
<h4 id="垃圾收集器以及内存分配"><a href="#垃圾收集器以及内存分配" class="headerlink" title="垃圾收集器以及内存分配"></a>垃圾收集器以及内存分配</h4><h5 id="串行垃圾收集器"><a href="#串行垃圾收集器" class="headerlink" title="串行垃圾收集器"></a>串行垃圾收集器</h5><p>串行垃圾收集器（<code>Serial</code>）是最基本的、历史最悠久的收集器。它是单线程的，对于限定单个<code>CPU</code>的环境来说，<code>Serial</code>收集器没有线程交互的开销，所以可以专心做垃圾回收以获得最高的效率。<code>Serial</code>收集器在回收垃圾时，必须暂停其他工作线程直至回收结束（<code>stop the world</code>）。</p>
<p>模拟堆内存溢出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"serial"</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        s += s + UUID.randomUUID();</span><br><span class="line">        s.intern();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加<code>VM</code>参数：<code>-XX:+UseSerialGC -Xmx8m -Xms8m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags</code>，使用串行垃圾收集器，堆内存设置为<code>8M</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize&#x3D;8388608 -XX:MaxHeapSize&#x3D;8388608 -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC </span><br><span class="line">[GC (Allocation Failure) [DefNew: 2176K-&gt;256K(2432K), 0.0016645 secs] 2176K-&gt;616K(7936K), 0.0017165 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 2419K-&gt;256K(2432K), 0.0011236 secs] 2779K-&gt;1307K(7936K), 0.0011419 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 2313K-&gt;0K(2432K), 0.0009272 secs] 3364K-&gt;2315K(7936K), 0.0009457 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 2057K-&gt;0K(2432K), 0.0005905 secs] 4373K-&gt;2987K(7936K), 0.0006075 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 2058K-&gt;0K(2432K), 0.0009592 secs][Tenured: 4331K-&gt;2650K(5504K), 0.0019428 secs] 5045K-&gt;2650K(7936K), [Metaspace: 3568K-&gt;3568K(1056768K)], 0.0029238 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 1386K-&gt;1386K(2432K), 0.0000087 secs][Tenured: 5338K-&gt;1978K(5504K), 0.0016750 secs] 6725K-&gt;1978K(7936K), [Metaspace: 3568K-&gt;3568K(1056768K)], 0.0017100 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 1430K-&gt;1430K(2432K), 0.0000139 secs][Tenured: 4666K-&gt;4667K(5504K), 0.0015422 secs] 6097K-&gt;4667K(7936K), [Metaspace: 3569K-&gt;3569K(1056768K)], 0.0015782 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [Tenured: 4667K-&gt;4623K(5504K), 0.0017988 secs] 4667K-&gt;4623K(7936K), [Metaspace: 3569K-&gt;3569K(1056768K)], 0.0018132 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 2432K, used 86K [0x00000007bf800000, 0x00000007bfaa0000, 0x00000007bfaa0000)</span><br><span class="line">  eden space 2176K,   3% used [0x00000007bf800000, 0x00000007bf815bb8, 0x00000007bfa20000)</span><br><span class="line">  from space 256K,   0% used [0x00000007bfa60000, 0x00000007bfa60000, 0x00000007bfaa0000)</span><br><span class="line">  to   space 256K,   0% used [0x00000007bfa20000, 0x00000007bfa20000, 0x00000007bfa60000)</span><br><span class="line"> tenured generation   total 5504K, used 4623K [0x00000007bfaa0000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 5504K,  84% used [0x00000007bfaa0000, 0x00000007bff23e90, 0x00000007bff24000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3601K, capacity 4540K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 402K, capacity 428K, committed 512K, reserved 1048576K</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>当我们配置<code>-XX:+UseSerialGC</code>时，实际上是在年轻代中使用了串行收集器以及复制算法；而老年代中虚拟机会自动帮我们使用<code>Serial Old</code>收集器，使用的是标记压缩算法。</p>
<h5 id="ParNew-垃圾收集器"><a href="#ParNew-垃圾收集器" class="headerlink" title="ParNew 垃圾收集器"></a>ParNew 垃圾收集器</h5><p><code>ParNew</code>并行垃圾收集器在串行的基础上做了改进，将单线程改为了多线程进行垃圾回收，这样可以缩短垃圾回收的时间，提高效率。</p>
<p>通过<code>-XX:+UseParNewGC</code>可以设置年轻代使用<code>ParNew</code>回收器，而老年代使用的依然是串行回收器；通过<code>-XX:+ParallelGCThreads</code>可以限制<code>GC</code>线程数量，默认开启和<code>CPU</code>数目相等的线程数。</p>
<h5 id="Parallel-垃圾收集器"><a href="#Parallel-垃圾收集器" class="headerlink" title="Parallel 垃圾收集器"></a>Parallel 垃圾收集器</h5><p><code>Parallel</code>垃圾收集器在年轻代和老年代都使用并行收集器。</p>
<p>通过<code>-XX:+UseParallelGC</code>就可以激活年轻代使用<code>Parallel</code>收集器，同时老年代的<code>-XX:+UseParallelOldGC</code>也会被自动激活，反过来也同理。</p>
<h5 id="CMS-垃圾收集器"><a href="#CMS-垃圾收集器" class="headerlink" title="CMS 垃圾收集器"></a>CMS 垃圾收集器</h5><p><code>CMS(Concurrent Mark Sweep)</code>是一款并发的、使用标记清除算法的垃圾收集器，该收集器针对老年代，通过参数<code>-XX:+UseConcMarkSweepGC</code>进行设置。激活后，<code>JVM</code>将会自动使用<code>ParNew</code>收集器在年轻代进行回收。</p>
<p><code>CMS</code>垃圾收集器进行垃圾回收时分为七个步骤：</p>
<ul>
<li>初始标记，会导致<code>STW</code>。</li>
<li>并发标记，与用户线程同时运行。</li>
<li>预清理，与用户线程同时运行。</li>
<li>可被终止的预清理，与用户线程同时运行。</li>
<li>重新标记，会导致<code>STW</code>。</li>
<li>并发清除，与用户线程同时运行。</li>
<li>并发重置状态下等待下次<code>CMS</code>的触发。</li>
</ul>
<p><code>CMS</code>并不完美。</p>
<ul>
<li>由于并发进行，<code>CMS</code>在回收垃圾的时候和应用程序会同时增加堆内存，也就是说，<code>CMS</code>必须要在老年代堆内存耗尽之前完成垃圾回收，如果回收失败，会触发担保机制，串行老年代收集器回进行<code>GC</code>，导致<code>STW</code>。</li>
<li><code>CMS</code>使用的是垃圾清除算法，无法解决碎片问题。<code>CMS</code>提供了参数：<code>-XX:CMSFullGCsBeforeCompaction</code>来指定多少次<code>CMS</code>收集之后进行一次压缩的<code>Full GC</code>，默认为<code>0</code>，也就是每次都进行压缩。</li>
</ul>
<h5 id="G1-垃圾收集器"><a href="#G1-垃圾收集器" class="headerlink" title="G1 垃圾收集器"></a>G1 垃圾收集器</h5><p><code>G1</code>垃圾收集器是<code>JDK1.7 update4</code>正式使用的全新的垃圾收集器，<code>oracle</code>官方在<code>JDK1.9</code>中将<code>G1</code>垃圾收集器变成了默认的垃圾收集器，取代了<code>CMS</code>。</p>
<p><code>g1</code>收集器不再划分年轻代和老年代，而是将堆划分为若干个区域，每个区域最大<code>32M</code>，是<code>2</code>的指数，可以通过<code>-XX:G1HeapRegionSize=n</code>来设置。默认划分<code>2048</code>个区域。</p>
<p><img src="G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt=""></p>
<p>除了<code>Eden</code>、<code>Survivor</code>、<code>Old</code>，<code>G1</code>收集器还多了一个<code>Humongous</code>区，这个区域存储的是巨大对象，也就是大于等于<code>region</code>一半的对象。</p>
<p><code>G1</code>收集器对于<code>Eden</code>区的回收仍然采用<code>STW</code>的方式，将<code>Eden</code>区中的对象拷贝到<code>Survivor</code>区或者<code>Old</code>区完成垃圾回收。<code>G1</code>收集器会智能地解决碎片问题，在复制的同时完成压缩。</p>
<p><code>G1</code>收集器有两种垃圾回收模式：</p>
<ul>
<li><code>Young GC</code>：针对<code>Eden</code>区，回收时将<code>Eden</code>去的对象拷贝到<code>Survivor</code>区。如果<code>Survivor</code>区的空间不够了，就直接拷贝到<code>Old</code>区。<code>G1</code>收集器有一个<code>RSet</code>的概念，存储的是<code>Region</code>中存活对象的指针，在标记存活对象的时候，将每个分区指向分区内的引用记录在该分区，避免对整个队堆扫描。</li>
<li><code>Mixed GC</code>：当<code>Old</code>区空间越来越大，为了避免堆内存耗尽，会触发<code>Mixed GC</code>。<code>Mixed GC</code>会回收<code>Young</code>区和一部分<code>Old</code>区。那么如何确定哪些<code>Old</code>区<code>region</code>要回收呢？这就是并发标记周期要做的了：<a href="https://www.jianshu.com/p/0b978e57d430" target="_blank" rel="noopener">mixed GC</a></li>
</ul>
<p>相关参数：</p>
<ul>
<li><code>-XX:+UseG1GC</code>，表示使用<code>G1</code>收集器。</li>
<li><code>-XX:MaxGCPauseMillis</code>，指定垃圾回收暂停时间，<code>JVM</code>会尽量按照指定的时间进行垃圾回收。</li>
<li><code>-XX:G1HeapRegionSize=n</code>，指定每个<code>region</code>的大小。</li>
<li><code>-XX:ConcGCThreads=n</code>，指定线程数，最大和<code>CPU</code>数量一致。</li>
<li><code>-XX:InitiatingHeapOccupancyPercent=n</code>，老年代大小占堆百分比多少的时候触发<code>mixed GC</code>，默认<code>45%</code>。</li>
</ul>
<h4 id="GC-日志输出参数"><a href="#GC-日志输出参数" class="headerlink" title="GC 日志输出参数"></a>GC 日志输出参数</h4><ul>
<li><code>-XX:+PrintGC</code>：打印<code>GC</code>日志。</li>
<li><code>-XX:+PrintGCDetails</code>：打印详细日志。</li>
<li><code>-XX:+PrintGCTimeStamps</code>：打印<code>GC</code>时间戳（基准时间形式）。</li>
<li><code>-XX:+PrintGCDateStamps</code>：打印<code>GC</code>时间戳（日期格式）。</li>
<li><code>-XX:+PrintHeapAtGC</code>：在进行<code>GC</code>前后打印堆的信息。</li>
<li><code>-Xloggc:filepath</code>：日志文件的输出路径。</li>
</ul>
<hr>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><h4 id="为什么是-Nginx-而不是-Apache"><a href="#为什么是-Nginx-而不是-Apache" class="headerlink" title="为什么是 Nginx 而不是 Apache"></a>为什么是 Nginx 而不是 Apache</h4><ul>
<li>轻量级，同样是<code>web</code>服务，比<code>Apache</code>占用更少的内存及资源。</li>
<li>静态处理，<code>Nginx</code>静态处理性能比<code>Apache</code>高三倍以上。</li>
<li>抗并发，<code>Nginx</code>处理请求是异步非阻塞的，而<code>Apache</code>是阻塞的。</li>
<li>高度模块化设计，编写模块简单。</li>
</ul>
<p>…</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>Tomcat</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>MySQL</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>细说Linux零拷贝</title>
    <url>/2021/03/02/%E7%BB%86%E8%AF%B4Linux%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>细说Linux零拷贝</p>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>磁盘可以说是计算机系统最慢的硬件之一，读写速度和内存相差了<code>10</code>倍以上，所以针对磁盘读写的优化非常多，比如零拷贝、异步<code>IO</code>等等，目的就是提高系统的吞吐量，减少磁盘的访问次数。</p>
<hr>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p><code>DMA</code>是什么？在没有<code>DMA</code>之前，磁盘的<code>IO</code>过程是这样的：</p>
<ul>
<li><code>CPU</code>发送指令给磁盘的控制器。</li>
<li>磁盘控制器收到指令后，开始准备数据，把数据放到磁盘控制器的缓冲区中，然后产生一个中断。</li>
<li><code>CPU</code>收到中断后，会停止当前的工作，把磁盘控制器的缓冲区中的数据拷贝到自己的寄存器中，再把寄存器中的数据拷贝到内存中。这期间<code>CPU</code>是无法执行其他任何指令的。</li>
</ul>
<p>用图来描述大概是这样：</p>
<p><img src="IO.png" alt=""></p>
<p>可以看到，整个数据传输过程<code>CPU</code>都要亲自参与，如果数据量大的话，那将耗费大量<code>CPU</code>的资源。所以后来就发明了<code>DMA</code>技术，也就是直接内存访问（<code>Direct Memory Access</code>）。简单来说就是，数据传输的工作全部交给<code>DMA</code>来管理，<code>CPU</code>可以去处理其他事情。如下图所示：</p>
<p><img src="DMA_IO.png" alt=""></p>
<p>具体过程是这样的：</p>
<ul>
<li>用户进程调用<code>read</code>方法，向操作系统发起<code>IO</code>请求，进程进入阻塞状态。</li>
<li>操作系统收到请求后，进一步把这个请求发送给<code>DMA</code>，然后<code>CPU</code>就去处理其他事情了。</li>
<li><code>DMA</code>收到请求后，把请求发送给磁盘。</li>
<li>磁盘收到请求后，把数据读取到磁盘控制器的缓冲区中。当缓冲区空间满了，磁盘向<code>DMA</code>发送中断信号。</li>
<li><code>DMA</code>收到信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中。当内核缓冲区读取了足够的数据，向<code>CPU</code>发送中断信号。</li>
<li><code>CPU</code>收到信号，将数据从内核缓冲区拷贝到用户空间的缓冲区中，<code>read</code>方法返回。</li>
</ul>
<p>整个过程不再需要<code>CPU</code>亲力亲为。</p>
<hr>
<h3 id="传统的文件传输"><a href="#传统的文件传输" class="headerlink" title="传统的文件传输"></a>传统的文件传输</h3><p>如果服务端要传输文件，最简单的方式就是：将磁盘上的文件读取出来，然后通过网络协议传输给客户端。</p>
<p>对于传统<code>IO</code>，数据的读写都通过从用户空间到内核空间的来回拷贝，而内核空间的数据则通过操作系统层面的<code>IO</code>接口从磁盘进行读写。整个过程如下图：</p>
<p><img src="%E4%BC%A0%E7%BB%9FIO.png" alt=""></p>
<p>这期间一共发生了<code>4</code>次用户态和内核态的上下文切换。因为发生了<code>read</code>和<code>write</code>两次系统调用，每次都要先从用户态切换到内核态，等内核执行完任务后再切换到用户态中。上下文切换的成本并不小，平均一次切换大概要几十纳秒到几微秒。在高并发的场景下，会影响系统的性能。</p>
<p>其次，该过程还发生了<code>4</code>次数据的拷贝。其中两次是<code>DMA</code>的拷贝，另外两次是<code>CPU</code>的拷贝。</p>
<ul>
<li>首先，<code>DMA</code>会将磁盘上的数据拷贝到内核缓冲区。</li>
<li>然后<code>CPU</code>将内核缓冲区的数据拷贝到用户缓冲区。</li>
<li><code>CPU</code>再把用户缓冲区的数据拷贝到<code>socket</code>缓冲区。</li>
<li>最后<code>DMA</code>把<code>socket</code>缓冲区中的数据拷贝到网卡缓冲区中。</li>
</ul>
<p>这种简单的数据传输方式效率低下，存在冗余的上下文切换和数据拷贝。针对这两点，可以进行优化。</p>
<hr>
<h3 id="优化文件传输"><a href="#优化文件传输" class="headerlink" title="优化文件传输"></a>优化文件传输</h3><p>首先来看，怎样才能减少上下文的切换呢？</p>
<p>读取磁盘数据的时候，之所以要发生上下文的切换，是因为用户空间没有权限操作磁盘或者网卡，所以只能调用操作系统提供的接口，由内核完成相关的任务。一次这样的调用就要发生两次上下文的切换，首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p>
<p>也就是说，想要减少上下文的切换，就需要减少系统的调用。</p>
<p>那么如何减少数据拷贝的次数呢？</p>
<p>传统的数据传输要经历四次数据拷贝，在这个过程中从内核缓冲区拷贝到用户缓冲区，再从用户缓冲区拷贝到<code>socket</code>缓冲区这一过程其实是没有必要的。因为数据传输的场景中，在用户空间我们并不会对数据进行修改，所以数据没有必要经过用户空间。</p>
<hr>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>零拷贝的技术实现方式有两种：</p>
<h4 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h4><p>前面说到<code>read()</code>函数调用会把内核缓冲区的数据拷贝到用户缓冲区，为了减少这一步的开销，我们使用<code>mmap()</code>替换<code>read()</code>函数。<code>mmap()</code>会直接把内核缓冲区之中的数据<strong>映射</strong>到用户空间。这样，内核空间和用户空间就不再需要数据的拷贝了，类似下图：</p>
<p><img src="mmap+write%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt=""></p>
<p>具体过程如下：</p>
<ul>
<li>用户进程调用<code>mmap()</code>，<code>DMA</code>把磁盘的数据拷贝到内核缓冲区中，然后用户空间和内核空间会共享该缓冲区。</li>
<li>用户进程再调用<code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到<code>socket</code>缓冲区，这一切都发生在内核态，由<code>CPU</code>完成。</li>
<li>最后<code>DMA</code>再把<code>socket</code>缓冲区中的数据拷贝到网卡缓冲区。</li>
</ul>
<p>所以通过<code>mmap + write</code>实现的零拷贝仍然需要四次上下文切换，但减少了一次数据的拷贝。</p>
<h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p><code>Linux 2.1</code>提供了一个专门用于发送文件的系统调用函数<code>sendfile()</code>，其函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>前两个参数是目的端和源端的文件描述符，后两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p>
<p>这个函数直接替代了<code>read()</code>和<code>write()</code>，所以减少了两次上下文的切换。其次我们不再需要把数据拷贝到用户态，这样就只有三次数据的拷贝。</p>
<p><img src="sendfile%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt=""></p>
<p>但这还不是最高效的零拷贝技术。如果网卡支持<code>SG-DMA</code>技术，则可以进一步减少通过<code>CPU</code>把内核缓冲区中的数据拷贝到<code>socket</code>缓冲区这一步骤。</p>
<p>如果是<code>Linux</code>系统，可以通过<code>ethtool -k eth0 | grep scatter-gather</code>命令查看网卡是否支持<code>SG-DMA</code>技术。</p>
<p>从<code>Linux 2.4</code>版本开始，如果网卡支持<code>SG-DMA</code>技术，<code>sendfile</code>函数底层的调用会发生变化：</p>
<ul>
<li>首先，<code>DMA</code>将磁盘上的数据拷贝到内核缓冲区。</li>
<li>缓冲区描述符和数据长度传到<code>socket</code>缓冲区中，这样网卡的<code>SG-DMA</code>控制器可以直接将内核缓冲区中的数据拷贝到网卡缓冲区中，不再需要经过<code>socket</code>缓冲区。于是又减少了一次数据的拷贝，现在只需要两次数据拷贝就可以完成整个过程。</li>
</ul>
<p><img src="SG-DMA%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt=""></p>
<p>这就是所谓的零拷贝技术。现在我们不用再使用<code>CPU</code>来拷贝数据，全程通过<code>DMA</code>进行传输。</p>
<hr>
<h3 id="PageCache"><a href="#PageCache" class="headerlink" title="PageCache"></a>PageCache</h3><p>前面的提到的数据传输过程，第一步都是要把数据从磁盘中拷贝到内核缓冲区中。这里的内核缓冲区就是<strong>磁盘高速缓存</strong>（<code>PageCache</code>）。</p>
<p>由于读写磁盘比读写内存的速度慢多了，所以我们使用<code>DMA</code>把磁盘中的数据拷贝到内存中进行操作。但是，内存的空间远远小于磁盘，所以内存每次只能拷贝一部分的数据。那么内存是如何选择的呢？</p>
<p>我们运行程序的时候，具有局部性，就是说刚才被访问到的数据很有可能在短时间内再次被访问，于是我们可以使用<code>PageCache</code>来缓存最近被访问到的数据，当空间不足时就淘汰最久没有被访问过的缓存，也就是使用了<strong>最近最少使用</strong>算法。</p>
<p>所以读取磁盘数据的时候，会优先在<code>PageCache</code>找，如果有数据就直接返回；否则再从磁盘中获取，然后缓存到<code>PageCache</code>中。</p>
<p>还有一点，读取磁盘数据的时候，磁头会先旋转到数据所在的扇区，然后再开始顺序读取，这个物理动作是十分耗时的。为了降低这个影响，<code>PageCache</code>使用了预读的功能。</p>
<p>比如，<code>read()</code>方法每次只读取<code>32KB</code>的数据，那么一开始<code>read()</code>读取<code>0-32KB</code>的数据，内核会把后面的数据也预先读取到内核缓冲区中。这样<code>read()</code>读取后面的数据时成本就降低了。</p>
<p>所以总的来说，<code>PageCache</code>主要有缓存最近使用的数据和预读这两个功能。</p>
<p>但是，如果读取的是<code>GB</code>级别的大文件，就不应该使用<code>PageCache</code>，也就是说不应该使用零拷贝技术。这是因为如果把这些大文件拷贝到内存中，内存很快就被占满了，其余的热点小文件就不能使用到<code>PageCache</code>了，这样反而会导致读写数据的性能降低。</p>
<hr>
<h3 id="大文件的读写"><a href="#大文件的读写" class="headerlink" title="大文件的读写"></a>大文件的读写</h3><p>那么针对大文件应该使用什么方式读写呢？</p>
<p>首先回到最初，我们调用<code>read()</code>读取文件时，进程会阻塞于<code>read()</code>方法，对于阻塞的问题，我们可以使用异步<code>IO</code>来解决。</p>
<p><img src="%E5%BC%82%E6%AD%A5IO.png" alt=""></p>
<p>具体流程如下：</p>
<ul>
<li>首先应用进程向内核发起读请求，但是可以直接返回，不用等待数据返回。</li>
<li>内核向磁盘发起请求，磁盘把数据拷贝到磁盘控制器缓冲区后，产生一个中断给内核。</li>
<li>内核把磁盘控制器缓冲区中的数据拷贝到用户缓冲区后，用户进程收到通知，进行后续的处理。</li>
</ul>
<p>也就是说异步<code>IO</code>全程没有涉及到内核缓冲区，这样的<code>IO</code>也叫做直接<code>IO</code>。所以，针对高并发以及大文件传输的场景，应该使用这样的异步<code>IO</code>来代替零拷贝技术。</p>
<p>最后，针对整个业务场景，我们在传输文件的时候，可以根据文件的大小选择传输的方式：</p>
<ul>
<li>传输大文件时，使用异步<code>IO</code>。</li>
<li>传输小文件的时候，使用零拷贝的方式。</li>
</ul>
<p>在<code>nginx</code>中，我们可以通过配置实现这个功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    sendfile on;</span><br><span class="line">    aio on;</span><br><span class="line">    directio 1024m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当文件大小小于<code>1024m</code>，使用异步<code>IO</code>；否则使用零拷贝。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统进程间的通信</title>
    <url>/2021/03/03/Linux%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>Linux系统进程间的通信</p>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>每个进程都有自己的用户空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据就必须通过内核。在内核中开辟一块缓冲区，进程<code>A</code>把数据从用户空间拷贝到内核缓冲区，进程<code>B</code>再从内核缓冲区中把数据读取出来，内核提供的这种机制称为进程间通信。</p>
<hr>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>信号是<code>Linux</code>系统响应某些条件而产生的一个事件，由操作系统事先定义，接收到该信号的进程可以采取自定义行为。这是一种<strong>订阅-发布</strong>的模式。</p>
<p>信号的来源主要分为硬件和软件：</p>
<ul>
<li>硬件：比如按下<code>CTRL+C</code>、除<code>0</code>、非法访问内存等等。</li>
<li>软件：比如<code>kill</code>命令。</li>
</ul>
<p>一般的信号都是由一个错误产生的。以除<code>0</code>为例，在<code>x86</code>机器上<code>DIV</code>或<code>IDIV</code>指令除数为<code>0</code>时，会引发<code>0</code>号中断，编号<code>#DE(Divide Error)</code>。这是一个硬件级中断，会导致陷入内核，执行操作系统预定义在<code>IDT</code>中的中断处理程序。而操作系统处理这个异常的方法，就是向进程发送一个信号<code>SIGFPE</code>。如果进程设置了相应的<code>signal handler</code>，就执行进程的处理方法。否则执行操作系统的默认操作，一般这种信号的默认操作是杀死进程。</p>
<p>操作系统会将硬件异常包装为信号发送给进程。如果进程不处理这几个异常信号，那么默认的方式就是杀死进程。</p>
<p>但是，信号也可以作为进程间通信的一种方式，明确地由一个进程发送给另一个进程。进程如何发送信号？</p>
<ul>
<li>操作系统提供发送信号的系统调用。</li>
<li>该系统调用会将信号放到目标进程的信号队列中。</li>
<li>如果目标进程未处于执行状态，则该信号由内核保存起来，直到该进程恢复执行并传递给它为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到该阻塞被取消时才被传递给进程。</li>
</ul>
<p>进程对信号的处理有三种方式：</p>
<ul>
<li>处理信号：定义信号的函数。当信号产生时，执行相应的处理函数。</li>
<li>忽略信号：当不希望接收到的信号对进程的执行产生影响，而让进程继续执行时，可以忽略该信号，不做任何处理。</li>
<li>执行默认操作：<code>Linux</code>为每种信号都规定了默认的操作。</li>
</ul>
<p>值得注意的是，有些信号用户进程是无法处理也无法忽略的，例如<code>SIGSTOP</code>、<code>SIGKILL</code>。</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道命令，在<code>Linux Shell</code>中使用得很频繁。一般来说，我们使用管道操作符<code>|</code>来表示两个命令之间的数据通信。例如：<code>ps -ef | more</code>。管道操作符的内部实现就是<code>Linux</code>的管道接口。由<code>|</code>分割的每个命令都是独立的进程，各个进程的标准输出<code>STDOUT</code>，会作为下个进程的标准输入<code>STDIN</code>。</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>管道是一种半双工的通信方式，数据只能单向传输，上游进程向管道写入数据，下游进程从管道中接收数据。如果想要实现双方通信，需要建立两个管道。管道适合传输大量信息。管道发送的内容是以字节为单位的，没有格式的字节流。</p>
<h5 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h5><p>通过<code>pipe()</code>系统调用创建并打开一个管道，当最后一个使用它的进程关闭对它的引用时，<code>pipe</code>将自动撤销。通过<code>pipe()</code>创建的是匿名管道，只能用于具有亲缘关系的进程之间（父子进程或者兄弟进程）。</p>
<h5 id="管道的实现"><a href="#管道的实现" class="headerlink" title="管道的实现"></a>管道的实现</h5><p>管道就是一个文件，是一种只存在于内存中的特殊的文件系统。</p>
<p>在<code>Linux</code>中，管道借助了文件系统的<code>File</code>结构实现。父进程使用<code>File</code>结构保存向管道写入数据的例程地址，子进程保存从管道读取数据的例程地址。所以管道中的数据只能单向流动，并且只能用于具有亲缘关系的进程之间。</p>
<p>管道是由内核管理的一个缓冲区，缓冲区被设计为环形的数据结构，以便管道可以被循环利用。</p>
<h5 id="管道的同步"><a href="#管道的同步" class="headerlink" title="管道的同步"></a>管道的同步</h5><p>管道是一个具有特定大小的缓冲区：</p>
<ul>
<li>操作系统会保证读写进程的同步。</li>
<li>下游进程或者上游进程需要等待另一方释放锁之后才能操作管道。管道就相当于一个文件，同一时刻只能有一个进程访问。</li>
<li>管道为空时，下游进程阻塞；管道满时，上游进程阻塞。类似于生产者-消费者模式。</li>
<li>管道不再被任何进程使用时，自动释放。</li>
</ul>
<h5 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道 FIFO"></a>命名管道 FIFO</h5><p><code>Linux</code>管道分为匿名管道和命名管道。前面说的就是匿名管道，只能在有亲缘关系的进程中通信，管道文件保存在内存中。</p>
<p>命名管道<code>FIFO</code>可以用于没有亲缘关系的进程之间。<code>pipe</code>和<code>FIFO</code>除了建立、打开、删除的方式不同之外，二者几乎一样。</p>
<p>通过<code>mknode()</code>系统调用或者<code>mkfifo()</code>函数创建命名管道。一旦建立，任何有访问权的进程都可以通过文件名将其打开、进行读写，不再局限于有亲缘关系的进程之间。</p>
<p>建立命名管道时，会在磁盘中创建一个索引节点，命名管道的名字相当于索引节点的文件名。索引节点设置了进程的访问权限，但是没有数据块。命名管道实质上也是通过内核缓冲区来实现数据传输。有权限访问的进程，可以通过磁盘的索引节点来读写这块缓冲区。</p>
<p>同样的，当命名管道不再被任何进程使用时，也会被释放，但是磁盘节点仍然存在。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量（<code>semaphore</code>）是一种特殊的变量，对它的操作都是原子的。它有两种操作：<code>V(signal())</code>和<code>P(wait())</code>。<code>V</code>操作会使得信号量<code>S</code>的数值增加，而<code>P</code>会减少数值。</p>
<ul>
<li><code>V</code>：如果有其他进程因为等待<code>S</code>而被挂起，就让它恢复运行，否则<code>S</code>加<code>1</code>。</li>
<li><code>P</code>：如果<code>S</code>为<code>0</code>，则挂起进程，否则<code>S</code>减<code>1</code>。</li>
</ul>
<p>如果信号量是一个任意的整数，通常被称为计数信号量，或一般信号量。如果信号量只有二进制的<code>0</code>和<code>1</code>，称为二进制信号量。在<code>Linux</code>系统中，二进制信号量又称为互斥锁。信号量可以用于实现进程或线程的互斥和同步。</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存（<code>shared memory</code>），允许多个进程共享同一段物理内存。不同进程可以将同一段共享内存映射到自己的地址空间，然后像访问正常内存一样访问它。不同进程可以通过向共享内存端读写数据来交换信息。</p>
<p>共享内存的优点是简单高效。访问共享内存和访问进程独有的内存速度一样快，原因是不需要系统调用，不涉及用户态和内核态的上下文切换，也减少了冗余的数据拷贝。</p>
<p>共享内存的缺点是存在并发问题，可能同时有多个进程修改同一快内存，所以共享内存一般和信号量结合使用。</p>
<p>在<code>Linux 2.2.x</code>开始支持多种共享内存的方式，以前介绍过的<code>mmap()</code>系统调用就是通过共享内存的方式进行通信。</p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列（<code>Message Queue</code>）是一个消息的链表，保存在内核中。消息队列中的每个消息都是一个数据块，具有特定的格式。操作系统中可以存在多个消息队列，每个队列有唯一的<code>key</code>。</p>
<p>消息队列克服了信号传递信息少、管道只能传输无格式字节流等等缺点。消息队列允许一个进程或多个进程向它写入或读取消息。消息发送者和接收者不需要同时和消息队列交互，消息会保存在队列中。也就是说，消息队列是异步的，接收者需要轮询消息队列，才能收到最近的消息。</p>
<p>消息队列中的数据是有格式的，并且获取消息的进程可以选择接收特定类型的消息。</p>
<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p>套接字（<code>socket</code>）是非常常见的进程间通信方式。</p>
<ul>
<li>不同的计算机进程之间通过<code>socket</code>通信，也可用于同一台计算机的不同进程。</li>
<li>需要通信的进程之间首先各自创建一个<code>socket</code>，包括主机地址和端口号，声明自己接收来自某端口地址的数据。</li>
<li>进程通过<code>socket</code>把消息发送到网络层中，网络层通过主机地址将其发送到目标主机，目标主机通过端口号发给对应的进程。</li>
</ul>
<p>操作系统提供创建<code>socket</code>、发送、接收的系统调用，为每个<code>socket</code>都设置了发送缓冲区、接收缓冲区。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统内存管理</title>
    <url>/2021/03/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>操作系统内存管理</p>
<a id="more"></a>

<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>我们知道，单片机是没有操作系统的，所以每次写完代码都要通过工具把代码烧录进去，这样程序才能运行起来。同时，单片机的<code>CPU</code>是直接操作内存的物理地址的，也就是说，想要同时运行两个程序是不可能的。如果一个程序在地址<code>10000</code>写入一个值，那么会覆盖掉其他程序存放在这个位置的值，所以两个程序是不能同时运行的。</p>
<p>那么操作系统是如何解决的呢？操作系统将不同进程使用的地址隔离开来，为每个进程独立分配一个虚拟地址，这样程序之间就没有干扰了。但前提是每个进程都不能直接访问物理地址，至于虚拟地址是如何落到物理地址的，程序不需要理会，操作系统提供了这种机制，将不同进程的虚拟地址和物理地址向映射起来。当程序想要访问虚拟地址时，操作系统会转换成不同的物理地址，这样就不会有冲突了。</p>
<p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过<code>CPU</code>芯片中的内存管理单元（<code>MMU</code>）的映射关系，转换成物理地址，然后再通过物理地址访问内存：</p>
<p><img src="%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt=""></p>
<p>那么操作系统是如何管理虚拟地址和真实物理地址的呢？主要有两种方式：<strong>内存分段</strong>和<strong>内存分页</strong>。</p>
<hr>
<h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>内存分段是早期提出的方案。程序是由若干个逻辑分段组成的，不同的段有不同的属性，所以就用分段的形式把这些段隔离开。</p>
<p>在分段机制下，虚拟地址由<strong>段选择子</strong>和<strong>段内偏移量</strong>组成。</p>
<p><img src="%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5.png" alt=""></p>
<p>段选择子保存在段寄存器中，包含段号和特权等标志位。其中最重要的是段号，用作段表的索引。段表保存的是这个段的基地址、段界限以及特权等级等等。</p>
<p>虚拟地址中的段内偏移量应该位于<code>0</code>和段界限之间。如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理地址。</p>
<p>分段机制会把程序的虚拟地址分为<code>4</code>段，每个段在段表中有一个项，在这个项找到段的基地址，再加上偏移量，就能够找到对应的物理地址了。如下图：</p>
<p><img src="%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5-%E8%99%9A%E6%8B%9F%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.png" alt=""></p>
<p>使用内存分段我们不再需要关心物理地址的问题，但它也有不足之处：容易产生内存碎片，以及内存交换的效率低。</p>
<ul>
<li>外部内存碎片：在清除内存后，很容易使得空闲的内存不是连续的，降低了内存的利用率。</li>
<li>内部内存碎片：程序所有的内存都会加载到物理内存中，即使有部分内存不经常使用，这也导致了内存的浪费。</li>
</ul>
<p>解决外部内存碎片的问题可以使用内存交换，也就是说把程序重新写到磁盘上，再从磁盘中读取到内存中，不过这次要紧挨这其他占用的内存解决碎片化问题。在<code>Linux</code>系统中，就是我们经常看到的<code>swap</code>分区。</p>
<p>那么为什么内存交换的效率低呢？这是因为内存碎片是很容易产生的。如果产生了内存碎片，就要进行交换，由于磁盘的访问速度是很慢的，每次交换都要把整段程序的内存数据写到磁盘上再读出来，这效率无疑是非常低的。</p>
<p>所以为了解决这两个问题，引入了<strong>内存分页</strong>。</p>
<hr>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，就叫做页。在<code>Linux</code>系统中，每一页的大小为<code>4KB</code>。</p>
<p>虚拟地址和物理地址之间通过页表来映射：</p>
<p><img src="%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5%E6%98%A0%E5%B0%84.png" alt=""></p>
<p>页表实际上存储在<code>CPU</code>的内存管理单元（<code>MMU</code>）中，因此<code>CPU</code>就可以直接通过<code>MMU</code>找出实际要访问的物理地址。如果进程访问的虚拟地址在页表中不存在时，系统会产生一个缺页异常，进入内核空间分配物理内存并更新页表，最后再返回用户空间恢复进程的运行。</p>
<p>那么分页是怎么解决内存碎片以及内存交换效率低的问题呢？</p>
<p>由于分页的内存空间都是预先划分好的，不会像分段那样产生间隙很小的内存。而且释放的时候都是以页为单位释放的，所以不会残留无法给进程使用的小内存。当内存空间不够时，操作系统会把其他正在运行的进程中最近没被使用的内存给释放掉，暂时交换到磁盘中。一旦需要的时候再加载进来。所以，一次性写入磁盘的只有少数的几页，效率比较高。</p>
<p>再者，我们不需要一次性把程序都加载到物理内存中。我们可以在进行虚拟内存和物理内存的页之间的映射后，并不把页真的加载到物理内存中，而是等到需要使用到对应虚拟内存页中的指令和数据时，再加载到物理内存中去。</p>
<p>那么在分页机制下，虚拟地址和物理地址具体是怎么映射的呢？</p>
<p>虚拟地址分为两部分：<strong>页号</strong>和<strong>页内偏移量</strong>。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址和页内偏移量组合就构成了物理地址。如下图：</p>
<p><img src="%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5-%E8%99%9A%E6%8B%9F%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.png" alt=""></p>
<p>但是这种简单的分页会导致占用空间过大的问题。</p>
<p>在<code>32</code>位系统环境下，虚拟地址空间有<code>4GB</code>，假设一个页的大小是<code>4KB</code>，那么就需要大约<code>100</code>万个页，每个页表项需要<code>4</code>个字节来存储，那么整个页表就需要约<code>4MB</code>的内存。假设系统一共有<code>100</code>个进程，那么就需要<code>400MB</code>的内存来存储页表，这是相当大的耗费了。</p>
<p>为了解决这个问题，又引入了<strong>多级页表</strong>。</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>我们将<code>100</code>多万个页表项分为两级，第一级有<code>1024</code>个页表项，每个页表项又有<code>1024</code>个页表项，这样就组成了二级分页。如下图：</p>
<p><img src="%E5%A4%9A%E7%BA%A7%E5%88%86%E9%A1%B5.png" alt=""></p>
<p>但这样似乎占了更多的空间？当然了，如果所有的虚拟地址都映射到了物理地址上，二级分页确实占用了更多的内存，但往往我们并不会给一个进程分配那么多内存。</p>
<p>每个进程都有<code>4GB</code>的虚拟地址空间，然后对于大多数进程，使用到的空间远没有<code>4GB</code>。大多数的页表项都是空的，没有分配，对于已分配的页表项，如果存在最近一段时间未访问的页表，在物理内存紧张的情况下，操作系统会把页面换出到磁盘，不会再占用物理内存。</p>
<p>如果使用了二级分页，以及页表就可以覆盖所有<code>4GB</code>的虚拟地址空间了，但如果某个页表的页表项没有被用到，也就不用创建这个页表项对应的二级页表了，直到需要时才创建。</p>
<p>假设只有<code>20%</code>的页表项被用到了，那么二级分页占用的内存只有：<code>4KB + 0.2 * 4MB</code>，这就比<code>4MB</code>小多了。</p>
<p>对于<code>64</code>位系统，变成了四级目录，分别是：</p>
<ul>
<li>全局页目录项<code>PGD(Page Global Directory)</code></li>
<li>上层页目录项<code>PUD(Page Upper Directory)</code></li>
<li>中间页目录项<code>PMD(Page Middle Directory)</code></li>
<li>页表项<code>PTE(Page Table Entry)</code></li>
</ul>
<p><img src="%E5%9B%9B%E7%BA%A7%E7%9B%AE%E5%BD%95.png" alt=""></p>
<p>多级分页虽然解决了空间的问题，但这样虚拟地址到物理地址的转换就多了几道转换的工序，自然也就降低了效率。</p>
<h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><p>程序具有局部性，即在一段时间内，整个程序的执行仅限于整个程序的一部分。也就是说，执行所访问到的内存空间也仅限于某一部分。我们可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，也就是<code>TLB(Translation Lookaside Buffer)</code>，通常称为页表缓存。有了<code>TLB</code>，<code>CPU</code>在寻址的时候，会首先查找<code>TLB</code>，如果没有才按照之前的流程找到相应的页表项。</p>
<hr>
<h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>内存分段和内存分页并不是对立的，反而是可以组合在一起使用的，也就叫做段页式内存管理。</p>
<p>首先将程序划分为多个有逻辑意义的段，然后把每个段分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页。这样，地址结构就由<strong>段号</strong>、<strong>段内页号</strong>以及<strong>页内偏移量</strong>三部分组成。</p>
<p><img src="%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98.png" alt=""></p>
<p>首先访问段表，得到页表的起始位置，然后访问页表得到物理页号，最后根据物理页号以及页内偏移量得到真实的物理地址。</p>
<hr>
<h3 id="Linux-内存管理"><a href="#Linux-内存管理" class="headerlink" title="Linux 内存管理"></a>Linux 内存管理</h3><p>说了这么多，<code>Linux</code>系统又是采用哪种方式进行内存管理的呢？先说说<code>intel</code>处理器的发展史。</p>
<p>早期的<code>Intel</code>处理器从<code>80286</code>开始使用分段内存管理。但是很快发现，没有分页内存管理是不够的，所以在<code>80386</code>中就实现了分页内存管理。但这个分页内存管理并没有绕开分段内存管理，而是建立在其之上。也就是说，分页内存管理的作用是在分段内存管理所映射而成的地址上再加上一层地址的映射。</p>
<p>这时分段内存管理映射的地址不再是物理地址了，所以<code>Intel</code>把它称之为<strong>线性地址</strong>，也叫做虚拟地址。于是，分段内存管理先将逻辑地址映射为线性地址，然后再由分页内存管理将线性地址映射为物理地址。</p>
<p><img src="intel%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90.png" alt=""></p>
<p>说完了<code>intel</code>处理器的发展史，现在来说说<code>Linux</code>是如何管理分配内存的呢？</p>
<p><code>Linux</code>内存主要采用页式内存管理，但同时也使用了段机制。这是因为<code>intel</code>处理器的硬件结构就是这样，<code>Linux</code>只能妥协。但事实上，<code>Linux</code>内核尽量使得段机制在实际过程中起不到什么作用。</p>
<p><code>Linux</code>系统中的每个段都是从<code>0</code>地址开始的整个<code>4GB</code>虚拟地址空间（<code>32</code>位环境下）。也就是说所有的段的起始地址都是一样的。这意味着<code>Linux</code>中的所有代码所面对的地址空间都是虚拟地址空间，相当于直接屏蔽了逻辑地址的概念，段只被用于访问控制和内存保护。</p>
<p>在<code>Linux</code>系统中，虚拟地址空间的内部又分为<strong>内核空间</strong>和<strong>用户空间</strong>。对于<code>32</code>位系统，内核空间为<code>1GB</code>，用户空间为<code>3GB</code>；对于<code>64</code>位系统，虚拟地址空间一共占了<code>2^48</code>，内核空间和用户空间各占了<code>128TB</code>，分别位于内存空间的最高位和最低位，中间剩下的部分是未定义的。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap详解</title>
    <url>/2020/07/29/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>ConcurrentHashMap详解</p>
<a id="more"></a>

<h3 id="为什么-HashTable-慢"><a href="#为什么-HashTable-慢" class="headerlink" title="为什么 HashTable 慢"></a>为什么 HashTable 慢</h3><p><code>hashTable</code>之所以慢是因为内部的实现使用了<code>Synchronized</code>关键字对<code>put</code>等操作加锁，而<code>Synchronized</code>加锁是直接对整个对象加锁，也就是说<code>put</code>等修改<code>Hash</code>表的操作直接锁住了整张表，所以效率较低。</p>
<hr>
<h3 id="ConcurrentHashMap-JDK-1-7"><a href="#ConcurrentHashMap-JDK-1-7" class="headerlink" title="ConcurrentHashMap(JDK 1.7)"></a>ConcurrentHashMap(JDK 1.7)</h3><p>在<code>JDK 1.5-1.7</code>版本，<code>Java</code>使用了<strong>分段锁</strong>的机制实现了<code>ConcurrentHashMap</code>。</p>
<p>简而言之，<code>ConcurrentHashMap</code>在对象中存储了一个<code>Segment</code>数组，将整个<code>Hash</code>表划分为多个分段；而每个<code>Segment</code>类似于一个<code>HashTable</code>。这样一来，在进行<code>put</code>等操作时首先会根据<code>Hash</code>算法定位到元素属于哪个<code>Segment</code>，然后对该<code>Segment</code>加锁即可，这样就避免了对整张表加锁，提升了并发性能。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>整个<code>ConcurrentHashMap</code>由多个<code>Segment</code>组成。<code>Segment</code>通过继承<code>ReetrantLock</code>来加锁，所以每次需要加锁只需要锁住一个<code>Segment</code>即可。</p>
<p><img src="concurrenthashmap-jdk1.7.png" alt=""></p>
<p><code>concurrentcyLevel</code>：<code>Segment</code>的数量，默认为<code>16</code>。也就是说，理论上这时<code>ConcurrentHashMap</code>可以支持最多<code>16</code>个线程同时写。这个值可以在初始化的时候设置为其他值，但是初始化之后就不可扩容了。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li><code>initialCapacity</code>：初始容量，这个值指的是整个<code>ConcurrentHashMap</code>的初始容量，实际操作时要平均分给每个<code>Segment</code>。</li>
<li><code>loadFactor</code>：负载因子，给每个<code>Segment</code>使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 假设concurrencyLevel为默认值16</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ssize=16，sshift=4，segmentShift=28，segmentMask=15</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 假设initialCapacity为64，每个Segemnt可以分到4个</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">// MIN_SEGMENT_TABLE_CAPACITY默认为2</span></span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建Segment数组</span></span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成，我们得到一个<code>Segment</code>数组。假设使用无参构造器，那么初始化完成后：</p>
<ul>
<li><code>Segment</code>数组长度默认为<code>16</code>，不可以扩容。</li>
<li><code>Segemnt[i]</code>默认大小为<code>2</code>，负载因子是<code>0.75</code>，所以初始阈值为<code>1.5</code>，也就是说插入第一个元素不会扩容，插入第二个会触发第一次扩容。</li>
</ul>
<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 根据hash值算出Segment数组中的位置j：</span></span><br><span class="line">    <span class="comment">// hash值是32位，右移28位，保留高4位，然后和15进行位于。</span></span><br><span class="line">    <span class="comment">// 也就是说j是hash值的高4位，也是Segment数组的下标。</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 一开始只会初始化segment[0]，其他位置还是null</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 初始化segment[j]</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 找到Segment数组下标，进入具体的put逻辑</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Segment</code>数组内部使用<strong>数组+链表</strong>的结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在put之前要先获取该Segment的独占锁。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">    scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Segment内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 利用hash值计算出应该放置在数组的哪个位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 获取链表头部</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="comment">// 循环链表</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="comment">// 如果已经存在相同的值且不使用onlyIfAbsent模式，就覆盖这个值</span></span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果node不为null，把它设置为链表头部；否则初始化再设置为链表头部。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果元素个数超过了阈值，就进行扩容。</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 否则把node放到数组tab的index位置。</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面提到，<code>ConcurrentHashMap</code>初始化的时候只会初始化第一个槽，对于其他槽，在插入第一个值的时候才初始化。</p>
<p>所以这里需要考虑并发的问题，因为有可能有多个线程同时初始化同一个槽。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">// 检查槽是否已被其他线程初始化了</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">// 使用当前segment[0]处的数组长度和负载因子来初始化segment[k]</span></span><br><span class="line">        <span class="comment">// 所以之前要先初始化segment[0]</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        <span class="comment">// 初始化内部结构</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="comment">// 再次检查槽是否已被其他线程初始化了</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// CAS循环初始化，初始化成功就退出</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面进行<code>put</code>操作时需要获取独占锁，首先会调用<code>tryLock()</code>尝试获取锁，如果失败，就进入到<code>scanAndLockForPut</code>方法获取锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="comment">// 循环获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    <span class="comment">// 到了这里说明数组该位置的链表是空的，不过该槽存在并发，不一定是该位置。</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果重试次数超过了MAX_SCAN_RETRIES（单核1多核64），那么不重试了，直接进入阻塞队列等待锁。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到了这里说明有新元素进入了链表，成为了表头</span></span><br><span class="line">        <span class="comment">// 策略是重新走一遍scanAndLockForPut方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法要么获取到了锁要么进入阻塞队列等待锁。</p>
<h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>前面提到，<code>Segment</code>数组是不能扩容的，扩容的是<code>Segment</code>数组内部的<code>HashEntry&lt;K, V&gt;[]</code>结构。扩容后，容量变为原来的两倍。</p>
<p>这个方法不需要考虑并发，因为需要扩容的条件是<code>put</code>元素时发现元素个数超过了阈值，而这个时候<code>put</code>操作已经获取到了独占锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node是扩容之后要添加的元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 两倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 重新计算掩码</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历原数组，将原数组下标i处的链表拆分到下标i和i+oldCap两个位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取链表头部</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 重新计算下标</span></span><br><span class="line">            <span class="comment">// 假设原数组长度为16，e在10的位置，那么扩容后只可能是10或者10+16=26的位置</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="comment">// 如果只有一个元素，直接赋值</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 表头</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="comment">// 新下标</span></span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 找到一个lastRun节点，该节点之后的元素要放到一起</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 把lastRun之后的节点组成的链表放到新数组的lastIdx位置</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="comment">// 处理lastRun节点之前的节点，这些节点可能放在另一个链表，也可能放到上面那个链表中。</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要put的节点放到新数组中两个链表之一的头部</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>相比于<code>put</code>，<code>get</code>就简单多了。</p>
<ul>
<li>首先计算<code>hash</code>值，找到<code>Segment</code>数组中具体的位置。</li>
<li>再根据<code>hash</code>值计算出<code>Segment</code>内部数组中具体的位置。</li>
<li>遍历链表寻找即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 根据hash值找到位置</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 判断segment[u]是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到内部数组的位置，遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">             (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>get</code>方法是没有加锁的，那么如果<code>get</code>的时候对应<code>Segment</code>数组发生了<code>put</code>或者<code>remove</code>怎么办呢？</p>
<ul>
<li><code>put</code>：<ul>
<li>初始化<code>Segment</code>数组：这个是通过<code>CAS</code>保证的。</li>
<li>添加节点的时候是添加到表头的。所以如果<code>get</code>操作已经遍历到了链表中间，那么没有影响；如果<code>get</code>发生在之后，那么需要保证新添加的节点也需要被读取到，这是通过<code>UNSAFE.putOrderedObject</code>来保证的。</li>
<li>扩容时：扩容其实是创建了一个新数组，然后迁移数据。所以<code>get</code>先行的话，就是在扩容之前的数组上查询；如果<code>put</code>先行，那么就是通过<code>volatile</code>来保证可见性的。</li>
</ul>
</li>
<li><code>remove</code>：<ul>
<li><code>get</code>需要遍历链表，但是<code>remove</code>会破坏链表。</li>
<li>如果<code>remove</code>的节点<code>get</code>操作已经过去了，那就不会有影响。</li>
<li>如果<code>remove</code>先破坏了一个节点，那么：如果该节点是头节点，那么需要把头节点的<code>next</code>设置为数组该位置的元素，使用<code>UNSAFE</code>操作数组；如果不是头节点，那么会把要删除节点的后继节点连接到前驱节点中，使用<code>volatile</code>保证可见性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="ConcurrentHashMap-JDK-1-8"><a href="#ConcurrentHashMap-JDK-1-8" class="headerlink" title="ConcurrentHashMap(JDK 1.8)"></a>ConcurrentHashMap(JDK 1.8)</h3><p>在<code>JDK 1.8</code>中，<code>ConcurrentHashMap</code>完全摒弃了分段锁的机制，而是选择了类似于<code>HashMap</code>的<strong>数组+链表+红黑树</strong>的方式实现的，加锁采用<code>CAS</code>和<code>synchronized</code>实现。</p>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p><img src="concurrenthashmap-jdk1.8.png" alt=""></p>
<p>其结构和<code>HashMap</code>基本一致。</p>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法通过提供初始容量，计算出<code>sizeCtl = (1.5 * initialCapacity) + 1</code>，然后向上取最近的<code>2</code>的<code>n</code>次方。</p>
<h4 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 获取hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组为空，初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 找该hash值对应的数组下标，拿到第一个节点f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为空，通过CAS把传进来的值放入其中即可，直接跳出循环到最后了。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 数据迁移</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 如果运行到这里，说明数组该位置不为空，f为头节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置头节点的监视器锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 头节点的hash值大于0，说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 记录链表长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现相等的key，根据onlyIfAbsent决定是否覆盖</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 到达链表尾部，把这个值放到链表末尾。</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果是红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 红黑树插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和HashMap一致，也是8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 如果数组长度小于64，不会转换成红黑树，而是进行数组扩容。</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化数组函数：<code>initTable</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化的工作被别的线程抢走了</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS设置sizeCtl为-1，表示抢到了锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// DEFAULT_CAPACITY默认为16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">// 初始化数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 赋值给table，table是volatile的</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 0.75 * n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表转红黑树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// MIN_TREEIFY_CAPACITY为64</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 扩容，不会转为红黑树</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// b是头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">// 遍历链表，创建红黑树</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 把红黑树设置到数组的相应位置中</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// size传进来时已经翻倍</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// size的1.5倍+1，向上取2的n次方</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">    tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 和初始化数组一样</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// sc的高16位表示至少有一个线程对容量n进行大小调整操作，低16位表示有多少先驱者正在同时调整大小。</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用CAS将SizeCtl+1，执行transfer方法</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据迁移方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 单核下stride=n，多核等于n&gt;&gt;&gt;3</span></span><br><span class="line">    <span class="comment">// stride可以理解为步长，有n个位置等待数据迁移</span></span><br><span class="line">    <span class="comment">// 将这n个任务分为多个任务包，每个任务包有stride个任务</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">// 如果nextTab为null，进行第一次初始化</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 容量翻倍</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// 正在被迁移的node，在原数组中位于i的节点完成迁移后会把自己的位置设置为ForwardingNode，表示已处理完</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">// 所有数据已迁移完</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// sizeCtl在迁移前会设置为(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，每有一个线程参与就会+1</span></span><br><span class="line">            <span class="comment">// 使用CAS对sizeCtl-1，表示自己完成了任务</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果i处为空，放入刚刚设置的ForwardingNode空节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 表示已迁移完成</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 加锁，开始该位置节点的迁移</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 如果是链表的node节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        <span class="comment">// 和JDK1.7差不多，将链表一分为二，找到lastRun节点。。</span></span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 其中一个链表放在新数组的i位置</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 另一个放在i+n位置</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 设置该位置为ForwardingNode，表示处理完成</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树的迁移</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果一分为二后长度小于6，将红黑树重新转变为链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">// 和上面一样</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 头节点是否就是要找的</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果hash值小于0说明正在扩容或者是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ConcurrentHashMap</category>
      </categories>
      <tags>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL详解</title>
    <url>/2024/04/22/MySQL%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>
<h2 id="非关系型数据库和关系型数据库"><a href="#非关系型数据库和关系型数据库" class="headerlink" title="非关系型数据库和关系型数据库"></a>非关系型数据库和关系型数据库</h2><p>关系型数据库的优点</p>
<ul>
<li>容易理解，因为它采用了关系模型来组织数据。</li>
<li>可以保持数据的一致性。</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带 where 子句的查询）。</li>
</ul>
<p>非关系型数据库（NOSQL）的优点</p>
<ul>
<li>无需经过 SQL 层的解析，读写效率高。</li>
<li>基于键值对，读写性能很高，易于扩展</li>
<li>可以支持多种类型数据的存储，如图片，文档等等。</li>
<li>扩展（可分为内存性数据库以及文档型数据库，比如 Redis，MongoDB，HBase 等，适合场景：数据量大高可用的日志系统/地理位置存储系统）。</li>
</ul>
<h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h2><ul>
<li>第一范式：数据表中的每一列（每个字段）都不可以再拆分。例如用户表，用户地址还可以拆分成国家、省份、市，这样才是符合第一范式的。</li>
<li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。例如订单表里，存储了商品信息（商品价格、商品类型），那就需要把商品 ID 和订单 ID 作为联合主键，才满足第二范式。</li>
<li>第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。例如订单表，就不能存储用户信息（姓名、地址）。</li>
</ul>
<p>三大范式的作用是为了控制数据库的冗余，是对空间的节省，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。</p>
<h2 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p><img src="MySQL%E6%9E%B6%E6%9E%84.png" alt="MySQL架构"></p>
<p><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<p><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。</p>
<p><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<p><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。</p>
<p>MySQL 的查询流程具体是？or 一条SQL语句在MySQL中如何执行的？</p>
<ul>
<li>先检查该语句<code>是否有权限</code>，如果没有权限，直接返回错误信息，如果有权限会先查询缓存 (MySQL8.0 版本以前)。</li>
<li>如果没有缓存，分析器进行<code>语法分析</code>，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误，比如关键词是否正确等等。</li>
<li>语法解析之后，MySQL 的服务器会对查询的语句进行优化，确定执行的方案。</li>
<li>完成查询优化后，按照生成的执行计划<code>调用数据库引擎接口</code>，返回执行结果。</li>
</ul>
<p><img src="%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询流程"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>主要包括以下五大类：</p>
<ul>
<li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li>
<li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li>
<li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li>
<li>日期类型：Date、DateTime、TimeStamp、Time、Year</li>
<li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734bff30a28cf0d~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="数据类型"></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734bff309f9eea0~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="数据类型"></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734bff30a5e00fe~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="数据类型"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="CHAR-和-VARCHAR-的区别？"><a href="#CHAR-和-VARCHAR-的区别？" class="headerlink" title="CHAR 和 VARCHAR 的区别？"></a>CHAR 和 VARCHAR 的区别？</h4><p>char是固定长度，varchar长度可变：</p>
<p>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p>
<p>存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间</p>
<p>相同点：</p>
<ol>
<li>char(n)，varchar(n)中的n都代表字符的个数</li>
<li>超过char，varchar最大长度n的限制后，字符串会被截断。</li>
</ol>
<p>不同点：</p>
<ol>
<li>char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0&lt;=length&lt;255）或加2（length&gt;255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。</li>
<li>能存储的最大空间限制不一样：char的存储上限为255字节。</li>
<li>char在存储时会截断尾部的空格，而varchar不会。</li>
</ol>
<p>char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。</p>
<h4 id="列的字符串类型可以是什么？"><a href="#列的字符串类型可以是什么？" class="headerlink" title="列的字符串类型可以是什么？"></a>列的字符串类型可以是什么？</h4><p>字符串类型是：SET、BLOB、ENUM、CHAR、TEXT、VARCHAR</p>
<h4 id="BLOB和TEXT有什么区别？"><a href="#BLOB和TEXT有什么区别？" class="headerlink" title="BLOB和TEXT有什么区别？"></a>BLOB和TEXT有什么区别？</h4><p>BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和LONGBLOB</p>
<p>TEXT是一个不区分大小写的BLOB。四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。</p>
<p>BLOB 保存二进制数据，TEXT 保存字符数据。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。</p>
<p>使用哪一种引擎可以灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能 。</p>
<p>MySQL服务器使用<strong>可插拔</strong>的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。</p>
<p>常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。</p>
<p>InnoDB 现在是 MySQL 默认的存储引擎，支持<strong>事务、行级锁定和外键</strong>。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>InnoDB 和 MyISAM 之间的区别主要表现在存储结构、事务支持、最小锁粒度、索引类型、主键必需、表的具体行数、外键支持等方面。</p>
<ol>
<li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li>MyISAM用三种格式的文件来存储，.frm 文件存储表的定义；.MYD 存储数据；.MYI 存储索引。InnoDB用两种格式的文件来存储，.frm 文件存储表的定义；.ibd 存储数据和索引。</li>
<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>
<li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
</ol>
<p>MyISAM</p>
<p><img src="MyISAM.png" alt="MyISAM"></p>
<p>InnoDB为聚簇索引，索引和数据不分开。</p>
<p><img src="InnoDB.png" alt="InnoDB"></p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p><strong>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</strong></p>
<p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；<br>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p>
<p><strong>哪个存储引擎执行 select count(*) 更快，为什么?</strong></p>
<p>MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。</p>
<ul>
<li>在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。</li>
<li>在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。</li>
</ul>
<p>InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p>
<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul>
<li>大多数情况下，使用默认的 InnoDB 就对了，InnoDB 可以提供事务、行级锁等能力。</li>
<li>MyISAM 适合读更多的场景。</li>
<li>MEMORY 适合临时表，数据量不大的情况。由于数据都存放在内存，所以速度非常快。</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MYSQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong></p>
<p>索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 。</p>
<p>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，<strong>数据库还维护者一个满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例。</p>
<p><img src="%E7%B4%A2%E5%BC%95.png" alt="索引"></p>
<p>左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址</p>
<p>为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。</p>
<ul>
<li><p>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></p>
</li>
<li><p>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</p>
</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li><p>创建：</p>
<ul>
<li><p>创建索引：<code>CREATE [UNIQUE] INDEX indexName ON mytable(username(length));</code></p>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
</li>
<li><p>修改表结构(添加索引)：<code>ALTER table tableName ADD [UNIQUE] INDEX  indexName(columnName)</code></p>
</li>
</ul>
</li>
<li><p>删除：<code>DROP INDEX [indexName] ON mytable;</code></p>
</li>
<li><p>查看：<code>SHOW INDEX FROM table_name\G</code>             –可以通过添加 \G 来格式化输出信息。</p>
</li>
<li><p>使用ALERT命令</p>
<ul>
<li><p><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</code> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</p>
</li>
<li><p><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list</code> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</p>
</li>
<li><p><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code> 添加普通索引，索引值可出现多次。</p>
</li>
<li><p><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code>该语句指定了索引为 FULLTEXT ，用于全文索引。</p>
</li>
</ul>
</li>
</ul>
<h3 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h3><p>优势：</p>
<ul>
<li><strong>提高数据检索效率，降低数据库IO成本</strong></li>
<li><strong>降低数据排序的成本，降低CPU的消耗</strong></li>
</ul>
<p>劣势：</p>
<ul>
<li><p>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</p>
</li>
<li><p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</p>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h4><ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>Full-Text全文索引</li>
<li>R-Tree索引</li>
</ul>
<h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h4><ul>
<li><p>聚集索引（clustered index）</p>
</li>
<li><p>非聚集索引（non-clustered index），也叫辅助索引（secondary index）</p>
<p>聚集索引和非聚集索引都是B+树结构</p>
</li>
</ul>
<h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h4><ul>
<li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li>
<li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li>
<li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li>
<li>唯一索引或者非唯一索引</li>
<li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。 MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</li>
</ul>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p>
<h4 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+ Tree 索引"></a>B+ Tree 索引</h4><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。</p>
<p><strong>先了解下 B-Tree 和 B+Tree 的区别</strong></p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。</p>
<p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
<p>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></p>
<p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p>
<p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p>
<p>一棵m阶的B-Tree有如下特性： </p>
<ol>
<li>每个节点最多有m个孩子 </li>
<li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。</li>
<li>若根节点不是叶子节点，则至少有2个孩子 </li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息 </li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） </li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1 </li>
<li>ki(i=1,…n)为关键字，且关键字升序排序</li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p>
<p><img src="B-Tree.png" alt="B-Tree"></p>
<p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p>
<p>模拟查找关键字29的过程：</p>
<ol>
<li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li>
<li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
<li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
<li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
<li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
<li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ol>
<p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</p>
<p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上</strong>，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p>B+Tree相对于B-Tree有几点不同：</p>
<ol>
<li>非叶子节点只存储键值信息；</li>
<li>所有叶子节点之间都有一个链指针；</li>
<li>数据记录都存放在叶子节点中</li>
</ol>
<p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p>
<p><img src="B+Tree.png" alt="B+Tree"></p>
<p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p>
<p>B+Tree性质</p>
<ol>
<li>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li>
<li>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li>
</ol>
<h5 id="MyISAM主键索引与辅助索引的结构"><a href="#MyISAM主键索引与辅助索引的结构" class="headerlink" title="MyISAM主键索引与辅助索引的结构"></a>MyISAM主键索引与辅助索引的结构</h5><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”<strong>非聚簇索引</strong>“。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。</p>
<p><img src="MyISAM%E7%B4%A2%E5%BC%95.png" alt="MyISAM"></p>
<p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量（通过偏移量访问就是随机访问，速度很快）。</p>
<p>主索引是指主键索引，键值不可能重复；辅助索引则是普通索引，键值可能重复。</p>
<p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p>
<h5 id="InnoDB主键索引与辅助索引的结构"><a href="#InnoDB主键索引与辅助索引的结构" class="headerlink" title="InnoDB主键索引与辅助索引的结构"></a>InnoDB主键索引与辅助索引的结构</h5><p><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为”“聚簇索引”，一个表只能有一个聚簇索引。</p>
<h6 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h6><p>我们知道InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。</p>
<p><img src="InnoDB%E7%B4%A2%E5%BC%95.png" alt="InnoDB"></p>
<p>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启<code>innodb_file_per_table)</code>，切分后存放在<code>xxx.ibd</code>中，默认不切分，存放在<code>xxx.ibdata</code>中。</p>
<h6 id="辅助（非主键）索引"><a href="#辅助（非主键）索引" class="headerlink" title="辅助（非主键）索引"></a>辅助（非主键）索引</h6><p>这次我们以示例中学生表中的name列建立辅助索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是辅助索引，按照ASCII码进行排序，第二行的整数是主键的值。</p>
<p>这就意味着，对name列进行条件搜索，需要两个步骤：</p>
<p>① 在辅助索引上检索name，到达其叶子节点获取对应的主键；</p>
<p>② 使用主键在主索引上再进行对应的检索操作</p>
<p>这也就是所谓的“<strong>回表查询</strong>”</p>
<p><img src="InnoDB%E7%B4%A2%E5%BC%952.png" alt="InnoDB"></p>
<p><strong>InnoDB 索引结构需要注意的点</strong></p>
<ol>
<li>数据文件本身就是索引文件</li>
<li>表数据文件本身就是按 B+Tree 组织的一个索引结构文件</li>
<li>聚集索引中叶节点包含了完整的数据记录</li>
<li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li>
</ol>
<p>正如我们上面介绍 InnoDB 存储结构，索引与数据是共同存储的，不管是主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</p>
<h5 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h5><p><strong>为什么推荐使用整型自增主键而不是选择UUID？</strong></p>
<ul>
<li>UUID是字符串，比整型消耗更多的存储空间；</li>
<li>在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</li>
<li>自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id &gt; 5 &amp;&amp; id &lt; 20的条件查询语句。</li>
<li>在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易出现这样的情况，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</li>
</ul>
<p><strong>为什么非主键索引结构叶子节点存储的是主键值？</strong></p>
<p>保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户ID作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真实名称、手机号、收货地址···）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间。</p>
<h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p>
<p>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</p>
<p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><ul>
<li><p>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</p>
</li>
<li><p>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</p>
</li>
<li><p>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应Btree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</p>
</li>
</ul>
<h3 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a>R-Tree空间索引</h3><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型</p>
<h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p><strong>为什么Mysql索引要用B+树不是B树？</strong></p>
<p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p>
<p><strong>为何不采用Hash方式？</strong></p>
<p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p>
<p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>
<p><strong>哪些情况需要创建索引</strong></p>
<ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li>
<li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li>
<li>查询中统计或分组字段</li>
</ol>
<p><strong>哪些情况不要创建索引</strong></p>
<ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li>
<li>频繁更新的字段不适合创建索引（会加重IO负担）</li>
<li>where条件里用不到的字段不创建索引</li>
</ol>
<p><strong>MySQL高效索引</strong></p>
<p><strong>覆盖索引</strong>（Covering Index），或者叫索引覆盖， 也就是平时所说的不需要回表操作</p>
<ul>
<li><p>就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</p>
</li>
<li><p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</p>
</li>
<li><p><strong>判断标准</strong></p>
<p>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</p>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。</p>
<ul>
<li><strong>A (Atomicity) 原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li>
<li><strong>C (Consistency) 一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏</li>
<li><strong>I (Isolation)隔离性</strong>：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li>
<li><strong>D (Durability) 持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li>
</ul>
<p>并发事务处理带来的问题</p>
<ul>
<li>更新丢失（Lost Update)： 事务A和事务B选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</li>
<li>脏读(Dirty Reads)：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读（Non-Repeatable Reads)：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>
<li>幻读（Phantom Reads)：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p>幻读和不可重复读的区别：</p>
<ul>
<li><strong>不可重复读的重点是修改</strong>：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li>
<li><strong>幻读的重点在于新增或者删除</strong>：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li>
</ul>
<p>并发事务处理带来的问题的解决办法：</p>
<ul>
<li><p>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p>
</li>
<li><p>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：</p>
<ul>
<li><p>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</p>
</li>
<li><p>另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 <strong>MVCC</strong> 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</p>
</li>
</ul>
</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库事务的隔离级别有4种，由低到高分别为</p>
<ul>
<li><strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<p>查看当前数据库的事务隔离级别：<code>show variables like &#39;tx_isolation&#39;</code></p>
<p>下面通过事例一一阐述在事务的并发操作中可能会出现脏读，不可重复读，幻读和事务隔离级别的联系。</p>
<p>数据库的事务隔离越严格，并发副作用越小，但付出的代价就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p>
<h4 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h4><p>读未提交，就是一个事务可以读取另一个未提交事务的数据。<br>事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。<br>分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。<br>那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p>
<h4 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h4><p>读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</p>
<p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p>
<p>分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是<strong>不可重复读</strong>。</p>
<p>那怎么解决可能的不可重复读问题？Repeatable read ！</p>
<h4 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h4><p>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。 <strong>MySQL的默认事务隔离级别</strong> </p>
<p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p>
<p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，<strong>不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作</strong>。</p>
<p><strong>什么时候会出现幻读？</strong></p>
<p>事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p>
<p>那怎么解决幻读问题？Serializable！</p>
<h4 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h4><p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>最低级被，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读已提交（read-committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong>事务隔离级别下使用的是Next-Key Lock 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(可串行化)</strong>隔离级别，而且保留了比较好的并发性能。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读已提交):</strong>，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p>
<h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h3><p>MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。</p>
<p>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p>
<p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。</p>
<p>典型的MVCC实现方式，分为<strong>乐观（optimistic）并发控制和悲观（pressimistic）并发控制</strong>。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。</p>
<p>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</strong></p>
<ul>
<li><p>SELECT</p>
<p>InnoDB会根据以下两个条件检查每行记录：</p>
<ul>
<li>InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li>
<li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li>
</ul>
<p>只有符合上述两个条件的才会被查询出来</p>
</li>
<li><p>INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p>
</li>
<li><p>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识</p>
</li>
<li><p>UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p>
</li>
</ul>
<p>保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p>
<p>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。</p>
<p>事务的实现就是如何实现ACID特性。</p>
<p>事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。</p>
<p>事务是如何通过日志来实现的？</p>
<p>事务日志包括：<strong>重做日志redo</strong>和<strong>回滚日志undo</strong></p>
<ul>
<li><p><strong>redo log（重做日志</strong>） 实现持久化和原子性</p>
<p>在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</p>
<p>在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。</p>
</li>
<li><p><strong>undo log（回滚日志）</strong>  实现一致性</p>
<p>undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。</p>
<p>Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</p>
</li>
</ul>
<p>二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p>
<h2 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。</p>
<p>打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题？这里肯定要用到事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。</p>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>从对数据操作的类型分类：</p>
<ul>
<li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li>
<li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li>
</ul>
<p>从对数据操作的粒度分类：</p>
<p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。</p>
<ul>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p>
<table>
<thead>
<tr>
<th></th>
<th>行锁</th>
<th>表锁</th>
<th>页锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>BDB</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>InnoDB</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>Memory</td>
<td></td>
<td>√</td>
<td></td>
</tr>
</tbody></table>
<h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h3><p>MyISAM 的表锁有两种模式：</p>
<ul>
<li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li>
<li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li>
</ul>
<p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。</p>
<p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p>
<h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>索引失效会导致行锁变表锁</strong>。比如 vchar 查询不写单引号的情况。</p>
<h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><p><strong>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题</strong></p>
<p>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式</p>
<p>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</strong></p>
<h3 id="锁模式-InnoDB有三种行锁的算法"><a href="#锁模式-InnoDB有三种行锁的算法" class="headerlink" title="锁模式(InnoDB有三种行锁的算法)"></a>锁模式(InnoDB有三种行锁的算法)</h3><h4 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h4><p>单个行记录上的锁。对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；</p>
<p><code>SELECT * FROM table WHERE id = 1 FOR UPDATE;</code></p>
<p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行</p>
<p>在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</p>
<p><code>UPDATE SET age = 50 WHERE id = 1;</code></p>
<h4 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a><strong>间隙锁（Gap Locks）</strong></h4><p>当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”。</p>
<p>InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。</p>
<p>对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</p>
<p>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的<code>Next-Key Locking</code> 算法，请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</strong></p>
<p><code>SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;</code></p>
<p>即所有在<code>（1，10）</code>区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</p>
<p>GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</p>
<h4 id="临键锁（Next-key-Locks）"><a href="#临键锁（Next-key-Locks）" class="headerlink" title="临键锁（Next-key Locks）"></a>临键锁（Next-key Locks）</h4><p><strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。(临键锁的主要目的，也是为了避免<strong>幻读</strong>(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。)</p>
<p>Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。通过<strong>临建锁</strong>可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，<code>InnoDB</code> 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p>
<p>对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p>
<p><strong>select for update有什么含义，会锁表还是锁行还是其他？</strong></p>
<p>for update 仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。</p>
<p>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 假设有个表单 products ，里面有id跟name二个栏位，id是主键。</p>
<ul>
<li>明确指定主键，并且有此笔资料，row lock</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products WHERE id&#x3D;&#39;3&#39; FOR UPDATE;</span><br><span class="line">SELECT * FROM products WHERE id&#x3D;&#39;3&#39; and type&#x3D;1 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<ul>
<li>明确指定主键，若查无此笔资料，无lock</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products WHERE id&#x3D;&#39;-1&#39; FOR UPDATE;</span><br></pre></td></tr></table></figure>

<ul>
<li>无主键，table lock</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products WHERE name&#x3D;&#39;Mouse&#39; FOR UPDATE;</span><br></pre></td></tr></table></figure>

<ul>
<li>主键不明确，table lock</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products WHERE id&lt;&gt;&#39;3&#39; FOR UPDATE;</span><br></pre></td></tr></table></figure>

<ul>
<li>主键不明确，table lock</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products WHERE id LIKE &#39;3&#39; FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p><strong>注1</strong>: FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。</p>
<p><strong>注2</strong>: 要测试锁定的状况，可以利用MySQL的Command Mode ，开二个视窗来做测试。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生</strong>：</p>
<ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环</li>
<li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁</li>
<li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li>
</ul>
<p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p>
<p><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>
<p><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p>
<p><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖<code>innodb_lock_wait_timeout</code>设置进行事务回滚。</p>
<p><strong>MyISAM避免死锁</strong>：</p>
<ul>
<li>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</li>
</ul>
<p><strong>InnoDB避免死锁</strong>：</p>
<ul>
<li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用<code>SELECT ... FOR UPDATE</code>语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li>
<li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li>
<li>通过<code>SELECT ... LOCK IN SHARE MODE</code>获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>改变事务隔离级别</li>
</ul>
<p>如果出现死锁，可以用 <code>show engine innodb status;</code>命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p>
<h2 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h2><h3 id="Explain-执行计划"><a href="#Explain-执行计划" class="headerlink" title="Explain(执行计划)"></a>Explain(执行计划)</h3><p>是什么：使用 <strong>Explain</strong> 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<p>能干吗：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p>怎么玩：</p>
<ul>
<li>Explain + SQL语句</li>
<li>执行计划包含的信息（如果有分区表的话还会有<strong>partitions</strong>）</li>
</ul>
<p><img src="explain.png" alt="explain"></p>
<p>各字段解释</p>
<ul>
<li><p><strong>id</strong>（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）</p>
<ul>
<li>id相同，执行顺序从上往下</li>
<li>id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行</li>
</ul>
</li>
<li><p><strong>select_type</strong>（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）</p>
<ul>
<li><strong>SIMPLE</strong> ：简单的select查询，查询中不包含子查询或UNION</li>
<li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY</li>
<li><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</li>
<li><strong>DERIVED</strong>：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</li>
<li><strong>UNION</strong>：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED</li>
<li><strong>UNION RESULT</strong>：从UNION表获取结果的select</li>
</ul>
</li>
<li><p><strong>table</strong>（显示这一行的数据是关于哪张表的）</p>
</li>
<li><p><strong>type</strong>（显示查询使用了那种类型，从最好到最差依次排列    <strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> ）</p>
<ul>
<li>system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现</li>
<li>const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li>
<li>ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体</li>
<li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</li>
<li>index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（<strong>也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的</strong>）</li>
<li>ALL：Full Table Scan，将遍历全表找到匹配的行</li>
</ul>
<p>tip: 一般来说，得保证查询至少达到range级别，最好到达ref</p>
</li>
<li><p><strong>possible_keys</strong>（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）</p>
</li>
<li><p><strong>key</strong></p>
<ul>
<li>实际使用的索引，如果为NULL，则没有使用索引</li>
<li><strong>查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中</strong></li>
</ul>
</li>
</ul>
<p><img src="key.png" alt="key"></p>
<ul>
<li><p><strong>key_len</strong></p>
<ul>
<li><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</p>
</li>
<li><p>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p>
</li>
</ul>
</li>
<li><p><strong>ref</strong> （显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）</p>
</li>
<li><p><strong>rows</strong> （根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）</p>
</li>
<li><p><strong>Extra</strong>（包含不适合在其他列中显示但十分重要的额外信息）</p>
<ol>
<li>using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中</li>
<li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li>
<li>using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作</li>
<li>using where：使用了where过滤</li>
<li>using join buffer：使用了连接缓存</li>
<li>impossible where：where子句的值总是false，不能用来获取任何元祖</li>
<li>select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li>
<li>distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作</li>
</ol>
</li>
</ul>
<h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p><img src="case.png" alt="case"></p>
<ol>
<li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name……】</li>
<li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name from t1 where other_column=’’】</li>
<li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</li>
<li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</li>
<li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</li>
</ol>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <code>long_query_time</code> 值的 SQL，则会被记录到慢查询日志中。</p>
<ul>
<li><code>long_query_time</code> 的默认值为10，意思是运行10秒以上的语句</li>
<li>默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启</li>
</ul>
<p><strong>查看开启状态</strong></p>
<p><code>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;</code></p>
<p><strong>开启慢查询日志</strong></p>
<ul>
<li>临时配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log&#x3D;&#39;ON&#39;;</span><br><span class="line">mysql&gt; set global slow_query_log_file&#x3D;&#39;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;hostname-slow.log&#39;;</span><br><span class="line">mysql&gt; set global long_query_time&#x3D;2;</span><br></pre></td></tr></table></figure>

<p>也可set文件位置，系统会默认给一个缺省文件host_name-slow.log</p>
<p>使用set操作开启慢查询日志只对当前数据库生效，如果MySQL重启则会失效。</p>
<ul>
<li><p>永久配置</p>
<p>修改配置文件my.cnf或my.ini，在[mysqld]一行下面加入两个配置参数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log &#x3D; ON</span><br><span class="line">slow_query_log_file &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;hostname-slow.log</span><br><span class="line">long_query_time &#x3D; 3</span><br></pre></td></tr></table></figure>

<p>注：log-slow-queries 参数为慢查询日志存放的位置，一般这个目录要有 MySQL 的运行帐号的可写权限，一般都将这个目录设置为 MySQL 的数据存放目录；long_query_time=2 中的 2 表示查询超过两秒才记录；在my.cnf或者 my.ini 中添加 log-queries-not-using-indexes 参数，表示记录下没有使用索引的查询。</p>
<p>可以用 <code>select sleep(4)</code> 验证是否成功开启。</p>
<p>在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具<strong>mysqldumpslow</strong>。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ol>
<li>全值匹配我最爱</li>
<li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li>
<li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li>
<li>is null ,is not null 也无法使用索引</li>
<li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li>
<li>字符串不加单引号索引失效</li>
<li>少用or，用它来连接时会索引失效</li>
<li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li>
</ol>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p><strong>永远小标驱动大表（小的数据集驱动大的数据集）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from A where id in (select id from B);</span><br><span class="line"># 等价于</span><br><span class="line">select id from B;</span><br><span class="line">select * from A where A.id&#x3D;B.id;</span><br></pre></td></tr></table></figure>

<p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from A where exists (select 1 from B where B.id&#x3D;A.id);</span><br><span class="line"># 等价于</span><br><span class="line">select * from A;</span><br><span class="line">select * from B where B.id &#x3D; A.id;</span><br></pre></td></tr></table></figure>

<p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p>
<p>注意：A表与B表的ID字段应建立索引。</p>
<p><strong>order by关键字优化</strong></p>
<ul>
<li><p>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p>
</li>
<li><p>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</p>
</li>
<li><p>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</p>
</li>
<li><p>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</p>
</li>
<li><p>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序</p>
<ul>
<li><p>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</p>
</li>
<li><p>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</p>
</li>
</ul>
</li>
<li><p>优化策略</p>
<ul>
<li><p>增大sort_buffer_size参数的设置</p>
</li>
<li><p>增大max_lencth_for_sort_data参数的设置</p>
</li>
</ul>
</li>
</ul>
<p><strong>GROUP BY关键字优化</strong></p>
<ul>
<li><p>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</p>
</li>
<li><p>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</p>
</li>
<li><p>where高于having，能写在where限定的条件就不要去having限定了</p>
</li>
</ul>
<p><strong>数据类型优化</strong></p>
<p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p>
<ul>
<li><p>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p>
<p>简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</p>
</li>
<li><p>尽量避免NULL：通常情况下最好指定列为NOT NULL</p>
</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><p>分表有两种分割方式，一种垂直拆分，另一种水平拆分。</p>
<ul>
<li><p><strong>垂直拆分</strong></p>
<p>垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p>
</li>
<li><p><strong>水平拆分(数据分片)</strong></p>
<p>单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。</p>
<p>水平分割的几种方法：</p>
<ul>
<li><p>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。</p>
</li>
<li><p>还可根据时间放入不同的表，比如：article_201601，article_201602。</p>
</li>
<li><p>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</p>
</li>
<li><p>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</p>
</li>
</ul>
</li>
</ul>
<p><img src="%E5%88%86%E8%A1%A8.png" alt="分表"></p>
<h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><p><strong>为什么要分库？</strong></p>
<p>数据库集群环境后都是多台 slave，基本满足了读取操作; 但是写入或者说大数据、频繁的写入操作对master性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。</p>
<p><strong>分库是什么？</strong></p>
<p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。</p>
<p>优点：</p>
<ul>
<li>减少增量数据写入时的锁对查询的影响</li>
<li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短</li>
</ul>
<p>但是它无法解决单表数据量太大的问题</p>
<p><strong>分库分表后的难题</strong></p>
<p>分布式事务的问题，数据的完整性和一致性问题。</p>
<p>数据操作维度问题：用户、交易、订单各个不同的维度，用户查询维度、产品数据分析维度的不同对比分析角度。 跨库联合查询的问题，可能需要两次查询 跨节点的count、order by、group by以及聚合函数问题，可能需要分别在各个节点上得到结果后在应用程序端进行合并 额外的数据管理负担，如：访问数据表的导航定位 额外的数据运算压力，如：需要在多个节点执行，然后再合并计算程序编码开发难度提升，没有太好的框架解决，更多依赖业务看如何分，如何合，是个难题。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>slave 会从 master 读取 binlog 来进行数据同步</p>
<p>三个步骤</p>
<ul>
<li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；</li>
<li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li>
<li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li>
</ul>
<p><img src="%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt="复制"></p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="什么是视图，为什么要用视图"><a href="#什么是视图，为什么要用视图" class="headerlink" title="什么是视图，为什么要用视图"></a>什么是视图，为什么要用视图</h3><ul>
<li>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</li>
<li>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>
<li>视图是由基本表(实表)产生的表(虚表)。</li>
<li>视图的建立和删除不影响基本表。</li>
<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>
<li>当视图来自多个基本表时，不允许添加和删除数据。</li>
</ul>
<p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p>
<ul>
<li>重用SQL语句；</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>
<li>使用表的组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>查询简单化。视图能简化用户的操作</li>
<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<p>缺点：</p>
<ol>
<li>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</li>
<li>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。</li>
</ol>
<h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><h3 id="什么是存储过程，优缺点"><a href="#什么是存储过程，优缺点" class="headerlink" title="什么是存储过程，优缺点"></a>什么是存储过程，优缺点</h3><ul>
<li>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</li>
</ul>
<p><strong>优点</strong></p>
<ol>
<li>存储过程是预编译过的，执行效率高。</li>
<li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li>
<li>安全性高，执行存储过程需要有一定权限的用户。</li>
<li>存储过程可以重复使用，减少数据库开发人员的工作量。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</li>
<li>移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</li>
<li>重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</li>
<li>如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</li>
</ol>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><p>由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
<h3 id="关系型和非关系型数据库的区别"><a href="#关系型和非关系型数据库的区别" class="headerlink" title="关系型和非关系型数据库的区别"></a>关系型和非关系型数据库的区别</h3><p>关系型数据库的优点</p>
<ul>
<li>容易理解，因为它采用了关系模型来组织数据。</li>
<li>可以保持数据的一致性。</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带 where 子句的查询）</li>
</ul>
<p>非关系型数据库（NOSQL）的优点</p>
<ul>
<li>无需经过 SQL 层的解析，读写效率高。</li>
<li>基于键值对，读写性能很高，易于扩展</li>
<li>可以支持多种类型数据的存储，如图片，文档等等。</li>
<li>扩展（可分为内存性数据库以及文档型数据库，比如 Redis，MongoDB，HBase 等，适合场景：数据量大高可用的日志系统/地理位置存储系统）。</li>
</ul>
<h3 id="内连接、外连接、交叉连接、笛卡尔积"><a href="#内连接、外连接、交叉连接、笛卡尔积" class="headerlink" title="内连接、外连接、交叉连接、笛卡尔积"></a>内连接、外连接、交叉连接、笛卡尔积</h3><ul>
<li>内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。</li>
<li>外连接（outer join）：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。</li>
<li>交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在 SQL 中的实现，如果 A 表有 m 行，B 表有 n 行，那么 A 和 B 交叉连接的结果就有 m*n 行。</li>
<li>笛卡尔积：是数学中的一个概念，例如集合 A={a,b}，集合 B={0,1,2}，那么 A✖️B=<code>{&lt;a,0&gt;,&lt;a,1&gt;,&lt;a,2&gt;,&lt;b,0&gt;,&lt;b,1&gt;,&lt;b,2&gt;,}</code>。</li>
</ul>
<p><img src="join.jpg" alt="连接"></p>
<p><code>inner join</code> 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集。</p>
<p>只有当两个表中都有匹配的记录时，这些记录才会出现在查询结果中。如果某一方没有匹配的记录，则该记录不会出现在结果集中。</p>
<p>内联可以用来找出两个表中共同的记录，相当于两个数据集的交集。</p>
<p><code>left join</code> 返回左表（FROM 子句中指定的表）的所有记录，以及右表中匹配记录的记录。如果右表中没有匹配的记录，则结果中右表的部分会以 NULL 填充。</p>
<p><code>right join</code> 刚好与左联相反，返回右表（FROM 子句中指定的表）的所有记录，以及左表中匹配记录的记录。如果左表中没有匹配的记录，则结果中左表的部分会以 NULL 填充。</p>
<h3 id="drop、delete、truncate区别"><a href="#drop、delete、truncate区别" class="headerlink" title="drop、delete、truncate区别"></a>drop、delete、truncate区别</h3><table>
<thead>
<tr>
<th>区别</th>
<th>delete</th>
<th>truncate</th>
<th>drop</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>属于 DML</td>
<td>属于 DDL</td>
<td>属于 DDL</td>
</tr>
<tr>
<td>回滚</td>
<td>可回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
</tr>
<tr>
<td>删除内容</td>
<td>表结构还在，删除表的全部或者一部分数据行</td>
<td>表结构还在，删除表中的所有数据</td>
<td>从数据库中删除表，所有数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td>删除速度</td>
<td>删除速度慢，需要逐行删除</td>
<td>删除速度快</td>
<td>删除速度最快</td>
</tr>
</tbody></table>
<p>因此，在不再需要一张表的时候，用 drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用 truncate。</p>
<h3 id="count-1-、count-与-count-列名-的区别"><a href="#count-1-、count-与-count-列名-的区别" class="headerlink" title="count(1)、count(*) 与 count(列名) 的区别"></a>count(1)、count(*) 与 count(列名) 的区别</h3><p><strong>执行效果</strong>：</p>
<ul>
<li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL</li>
<li>count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL</li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0，而是表示 null）的计数，即某个字段值为 NULL 时，不统计。</li>
</ul>
<p><strong>执行速度</strong>：</p>
<ul>
<li>列名为主键，count(列名)会比 count(1)快</li>
<li>列名不为主键，count(1)会比 count(列名)快</li>
<li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）</li>
<li>如果有主键，则 select count（主键）的执行效率是最优的</li>
<li>如果表只有一个字段，则 select count（*）最优。</li>
</ul>
<h3 id="存储引擎应该怎么选择"><a href="#存储引擎应该怎么选择" class="headerlink" title="存储引擎应该怎么选择"></a>存储引擎应该怎么选择</h3><ul>
<li>大多数情况下，使用默认的 InnoDB 就对了，InnoDB 可以提供事务、行级锁等能力。</li>
<li>MyISAM 适合读更多的场景。</li>
<li>MEMORY 适合临时表，数据量不大的情况。由于数据都存放在内存，所以速度非常快。</li>
</ul>
<h3 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h3><p>MySQL 的日志文件主要包括：</p>
<p>①、<strong>错误日志</strong>（Error Log）：记录 MySQL 服务器启动、运行或停止时出现的问题。</p>
<p>②、<strong>慢查询日志</strong>（Slow Query Log）：记录执行时间超过 long_query_time 值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。可以用来识别和优化慢 SQL。</p>
<p>③、<strong>一般查询日志</strong>（General Query Log）：记录所有 MySQL 服务器的连接信息及所有的 SQL 语句，不论这些语句是否修改了数据。</p>
<p>④、<strong>二进制日志</strong>（Binary Log）：记录了所有修改数据库状态的 SQL 语句，以及每个语句的执行时间，如 INSERT、UPDATE、DELETE 等，但不包括 SELECT 和 SHOW 这类的操作。</p>
<p>以及两个 InnoDB 存储引擎特有的日志文件：</p>
<p>⑤、<strong>重做日志</strong>（Redo Log）：记录了对于 InnoDB 表的每个写操作，不是 SQL 级别的，而是物理级别的，主要用于崩溃恢复。</p>
<p>⑥、<strong>回滚日志</strong>（Undo Log，或者叫事务日志）：记录数据被修改前的值，用于事务的回滚。</p>
<p>支持事务回滚，可以用来实现 MVCC，即多版本并发控制。</p>
<p>binlog 主要用于复制（Replication）和数据恢复（Data Recovery）。</p>
<ul>
<li>支持主从复制，主服务器（master）上的二进制日志可以被从服务器（slave）读取和恢复。</li>
<li>在发生数据丢失或损坏时，binlog 可以用来恢复数据。结合全量备份和 binlog 的增量备份，可以将数据库恢复到特定的时间点（Point-In-Time Recovery）</li>
</ul>
<p>binlog 包括两类文件：</p>
<ul>
<li>二进制索引文件（.index）</li>
<li>二进制日志文件（.00000*）</li>
</ul>
<p>binlog 默认是没有启用的。要启用它，需要在 MySQL 的配置文件（my.cnf 或 my.ini）中设置 log_bin 参数，并指定 binlog 文件的存储位置。</p>
<h3 id="binlog-和-redo-log-有什么区别"><a href="#binlog-和-redo-log-有什么区别" class="headerlink" title="binlog 和 redo log 有什么区别"></a>binlog 和 redo log 有什么区别</h3><ul>
<li>bin log 会记录所有与数据库有关的日志记录，包括 InnoDB、MyISAM 等存储引擎的日志，而 redo log 只记 InnoDB 存储引擎的日志。</li>
<li>记录的内容不同，bin log 记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而 redo log 记录的是关于每个页（Page）的更改的物理情况。</li>
<li>写入的时间不同，bin log 仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有 redo ertry 被写入 redo log 中。</li>
<li>写入的方式也不相同，redo log 是循环写入和擦除，bin log 是追加写入，不会覆盖已经写的文件。</li>
</ul>
<h3 id="更新语句怎么执行"><a href="#更新语句怎么执行" class="headerlink" title="更新语句怎么执行"></a>更新语句怎么执行</h3><p>更新语句的执行是 Server 层和引擎层配合完成，数据除了要写入表中，还要记录相应的日志。</p>
<p><img src="update.jpg" alt="update"></p>
<ol>
<li>执行器先找引擎获取 ID=2 这一行。ID 是主键，存储引擎检索数据，找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ol>
<p>从上图可以看出，MySQL 在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对 binlog 进行写入，在 InnoDB 内进行 redo log 的写入。</p>
<p>不仅如此，在对 redo log 写入时有两个阶段的提交，一是 binlog 写入之前<code>prepare</code>状态的写入，二是 binlog 写入之后<code>commit</code>状态的写入。</p>
<p>为什么要两阶段提交呢？</p>
<p>为什么要两阶段提交呢？直接提交不行吗？</p>
<p>我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入 redo log，后写入 binlog；要么先写入 binlog，后写入 redo log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。</p>
<p><strong>先写入 redo log，后写入 binlog：</strong></p>
<p>在写完 redo log 之后，数据此时具有<code>crash-safe</code>能力，因此系统崩溃，数据会恢复成事务开始之前的状态。但是，若在 redo log 写完时候，binlog 写入之前，系统发生了宕机。此时 binlog 没有对上面的更新语句进行保存，导致当使用 binlog 进行数据库的备份或者恢复时，就少了上述的更新语句。从而使得<code>id=2</code>这一行的数据没有被更新。</p>
<p><img src="redobinlog.jpg" alt="redobinlog"></p>
<p><strong>先写入 binlog，后写入 redo log：</strong></p>
<p>写完 binlog 之后，所有的语句都被保存，所以通过 binlog 复制或恢复出来的数据库中 id=2 这一行的数据会被更新为 a=1。但是如果在 redo log 写入之前，系统崩溃，那么 redo log 中记录的这个事务会无效，导致实际数据库中<code>id=2</code>这一行的数据并没有更新。</p>
<p><img src="binredolog.jpg" alt="binredolog"></p>
<p>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<p>redo log 的写入不是直接落到磁盘，而是在内存中设置了一片称之为<code>redo log buffer</code>的连续内存空间，也就是<code>redo 日志缓冲区</code>。</p>
<p><img src="redobuffer.jpg" alt="redobuffer"></p>
<p>在如下的一些情况中，log buffer 的数据会刷入磁盘：</p>
<ul>
<li>log buffer 空间不足时</li>
</ul>
<p>log buffer 的大小是有限的，如果不停的往这个有限大小的 log buffer 里塞入日志，很快它就会被填满。如果当前写入 log buffer 的 redo 日志量已经占满了 log buffer 总容量的大约<strong>一半</strong>左右，就需要把这些日志刷新到磁盘上。</p>
<ul>
<li>事务提交时</li>
</ul>
<p>在事务提交时，为了保证持久性，会把 log buffer 中的日志全部刷到磁盘。注意，这时候，除了本事务的，可能还会刷入其它事务的日志。</p>
<ul>
<li>后台线程输入</li>
</ul>
<p>有一个后台线程，大约每秒都会刷新一次<code>log buffer</code>中的<code>redo log</code>到磁盘。</p>
<ul>
<li>正常关闭服务器时</li>
<li><strong>触发 checkpoint 规则</strong></li>
</ul>
<p>重做日志缓存、重做日志文件都是以<strong>块（block）的方式进行保存的，称之为重做日志块（redo log block）</strong>,块的大小是固定的 512 字节。我们的 redo log 它是固定大小的，可以看作是一个逻辑上的 <strong>log group</strong>，由一定数量的<strong>log block</strong> 组成。</p>
<h3 id="优化慢查询"><a href="#优化慢查询" class="headerlink" title="优化慢查询"></a>优化慢查询</h3><p><img src="sql%E4%BC%98%E5%8C%96.png" alt="sql优化"></p>
<h4 id="如何避免不必要的列？"><a href="#如何避免不必要的列？" class="headerlink" title="如何避免不必要的列？"></a>如何避免不必要的列？</h4><p>比如说尽量避免使用 <code>select *</code>，只查询需要的列，减少数据传输量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees WHERE department_id &#x3D; 5;</span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, first_name, last_name FROM employees WHERE department_id &#x3D; 5;</span><br></pre></td></tr></table></figure>

<h4 id="如何进行分页优化？"><a href="#如何进行分页优化？" class="headerlink" title="如何进行分页优化？"></a>如何进行分页优化？</h4><p>当数据量巨大时，传统的<code>LIMIT</code>和<code>OFFSET</code>可能会导致性能问题，因为数据库需要扫描<code>OFFSET + LIMIT</code>数量的行。</p>
<p>延迟关联（Late Row Lookups）和书签（Seek Method）是两种优化分页查询的有效方法。</p>
<p><strong>①、延迟关联</strong></p>
<p>延迟关联适用于需要从多个表中获取数据且主表行数较多的情况。它首先从索引表中检索出需要的行 ID，然后再根据这些 ID 去关联其他的表获取详细信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT e.id, e.name, d.details</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN department d ON e.department_id &#x3D; d.id</span><br><span class="line">ORDER BY e.id</span><br><span class="line">LIMIT 1000, 20;</span><br></pre></td></tr></table></figure>

<p>延迟关联后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT e.id, e.name, d.details</span><br><span class="line">FROM (</span><br><span class="line">    SELECT id</span><br><span class="line">    FROM employees</span><br><span class="line">    ORDER BY id</span><br><span class="line">    LIMIT 1000, 20</span><br><span class="line">) AS sub</span><br><span class="line">JOIN employees e ON sub.id &#x3D; e.id</span><br><span class="line">JOIN department d ON e.department_id &#x3D; d.id;</span><br></pre></td></tr></table></figure>

<p>首先对<code>employees</code>表进行分页查询，仅获取需要的行的 ID，然后再根据这些 ID 关联获取其他信息，减少了不必要的 JOIN 操作。</p>
<p><strong>②、书签（Seek Method）</strong></p>
<p>书签方法通过记住上一次查询返回的最后一行的某个值，然后下一次查询从这个值开始，避免了扫描大量不需要的行。</p>
<p>假设需要对用户表进行分页，根据用户 ID 升序排列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id, name</span><br><span class="line">FROM users</span><br><span class="line">ORDER BY id</span><br><span class="line">LIMIT 1000, 20;</span><br></pre></td></tr></table></figure>

<p>书签方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id, name</span><br><span class="line">FROM users</span><br><span class="line">WHERE id &gt; last_max_id  -- 假设last_max_id是上一页最后一行的ID</span><br><span class="line">ORDER BY id</span><br><span class="line">LIMIT 20;</span><br></pre></td></tr></table></figure>

<p>优化后的查询不再使用<code>OFFSET</code>，而是直接从上一页最后一个用户的 ID 开始查询。这里的<code>last_max_id</code>是上一次查询返回的最后一行的用户 ID。这种方法有效避免了不必要的数据扫描，提高了分页查询的效率。</p>
<h4 id="如何进行索引优化？"><a href="#如何进行索引优化？" class="headerlink" title="如何进行索引优化？"></a>如何进行索引优化？</h4><p>正确地使用索引可以显著减少 SQL 的查询时间，通常可以从索引覆盖、避免使用 <code>!=</code> 或者 <code>&lt;&gt;</code> 操作符、适当使用前缀索引、避免列上函数运算、正确使用联合索引等方面进行优化。</p>
<p><strong>①、利用覆盖索引</strong></p>
<p>使用非主键索引查询数据时需要回表，但如果索引的叶节点中已经包含要查询的字段，那就不会再回表查询了，这就叫覆盖索引。</p>
<p>举个例子，现在要从 test 表中查询 city 为上海的 name 字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from test where city&#x3D;&#39;上海&#39;;</span><br></pre></td></tr></table></figure>

<p>如果仅在 city 字段上添加索引，那么这条查询语句会先通过索引找到 city 为上海的行，然后再回表查询 name 字段，这就是回表查询。</p>
<p>为了避免回表查询，可以在 city 和 name 字段上建立联合索引，这样查询结果就可以直接从索引中获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table test add index index1(city,name);</span><br></pre></td></tr></table></figure>

<p><strong>②、避免使用 != 或者 &lt;&gt; 操作符</strong></p>
<p><code>!=</code> 或者 <code>&lt;&gt;</code> 操作符会导致 MySQL 无法使用索引，从而导致全表扫描。</p>
<p>例如，可以把<code>column&lt;&gt;&#39;aaa&#39;</code>，改成<code>column&gt;&#39;aaa&#39; or column&lt;&#39;aaa&#39;</code>，就可以使用索引了。</p>
<p>优化策略就是尽可能使用 <code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>等操作符，它们能够更好地利用索引。</p>
<p><strong>③、适当使用前缀索引</strong></p>
<p>适当使用前缀索引可以降低索引的空间占用，提高索引的查询效率。</p>
<p>比如，邮箱的后缀一般都是固定的<code>@xxx.com</code>，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table test add index index2(email(6));</span><br></pre></td></tr></table></figure>

<p>需要注意的是，MySQL 无法利用前缀索引做 order by 和 group by 操作。</p>
<p><strong>④、避免列上使用函数</strong></p>
<p>在 where 子句中直接对列使用函数会导致索引失效，因为数据库需要对每行的列应用函数后再进行比较，无法直接利用索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from test where date_format(create_time,&#39;%Y-%m-%d&#39;)&#x3D;&#39;2021-01-01&#39;;</span><br></pre></td></tr></table></figure>

<p>可以改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from test where create_time&gt;&#x3D;&#39;2021-01-01 00:00:00&#39; and create_time&lt;&#39;2021-01-02 00:00:00&#39;;</span><br></pre></td></tr></table></figure>

<p>通过日期的范围查询，而不是在列上使用函数，可以利用 create_time 上的索引。</p>
<p><strong>⑤、正确使用联合索引</strong></p>
<p>正确地使用联合索引可以极大地提高查询性能，联合索引的创建应遵循最左前缀原则，即索引的顺序应根据列在查询中的使用频率和重要性来安排。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from messages where sender_id&#x3D;1 and receiver_id&#x3D;2 and is_read&#x3D;0;</span><br></pre></td></tr></table></figure>

<p>那就可以为 sender_id、receiver_id 和 is_read 这三个字段创建联合索引，但是要注意索引的顺序，应该按照查询中的字段顺序来创建索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table messages add index index3(sender_id,receiver_id,is_read);</span><br></pre></td></tr></table></figure>

<h4 id="如何进行-JOIN-优化？"><a href="#如何进行-JOIN-优化？" class="headerlink" title="如何进行 JOIN 优化？"></a>如何进行 JOIN 优化？</h4><p>对于 JOIN 操作，可以通过优化子查询、小表驱动大表、适当增加冗余字段、避免 join 太多表等方式来进行优化。</p>
<p><strong>①、优化子查询</strong></p>
<p>子查询，特别是在 select 列表和 where 子句中的子查询，往往会导致性能问题，因为它们可能会为每一行外层查询执行一次子查询。</p>
<p>使用子查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B);</span><br></pre></td></tr></table></figure>

<p>使用 JOIN 代替子查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A.name <span class="keyword">from</span> A <span class="keyword">join</span> B <span class="keyword">on</span> A.id=B.id;</span><br></pre></td></tr></table></figure>

<p><strong>②、小表驱动大表</strong></p>
<p>在执行 JOIN 操作时，应尽量让行数较少的表（小表）驱动行数较多的表（大表），这样可以减少查询过程中需要处理的数据量。</p>
<p>比如 left join，左表是驱动表，所以 A 表应小于 B 表，这样建立连接的次数就少，查询速度就快了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B;</span><br></pre></td></tr></table></figure>

<p><strong>③、适当增加冗余字段</strong></p>
<p>在某些情况下，通过在表中适当增加冗余字段来避免 JOIN 操作，可以提高查询效率，尤其是在高频查询的场景下。</p>
<p>比如，我们有一个订单表和一个商品表，查询订单时需要显示商品名称，如果每次都通过 JOIN 操作查询商品表，会降低查询效率。这时可以在订单表中增加一个冗余字段，存储商品名称，这样就可以避免 JOIN 操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> order_id,product_name <span class="keyword">from</span> orders;</span><br></pre></td></tr></table></figure>

<p><strong>④、避免使用 JOIN 关联太多的表</strong></p>
<p>不要使用 join 关联太多的表，最多不要超过 3 张表。</p>
<p>因为 join 太多表会降低查询的速度，返回的数据量也会变得非常大，不利于后续的处理。</p>
<p>如果业务逻辑允许，可以考虑将复杂的 JOIN 查询分解成多个简单查询，然后在应用层组合这些查询的结果。</p>
<h4 id="如何进行排序优化？"><a href="#如何进行排序优化？" class="headerlink" title="如何进行排序优化？"></a>如何进行排序优化？</h4><p>MySQL 生成有序结果的方式有两种：一种是对结果集进行排序操作，另外一种是按照索引顺序扫描得出的自然有序结果。</p>
<p>因此在设计索引的时候要充分考虑到排序的需求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id, name from users order by name;</span><br></pre></td></tr></table></figure>

<p>如果 name 字段上有索引，那么 MySQL 可以直接利用索引的有序性，避免排序操作。</p>
<h3 id="简单说一下索引的分类"><a href="#简单说一下索引的分类" class="headerlink" title="简单说一下索引的分类"></a>简单说一下索引的分类</h3><p><img src="%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.png" alt="索引分类"></p>
<h4 id="说说从功能上的分类"><a href="#说说从功能上的分类" class="headerlink" title="说说从功能上的分类"></a>说说从功能上的分类</h4><p>①、<strong>主键索引</strong>: 表中每行数据唯一标识的索引，强调列值的唯一性和非空性。</p>
<p>当创建表的时候，可以直接指定主键索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    username VARCHAR(255) NOT NULL,</span><br><span class="line">    email VARCHAR(255)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>id 列被指定为主键索引，同时，MySQL 会自动为这个列创建一个聚簇索引（主键索引一定是聚簇索引）。</p>
<p>②、<strong>唯一索引</strong>: 保证数据列中每行数据的唯一性，但允许有空值。</p>
<p>③、<strong>普通索引</strong>: 基本的索引类型，用于加速查询。</p>
<p>④、<strong>全文索引</strong>：特定于文本数据的索引，用于提高文本搜索的效率。</p>
<h4 id="说说从数据结构上分类"><a href="#说说从数据结构上分类" class="headerlink" title="说说从数据结构上分类"></a>说说从数据结构上分类</h4><p>①、B+树索引：最常见的索引类型，一种将索引值按照一定的算法，存入一个树形的数据结构中（二叉树），每次查询都从树的根节点开始，一次遍历叶子节点，找到对应的值。查询效率是 O(logN)。</p>
<p>也是 <strong>InnoDB 存储引擎的默认索引类型</strong>。</p>
<p>B+ 树是 B 树的升级版，B+ 树中的非叶子节点都不存储数据，只存储索引。叶子节点中存储了所有的数据，并且构成了一个从小到大的有序双向链表，使得在完成一次树的遍历定位到范围查询的起点后，可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。这在处理大范围的查询时特别高效。</p>
<p><img src="B+.png" alt="B+"></p>
<p>因为 B+ 树是 InnoDB 的默认索引类型，所以创建 B+ 树的时候不需要指定索引类型。</p>
<p>②、Hash 索引：基于哈希表的索引，查询效率可以达到 O(1)，但是只适合 = 和 in 查询，不适合范围查询。</p>
<p>Hash 索引在原理上和 Java 中的 HashMap 类似，当发生哈希冲突的时候也是通过拉链法来解决。</p>
<p><img src="Hash.png" alt="Hash"></p>
<p>可以通过下面的语句创建哈希索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE example_hash (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(255),</span><br><span class="line">    UNIQUE HASH (name)</span><br><span class="line">) ENGINE&#x3D;MEMORY;</span><br></pre></td></tr></table></figure>

<h4 id="说说从存储位置上分类"><a href="#说说从存储位置上分类" class="headerlink" title="说说从存储位置上分类"></a>说说从存储位置上分类</h4><p>①、聚簇索引：聚簇索引的叶子节点保存了一行记录的所有列信息。也就是说，聚簇索引的叶子节点中，包含了一个完整的记录行。</p>
<p><img src="%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="聚簇索引"></p>
<p>②、非聚簇索引：它的叶子节点只包含一个主键值，通过非聚簇索引查找记录要先找到主键，然后通过主键再到聚簇索引中找到对应的记录行，这个过程被称为回表。</p>
<p><img src="%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="非聚簇索引"></p>
<p>InnoDB 存储引擎的主键使用的是聚簇索引，MyISAM 存储引擎不管是主键索引，还是二级索引使用的都是非聚簇索引。</p>
<h3 id="为什么使用索引会加快查询"><a href="#为什么使用索引会加快查询" class="headerlink" title="为什么使用索引会加快查询"></a>为什么使用索引会加快查询</h3><p>数据库文件是存储在磁盘上的，磁盘 I/O 是数据库操作中最耗时的部分之一。没有索引时，数据库会进行全表扫描（Sequential Scan），这意味着它必须读取表中的每一行数据来查找匹配的行（时间效率为 O(n)）。当表的数据量非常大时，就会导致大量的磁盘 I/O 操作。</p>
<p>有了索引，就可以直接跳到索引指示的数据位置，而不必扫描整张表，从而大大减少了磁盘 I/O 操作的次数。</p>
<p>MySQL 的 InnoDB 存储引擎默认使用 B+ 树来作为索引的数据结构，而 B+ 树的查询效率非常高，时间复杂度为 O(logN)。</p>
<p>索引文件相较于数据库文件，体积小得多，查到索引之后再映射到数据库记录，查询效率就会高很多。</p>
<p>就好像我们通过书的目录，去查找对应的章节内容一样。</p>
<h3 id="索引哪些情况下会失效"><a href="#索引哪些情况下会失效" class="headerlink" title="索引哪些情况下会失效"></a>索引哪些情况下会失效</h3><ul>
<li><strong>在索引列上使用函数或表达式</strong>：如果在查询中对索引列使用了函数或表达式，那么索引可能无法使用，因为数据库无法预先计算出函数或表达式的结果。例如：<code>SELECT * FROM table WHERE YEAR(date_column) = 2021</code>。</li>
<li>使用不等于（<code>&lt;&gt;</code>）或者 NOT 操作符：这些操作符通常会使索引失效，因为它们会扫描全表。</li>
<li><strong>使用 LIKE 操作符，但是通配符在最前面</strong>：如果 LIKE 的模式串是以“%”或者“_”开头的，那么索引也无法使用。例如：<code>SELECT * FROM table WHERE column LIKE &#39;%abc&#39;</code>。</li>
<li><strong>OR 操作符</strong>：如果查询条件中使用了 OR，并且 OR 两边的条件分别涉及不同的索引，那么这些索引可能都无法使用。</li>
<li>如果 MySQL 估计使用全表扫描比使用索引更快时（通常是小表或者大部分行都满足 WHERE 子句），也不会使用索引。</li>
<li>联合索引不满足最左前缀原则时，索引会失效。</li>
</ul>
<h3 id="索引不适合哪些场景呢"><a href="#索引不适合哪些场景呢" class="headerlink" title="索引不适合哪些场景呢"></a>索引不适合哪些场景呢</h3><ul>
<li><p><strong>数据表较小</strong>：当表中的数据量很小，或者查询需要扫描表中大部分数据时，数据库优化器可能会选择全表扫描而不是使用索引。在这种情况下，维护索引的开销可能大于其带来的性能提升。</p>
</li>
<li><p><strong>频繁更新的列</strong>：对于经常进行更新、删除或插入操作的列，使用索引可能会导致性能下降。因为每次数据变更时，索引也需要更新，这会增加额外的写操作负担。</p>
</li>
<li><p><strong>索引会占据磁盘空间</strong></p>
</li>
<li><p><strong>索引虽然会提高查询效率，但是会降低更新表的效率</strong>。比如每次对表进行增删改操作，MySQL 不仅要保存数据，还有保存或者更新对应的索引文件。</p>
</li>
</ul>
<h3 id="为什么-InnoDB-要使用-B-树作为索引"><a href="#为什么-InnoDB-要使用-B-树作为索引" class="headerlink" title="为什么 InnoDB 要使用 B+树作为索引"></a>为什么 InnoDB 要使用 B+树作为索引</h3><p>MySQL 的默认存储引擎是 InnoDB，它采用的是 B+树索引。</p>
<p>那在说 B+树之前，必须得先说一下 B 树（B-tree）。</p>
<p>B 树是一种自平衡的多路查找树，和红黑树、二叉平衡树不同，B 树的每个节点可以有 m 个子节点，而红黑树和二叉平衡树都只有 2 个。</p>
<p>换句话说，红黑树、二叉平衡树是细高个，而 B 树是矮胖子。</p>
<p><img src="BTree.png" alt="BTree"></p>
<p>内存和磁盘在进行 IO 读写的时候，有一个最小的逻辑单元，叫做页（Page），页的大小一般是 4KB。</p>
<p><img src="IO.png" alt="IO"></p>
<p>那为了提高读写效率，从磁盘往内存中读数据的时候，一次会读取至少一页的数据，比如说读取 2KB 的数据，实际上会读取 4KB 的数据；读取 5KB 的数据，实际上会读取 8KB 的数据。<strong>我们要尽量减少读写的次数</strong>。</p>
<p>因为读的次数越多，效率就越低。就好比我们在工地上搬砖，一次搬 10 块砖肯定比一次搬 1 块砖的效率要高，反正我每次都搬 10 块（😁）。</p>
<p>对于红黑树、二叉平衡树这种细高个来说，每次搬的砖少，因为力气不够嘛，那来回跑的次数就越多。</p>
<p>是这个道理吧，树越高，意味着查找数据时就需要更多的磁盘 IO，因为每一层都可能需要从磁盘加载新的节点。</p>
<p><img src="binaryTree.png" alt="binaryTree"></p>
<p>B 树的节点大小通常与页的大小对齐，这样每次从磁盘加载一个节点时，可以正好是一个页的大小。因为 B 树的节点可以有多个子节点，可以填充更多的信息以达到一页的大小。</p>
<p><img src="BTree2.png" alt="BTree"></p>
<p>B 树的一个节点通常包括三个部分：</p>
<ul>
<li>键值：即表中的主键</li>
<li>指针：存储子节点的信息</li>
<li>数据：表记录中除主键外的数据</li>
</ul>
<p>不过，正所谓“祸兮福所倚，福兮祸所伏”，正是因为 B 树的每个节点上都存了数据，就导致每个节点能存储的键值和指针变少了，因为每一页的大小是固定的，对吧？</p>
<p>于是 B+树就来了，B+树的非叶子节点只存储键值，不存储数据，而叶子节点存储了所有的数据，并且构成了一个有序链表。</p>
<p><img src="B+Tree2.png" alt="B+Tree"></p>
<p>这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，树就变得更加矮胖了，于是就更有劲了，每次搬的砖也就更多了（😂）。</p>
<p>由此一来，查找数据进行的磁盘 IO 就更少了，查询的效率也就更高了。</p>
<p>再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。</p>
<p>总结一下，InnoDB 之所以选择 B+树是因为：</p>
<ul>
<li>更高效的磁盘 IO，因为它减少了磁盘寻道时间和页的加载次数。</li>
<li>支持范围查询，与 B 树相比，B+树的叶子节点通过指针连接成一个链表，这使得范围查询变得非常高效。在 B+树上执行范围查询可以简单地从范围的起始点开始，然后沿着链表向后遍历，直到结束点。</li>
<li>查询性能稳定，B+树的所有查找操作都要查到叶子节点，这使得所有的查询操作都有着相同的访问深度，因此查询性能非常稳定。不像某些其他数据结构，如 B 树，其查询性能因为数据存在所有的节点上导致深度不一致，性能不稳定。</li>
</ul>
<p><strong>注</strong>：在 InnoDB 存储引擎中，默认的页大小是 16KB。可以通过 <code>show variables like &#39;innodb_page_size&#39;;</code> 查看。</p>
<p>总结一下：</p>
<p>MySQL 的默认存储引擎是 InnoDB，它采用的是 B+树索引，B+树是一种自平衡的多路查找树，和红黑树、二叉平衡树不同，B+树的每个节点可以有 m 个子节点，而红黑树和二叉平衡树都只有 2 个。</p>
<p>和 B 树不同，B+树的非叶子节点只存储键值，不存储数据，而叶子节点存储了所有的数据，并且构成了一个有序链表。</p>
<p>这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。查询的效率会更高。</p>
<h3 id="一棵-B-树能存储多少条数据"><a href="#一棵-B-树能存储多少条数据" class="headerlink" title="一棵 B+树能存储多少条数据"></a>一棵 B+树能存储多少条数据</h3><p><img src="B+Tree3.jpg" alt="B+Tree"></p>
<p>假如我们的主键 ID 是 bigint 类型，长度为 8 个字节。指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。所以非叶子节点(一页)可以存储 16384/14=1170 个这样的单元(键值+指针)。</p>
<p>一个指针指向一个存放记录的页，一页可以放 16 条数据，树深度为 2 的时候，可以存放 1170<em>16=*</em>18720** 条数据。</p>
<p>同理，树深度为 3 的时候，可以存储的数据为 1170<em>1170</em>16=<strong>21902400</strong>条记录。</p>
<p>理论上，在 InnoDB 存储引擎中，B+树的高度一般为 2-4 层，就可以满足千万级数据的存储。查找数据的时候，一次页的查找代表一次 IO，当我们通过主键索引查询的时候，最多只需要 2-4 次 IO 就可以了。</p>
<h3 id="innodb-使用数据页存储数据？默认数据页大小-16K，我现在有一张表，有-2kw-数据，我这个-b-树的高度有几层？"><a href="#innodb-使用数据页存储数据？默认数据页大小-16K，我现在有一张表，有-2kw-数据，我这个-b-树的高度有几层？" class="headerlink" title="innodb 使用数据页存储数据？默认数据页大小 16K，我现在有一张表，有 2kw 数据，我这个 b+树的高度有几层？"></a>innodb 使用数据页存储数据？默认数据页大小 16K，我现在有一张表，有 2kw 数据，我这个 b+树的高度有几层？</h3><p>在 MySQL 中，InnoDB 存储引擎的最小存储单元是页，默认大小是 16k，可通过参数设置。页可以用来存储 B+树叶子节点上的数据，也可以存放非叶子节点上的键值对。</p>
<p>在查找数据时，一次页的查找代表一次 IO，一般 B+树的高度为 2-4 层，所以通过主键索引查询时，最多只需要 2-4 次 IO 就可以了。</p>
<p>已知非叶子节点可以存储 1170 个键值对。</p>
<blockquote>
<p>主键 ID 是 bigint 类型，长度为 8 个字节。指针大小在 InnoDB 源码中设置为 6 字节，这样一共是 14 字节。所以非叶子节点（一页）可以存储 16384/14=1170 个这样的单元(键值+指针)。</p>
</blockquote>
<p>假设一行数据的大小为 1KB，那么一页的叶子节点就可以存储 16 条数据。对于 3 层的 B+树，第一层叶子节点数<em>第二层叶子节点数</em>一页能够存储的数据量 = 1170<em>1170</em>16 = 21902400 条数据。</p>
<p><img src="B+Tree4.png" alt="B+Tree"></p>
<p>如果有 2KW 条数据，那么这颗 B+树的高度为 3 层。</p>
<h3 id="为什么用-B-树而不用-B-树"><a href="#为什么用-B-树而不用-B-树" class="headerlink" title="为什么用 B+ 树而不用 B 树"></a>为什么用 B+ 树而不用 B 树</h3><p>B+ 树相比较 B 树，有这些优势：</p>
<p>①、更高的查询效率</p>
<p>B+树的所有值（数据记录或指向数据记录的指针）都存在于叶子节点，并且叶子节点之间通过指针连接，形成一个有序链表。</p>
<p><img src="B+Tree5.png" alt="B+Tree"></p>
<p>这种结构使得 B+树非常适合进行范围查询——一旦到达了范围的开始位置，接下来的元素可以通过遍历叶子节点的链表顺序访问，而不需要回到树的上层。如 SQL 中的 ORDER BY 和 BETWEEN 查询。</p>
<p><img src="BTree3.png" alt="BTree"></p>
<p>而 B 树的数据分布在整个树中，进行范围查询时可能需要遍历树的多个层级。</p>
<p>②、更高的空间利用率</p>
<p>在 B+树中，非叶子节点不存储数据，只存储键值，这意味着非叶子节点可以拥有更多的键，从而有更多的分叉。</p>
<p>这导致树的高度更低，进一步降低了查询时磁盘 I/O 的次数，因为每一次从一个节点到另一个节点的跳转都可能涉及到磁盘 I/O 操作。</p>
<p>③、查询效率更稳定</p>
<p>B+树中所有叶子节点深度相同，所有数据查询路径长度相等，保证了每次搜索的性能稳定性。而在 B 树中，数据可以存储在内部节点，不同的查询可能需要不同深度的搜索。</p>
<h3 id="Hash-索引和-B-树索引区别是什么"><a href="#Hash-索引和-B-树索引区别是什么" class="headerlink" title="Hash 索引和 B+ 树索引区别是什么"></a>Hash 索引和 B+ 树索引区别是什么</h3><ul>
<li>B+ 树索引可以进行范围查询，Hash 索引不能。</li>
<li>B+ 树索引支持联合索引的最左侧原则，Hash 索引不支持。</li>
<li>B+ 树索引支持 order by 排序，Hash 索引不支持。</li>
<li>Hash 索引在等值查询上比 B+ 树索引效率更高。</li>
<li>B+ 树使用 like 进行模糊查询的时候，<code>LIKE &#39;abc%&#39;</code> 的话可以起到索引优化的作用，Hash 索引无法进行模糊查询。</li>
</ul>
<h3 id="聚簇索引与非聚簇索引的区别"><a href="#聚簇索引与非聚簇索引的区别" class="headerlink" title="聚簇索引与非聚簇索引的区别"></a>聚簇索引与非聚簇索引的区别</h3><p>聚簇索引不是一种新的索引，而是一种<strong>数据存储方式</strong>。</p>
<p><img src="index.jpg" alt="index"></p>
<p>在聚簇索引中，表中的行是按照键值（索引）的顺序存储的。这意味着表中的实际数据行和键值之间存在物理排序的关系。因此，每个表只能有一个聚簇索引。例如，在 MySQL 的 InnoDB 存储引擎中，主键就是聚簇索引。</p>
<p>在非聚簇索引中，索引和数据是分开存储的，索引中的键值指向数据的实际存储位置。因此，非聚簇索引也被称为二级索引或辅助索引。表可以有多个非聚簇索引。</p>
<p>这意味着，当使用非聚簇索引检索数据时，数据库首先在索引中查找，然后通过索引中的指针去访问表中实际的数据行，这个过程称为“回表”（Bookmark Lookup）。</p>
<p>举例来说：</p>
<ul>
<li>InnoDB 采用的是聚簇索引，如果没有显式定义主键，InnoDB 会选择一个唯一的非空列作为隐式的聚簇索引；如果这样的列也不存在，InnoDB 会自动生成一个隐藏的行 ID 作为聚簇索引。这意味着数据与主键是紧密绑定的，行数据直接存储在索引的叶子节点上。</li>
<li>MyISAM 采用的是非聚簇索引，表数据存储在一个地方，而索引存储在另一个地方，索引指向数据行的物理位置。</li>
</ul>
<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>当使用非聚簇索引查找数据时，数据库会进行两步操作：</p>
<ul>
<li>查找索引：数据库首先会查找非聚簇索引，找到索引键值对应的索引项。这个索引项包含了数据行在磁盘上的位置信息。</li>
<li>读取数据：然后，数据库会根据位置信息，去磁盘上读取相应的数据行。</li>
</ul>
<p>这个过程也被称为“回表”，因为数据库需要先查找索引，然后再根据索引回到数据表中去查找实际的数据。</p>
<p>因此，使用非聚簇索引查找数据通常比使用聚簇索引要慢，因为需要进行两次磁盘访问。当然，如果索引所在的数据页已经被加载到内存中，那么非聚簇索引的查找速度也可以非常快。</p>
<p>例如：<code>select * from user where name = &#39;张三&#39;;</code>，会先从辅助索引中找到 name=’张三’ 的主键 ID，然后再根据主键 ID 从主键索引中找到对应的数据行。</p>
<p><img src="%E5%9B%9E%E8%A1%A8.jpg" alt="回表"></p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>在辅助索引里面，不管是单列索引还是联合索引，如果 select 的数据列只用辅助索引中就能够取得，不用去查主键索引，这时候使用的索引就叫做覆盖索引，避免了回表。</p>
<p>比如，<code>select name from user where name = ‘张三’;</code></p>
<p><img src="%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96.jpg" alt="索引覆盖"></p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>最左前缀原则，也叫最左匹配原则，或者最左前缀匹配原则。</p>
<p>最左匹配原则是指在使用联合索引（即包含多列的索引）时，查询条件从索引的最左列开始并且不跳过中间的列。</p>
<p>如果一个复合索引包含<code>(col1, col2, col3)</code>，那么它可以支持 <code>col1</code>、<code>col1,col2</code> 和 <code>col1, col2, col3</code> 的查询优化，但不会优化只有 col2 或 col3 的查询。</p>
<p>也就说，在进行查询时，如果没有遵循最左前缀，那么索引可能不会被利用，导致查询效率降低。</p>
<p><strong>为什么不从最左开始查，就无法匹配呢？</strong></p>
<p>比如有一个 user 表，我们给 name 和 age 建立了一个联合索引 <code>(name, age)</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE user add INDEX comidx_name_phone (name,age);</span><br></pre></td></tr></table></figure>

<p>联合索引在 B+ 树中是复合的数据结构，按照从左到右的顺序依次建立搜索树的 (name 在左边，age 在右边)。</p>
<p><img src="%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.jpg" alt="联合索引"></p>
<p>注意，name 是有序的，age 是无序的。当 name 相等的时候，age 才有序。</p>
<p>当我们使用 <code>where name= &#39;张三&#39; and age = &#39;20&#39;</code> 去查询的时候， B+ 树会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。</p>
<p>如果 name 相同的时候再比较 age。</p>
<p>但如果查询条件没有 name，就不知道应该怎么查了，因为 name 是 B+树中的前置条件，没有 name，索引就派不上用场了。</p>
<p><strong>(A,B,C) 联合索引 <code>select * from tbn where a=? and b in (?,?) and c&gt;?</code> 会走索引吗？</strong></p>
<p>这个查询会使用到联合索引 <code>(A,B,C)</code>，因为条件是按照索引列 <code>A</code>、<code>B</code>、<code>C</code> 的顺序来的，这是理想的使用场景。</p>
<ol>
<li>对于 <code>A=?</code>：这个条件是一个精确匹配，MySQL 会使用索引来定位到满足条件 <code>A=?</code> 的记录。</li>
<li>对于 <code>B IN (?, ?)</code>：这个条件指定了 <code>B</code> 列可以取两个可能的值。MySQL 会利用索引来查找所有匹配 <code>A=?</code> 且 <code>B</code> 列为这两个值中任意一个的记录。</li>
<li>对于 <code>C&gt;?</code>：这个条件是一个范围查询。在已经根据 <code>A</code> 和 <code>B</code> 筛选的基础上，MySQL 会继续利用索引来查找 <code>C</code> 列值大于指定值的记录。</li>
</ol>
<h3 id="索引下推优化"><a href="#索引下推优化" class="headerlink" title="索引下推优化"></a>索引下推优化</h3><p>索引条件下推优化<code>（Index Condition Pushdown (ICP) ）</code>是 MySQL5.6 添加的，用于优化数据查询。</p>
<ul>
<li>不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给 MySQL Server，MySQL Server 进行过滤条件的判断。</li>
<li>当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL Server 将这一部分判断条件<strong>下推</strong>给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL Server 传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器。</li>
</ul>
<p>例如一张表，建了一个联合索引（name, age），查询语句：<code>select * from t_user where name like &#39;张%&#39; and age=10;</code>，由于<code>name</code>使用了范围查询，根据最左匹配原则：</p>
<p>不使用 ICP，引擎层查找到<code>name like &#39;张%&#39;</code>的数据，再由 Server 层去过滤<code>age=10</code>这个条件，这样一来，就回表了两次，浪费了联合索引的另外一个字段<code>age</code>。</p>
<p><img src="noICP.jpg" alt="noICP"></p>
<p>但是，使用了索引下推优化，把 where 的条件放到了引擎层执行，直接根据<code>name like &#39;张%&#39; and age=10</code>的条件进行过滤，减少了回表的次数。</p>
<p><img src="ICP.jpg" alt="ICP"></p>
<p>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。</p>
<h3 id="MySQL有几种锁"><a href="#MySQL有几种锁" class="headerlink" title="MySQL有几种锁"></a>MySQL有几种锁</h3><p><img src="%E9%94%81.jpg" alt="锁"></p>
<p>如果按锁粒度划分，有以下 3 种：</p>
<ul>
<li>表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。</li>
<li>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</li>
<li>页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li>
</ul>
<p>如果按照兼容性，有两种，</p>
<ul>
<li>共享锁（S Lock）,也叫读锁（read lock），相互不阻塞。</li>
<li>排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。</li>
</ul>
<h3 id="InnoDB行锁"><a href="#InnoDB行锁" class="headerlink" title="InnoDB行锁"></a>InnoDB行锁</h3><p>我们拿这么一个用户表来表示行级锁，其中插入了 4 行数据，主键值分别是 1,6,8,12，现在简化它的聚簇索引结构，只保留数据记录。</p>
<p><img src="%E8%A1%8C%E9%94%81.jpg" alt="行锁"></p>
<p>InnoDB 的行锁的主要实现如下：</p>
<ul>
<li><strong>Record Lock 记录锁</strong></li>
</ul>
<p>记录锁就是直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。例如<code>select * from t where id =6 for update;</code>就会将<code>id=6</code>的记录锁定。</p>
<p><img src="%E8%AE%B0%E5%BD%95%E9%94%81.jpg" alt="记录锁"></p>
<ul>
<li><strong>Gap Lock 间隙锁</strong></li>
</ul>
<p>间隙锁(Gap Locks) 的间隙指的是两个记录之间逻辑上尚未填入数据的部分,是一个<strong>左开右开空间</strong>。</p>
<p><img src="%E9%97%B4%E9%9A%99%E9%94%81.jpg" alt="间隙锁"></p>
<p>间隙锁就是锁定某些间隙区间的。当我们使用用等值查询或者范围查询，并且没有命中任何一个<code>record</code>，此时就会将对应的间隙区间锁定。例如<code>select * from t where id =3 for update;</code>或者<code>select * from t where id &gt; 1 and id &lt; 6 for update;</code>就会将(1,6)区间锁定。</p>
<ul>
<li><strong>Next-key Lock 临键锁</strong></li>
</ul>
<p>临键指的是间隙加上它右边的记录组成的<strong>左开右闭区间</strong>。比如上述的(1,6]、(6,8]等。</p>
<p><img src="%E4%B8%B4%E9%94%AE%E9%94%81.jpg" alt="临键锁"></p>
<p>临键锁就是记录锁(Record Locks)和间隙锁(Gap Locks)的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分<code>record</code>记录，此时锁住的就是临键区间。注意，临键锁锁住的区间会包含最后一个 record 的右边的临键区间。例如<code>select * from t where id &gt; 5 and id &lt;= 7 for update;</code>会锁住(4,7]、(7,+∞)。mysql 默认行锁类型就是<code>临键锁(Next-Key Locks)</code>。当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(Next-Key Locks)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。</p>
<blockquote>
<p><code>间隙锁(Gap Locks)</code>和<code>临键锁(Next-Key Locks)</code>都是用来解决幻读问题的，在<code>已提交读（READ COMMITTED）</code>隔离级别下，<code>间隙锁(Gap Locks)</code>和<code>临键锁(Next-Key Locks)</code>都会失效！</p>
</blockquote>
<p>上面是行锁的三种实现算法，除此之外，在行上还存在插入意向锁。</p>
<ul>
<li><strong>Insert Intention Lock 插入意向锁</strong></li>
</ul>
<p>一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了意向锁 ，如果有的话，插入操作需要等待，直到拥有 gap 锁 的那个事务提交。但是事务在等待的时候也需要在内存中生成一个 锁结构 ，表明有事务想在某个 间隙 中插入新记录，但是现在在等待。这种类型的锁命名为 Insert Intention Locks ，也就是插入意向锁 。</p>
<p>假如我们有个 T1 事务，给(1,6)区间加上了意向锁，现在有个 T2 事务，要插入一个数据，id 为 4，它会获取一个（1,6）区间的插入意向锁，又有有个 T3 事务，想要插入一个数据，id 为 3，它也会获取一个（1,6）区间的插入意向锁，但是，这两个插入意向锁锁不会互斥。</p>
<p><img src="%E6%84%8F%E5%90%91%E9%94%81.jpg" alt="意向锁"></p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向锁是一个表级锁，不要和插入意向锁搞混。</p>
<p>意向锁的出现是为了支持 InnoDB 的多粒度锁，它解决的是表锁和行锁共存的问题。</p>
<p>当我们需要给一个表加表锁的时候，我们需要根据去判断表中有没有数据行被锁定，以确定是否能加成功。</p>
<p>假如没有意向锁，那么我们就得遍历表中所有数据行来判断有没有行锁；</p>
<p>有了意向锁这个表级锁之后，则我们直接判断一次就知道表中是否有数据行被锁定了。</p>
<p>有了意向锁之后，要执行的事务 A 在申请行锁（写锁）之前，数据库会自动先给事务 A 申请表的意向排他锁。当事务 B 去申请表的互斥锁时就会失败，因为表上有意向排他锁之后事务 B 申请表的互斥锁时会被阻塞。</p>
<p><img src="%E6%84%8F%E5%90%91%E9%94%812.jpg" alt="意向锁"></p>
<h3 id="悲观锁、乐观锁"><a href="#悲观锁、乐观锁" class="headerlink" title="悲观锁、乐观锁"></a>悲观锁、乐观锁</h3><ul>
<li><strong>悲观锁</strong>（Pessimistic Concurrency Control）：</li>
</ul>
<p>悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能被改动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。</p>
<p>数据库中的行锁，表锁，读锁，写锁均为悲观锁。</p>
<ul>
<li><strong>乐观锁（Optimistic Concurrency Control）</strong></li>
</ul>
<p>乐观锁认为数据的变动不会太频繁。</p>
<p>乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用。</p>
<p>事务在从数据库中取数据时，会将该数据的版本也取出来(v1)，当事务对数据变动完毕想要将其更新到表中时，会将之前取出的版本 v1 与数据中最新的版本 v2 相对比，如果 v1=v2，那么说明在数据变动期间，没有其他事务对数据进行修改，此时，就允许事务对表中的数据进行修改，并且修改时 version 会加 1，以此来表明数据已被变动。</p>
<p>如果，v1 不等于 v2，那么说明数据变动期间，数据被其他事务改动了，此时不允许数据更新到表中，一般的处理办法是通知用户让其重新操作。不同于悲观锁，乐观锁通常是由开发者实现的。</p>
<h3 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h3><p>排查死锁的一般步骤是这样的：</p>
<p>（1）查看死锁日志 show engine innodb status;</p>
<p>（2）找出死锁 sql</p>
<p>（3）分析 sql 加锁情况</p>
<p>（4）模拟死锁案发</p>
<p>（5）分析死锁日志</p>
<p>（6）分析死锁结果</p>
<p>当然，这只是一个简单的流程说明，实际上生产中的死锁千奇百怪，排查和解决起来没那么简单。</p>
<h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>事务是一个或多个 SQL 语句组成的一个执行单元，这些 SQL 语句要么全部执行成功，要么全部不执行，不会出现部分执行的情况。事务是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
<p>事务的主要作用是保证数据库操作的一致性，即事务内的操作，要么全部成功，要么全部失败回滚，不会出现中间状态。这对于维护数据库的完整性和一致性非常重要。</p>
<p>事务具有四个基本特性，也就是通常所说的 ACID 特性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p>
<h4 id="什么是原子性？"><a href="#什么是原子性？" class="headerlink" title="什么是原子性？"></a>什么是原子性？</h4><p>原子性子性意味着事务中的所有操作要么全部完成，要么全部不完成，它是不可分割的单位。如果事务中的任何一个操作失败了，整个事务都会回滚到事务开始之前的状态，如同这些操作从未被执行过一样。</p>
<h4 id="什么是一致性？"><a href="#什么是一致性？" class="headerlink" title="什么是一致性？"></a>什么是一致性？</h4><p>一致性确保事务从一个一致的状态转换到另一个一致的状态。</p>
<p>比如在银行转账事务中，无论发生什么，转账前后两个账户的总金额应保持不变。假如 A 账户（100 块）给 B 账户（10 块）转了 10 块钱，不管成功与否，A 和 B 的总金额都是 110 块。</p>
<h4 id="什么是隔离性？"><a href="#什么是隔离性？" class="headerlink" title="什么是隔离性？"></a>什么是隔离性？</h4><p>隔离性意味着并发执行的事务是彼此隔离的，一个事务的执行不会被其他事务干扰。就是事务之间是井水不犯河水的。</p>
<p>隔离性主要是为了解决事务并发执行时可能出现的问题，如脏读、不可重复读、幻读等。</p>
<p>数据库系统通过事务隔离级别（如读未提交、读已提交、可重复读、串行化）来实现事务的隔离性。</p>
<h4 id="什么是持久性？"><a href="#什么是持久性？" class="headerlink" title="什么是持久性？"></a>什么是持久性？</h4><p>持久性确保事务一旦提交，它对数据库所做的更改就是永久性的，即使发生系统崩溃，数据库也能恢复到最近一次提交的状态。通常，持久性是通过数据库的恢复和日志机制来实现的，确保提交的事务更改不会丢失。</p>
<p>简短一点的回答可以是：</p>
<ul>
<li><strong>原子性</strong>：事务的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务中的操作不能只执行其中一部分。</li>
<li><strong>一致性</strong>：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致性与业务规则有关，比如银行转账，不论事务成功还是失败，转账双方的总金额应该是不变的。</li>
<li><strong>隔离性</strong>：多个并发事务之间需要相互隔离，即一个事务的执行不能被其他事务干扰。</li>
<li><strong>持久性</strong>：一旦事务提交，则其所做的修改将永久保存到数据库中。即使发生系统崩溃，修改的数据也不会丢失。</li>
</ul>
<h3 id="ACID-靠什么保证"><a href="#ACID-靠什么保证" class="headerlink" title="ACID 靠什么保证"></a>ACID 靠什么保证</h3><p>MySQL 通过事务管理和持久性存储机制来确保 ACID（原子性、一致性、隔离性和持久性）。</p>
<p>01、原子性（Atomicity），如果事务的所有操作都成功执行，则事务被提交；如果事务中的任何操作失败，所有事务中的操作都会被回滚，使数据库返回到事务开始前的状态。</p>
<p>undo log 是 InnoDB 存储引擎来确保事务原子性的关键机制，undo log 记录了事务发生之前的数据，如果事务失败，InnoDB 会根据 undo log 回滚数据。</p>
<p>当事务开始修改数据时，InnoDB 首先会在<code>undo log</code>中记录旧值（即修改前的值）。</p>
<ul>
<li>如果事务顺利进行并最终提交，<code>undo log</code>会在某个时间点被清除。</li>
<li>如果事务中的某个操作失败或者事务被明确地回滚，InnoDB 会使用<code>undo log</code>中的信息来撤销所有更改，确保数据的原子性。</li>
</ul>
<p>简而言之，<code>undo log</code>机制为 InnoDB 提供了一种在事务失败或被中断时恢复数据的手段，从而保证了事务的原子性。</p>
<p>02、一致性（Consistency），保证在事务开始之前和事务成功完成之后，数据库处于一个一致的状态。中间的任何阶段，即使事务失败，也不应该使数据库处于不一致的状态。</p>
<p>一致性是 ACID 的目的，也就是说，只要保证原子性、隔离性、持久性，自然也就保证了数据的一致性。</p>
<p>03、隔离性 (Isolation)，MySQL 使用多种隔离级别来控制事务如何与其他并发事务隔离。InnoDB 存储引擎使用 MVCC (多版本并发控制) 机制来处理并发事务，确保每个事务都有自己的数据版本。</p>
<p>换句话说，事务查看数据时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
<p>在 MVCC 中，每次更新记录时，都会生成记录的一个新版本，而不是覆盖老版本。每个版本都会有两个额外的属性：一个表示版本的创建时间（或事务 ID），另一个表示版本的过期时间（或下一个版本的事务 ID）。</p>
<p>当事务尝试读取记录时，它会看到该事务开始时有效的那个版本。</p>
<p>MVCC 通过提供数据版本来支持事务的隔离性。不同的事务会看到不同版本的数据行，这取决于事务的开始时间和它的隔离级别。</p>
<p>对于如 “读未提交”（READ UNCOMMITTED）这样的较低隔离级别，事务可能会看到其他未提交事务所做的更改。但在更高的隔离级别，如 “可重复读”（REPEATABLE READ）或 “串行化”（SERIALIZABLE），事务不会看到其他事务所做的更改，直到它们被提交。</p>
<p>04、持久性 (Durability)，由 MySQL 的存储引擎（如 InnoDB）通过写入磁盘来确保。即使在系统崩溃之后，已提交事务的更改也不会丢失。</p>
<p>InnoDB 使用“redo log”来记录数据的更改，在系统崩溃后，redo log 可用于恢复数据。</p>
<p>redo log 是一种物理日志，记录了对数据页的物理更改。当事务进行写操作时，InnoDB 首先会写入 redo log，并不会立即修改数据文件。这种写入方式被称为“write-ahead logging”（先写日志）。</p>
<p>当 redo log 填满或在某些其他情况下，InnoDB 会异步将这些更改刷新到数据文件中。</p>
<p>系统崩溃时，由于数据可能还没有被真正写入数据文件，但已经在 redo log 中，因此系统可以在启动时使用这些日志来重新执行或“重做”这些更改，确保数据的持久性。</p>
<p>即使数据库在事务提交后立即崩溃，由于事务的更改已经记录在 redo log 中，这些更改在数据库恢复时仍然是安全的。</p>
<p><img src="%E4%BF%9D%E8%AF%81.png" alt="保证"></p>
<h3 id="事务的隔离级别有哪些？MySQL-的默认隔离级别是什么"><a href="#事务的隔离级别有哪些？MySQL-的默认隔离级别是什么" class="headerlink" title="事务的隔离级别有哪些？MySQL 的默认隔离级别是什么"></a>事务的隔离级别有哪些？MySQL 的默认隔离级别是什么</h3><p>事务的隔离级别定了一个事务可能受其他事务影响的程度，MySQL 支持的四种隔离级别分别是：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。</p>
<h4 id="什么是读未提交？"><a href="#什么是读未提交？" class="headerlink" title="什么是读未提交？"></a>什么是读未提交？</h4><p>读未提交是最低的隔离级别，在这个级别，当前事务可以读取未被其他事务提交的数据，以至于会出现“脏读”、“不可重复读”和“幻读”的问题。</p>
<h4 id="什么是读已提交？"><a href="#什么是读已提交？" class="headerlink" title="什么是读已提交？"></a>什么是读已提交？</h4><p>当前事务只能读取已经被其他事务提交的数据，可以避免“脏读”现象。但不可重复读和幻读问题仍然存在。</p>
<h4 id="什么是可重复读？"><a href="#什么是可重复读？" class="headerlink" title="什么是可重复读？"></a>什么是可重复读？</h4><p>确保在同一事务中多次读取相同记录的结果是一致的，即使其他事务对这条记录进行了修改，也不会影响到当前事务。</p>
<p>是 MySQL 默认的隔离级别，避免了“脏读”和“不可重复读”，也在很大程度上减少了“幻读”问题。</p>
<h4 id="什么是串行化？"><a href="#什么是串行化？" class="headerlink" title="什么是串行化？"></a>什么是串行化？</h4><p>最高的隔离级别，通过强制事务串行执行来避免并发问题，可以解决“脏读”、“不可重复读”和“幻读”问题。</p>
<p>但会导致大量的超时和锁竞争问题。</p>
<h3 id="什么是幻读，脏读，不可重复读"><a href="#什么是幻读，脏读，不可重复读" class="headerlink" title="什么是幻读，脏读，不可重复读"></a>什么是幻读，脏读，不可重复读</h3><ul>
<li>事务 A、B 交替执行，事务 A 读取到事务 B 未提交的数据，这就是<strong>脏读</strong>。</li>
<li>在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是<strong>不可重复读</strong>。</li>
<li>事务 A 查询一个范围的结果集，另一个并发事务 B 往这个范围中插入 / 删除了数据，并静悄悄地提交，然后事务 A 再次查询相同的范围，两次读取得到的结果集不一样了，这就是<strong>幻读</strong>。</li>
</ul>
<p>不同的隔离级别，在并发事务下可能会发生的问题：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommited 读取未提交</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Read Commited 读取已提交</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Repeatable Read 可重复读</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>Serialzable 可串行化</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="事务的各个隔离级别都是如何实现的"><a href="#事务的各个隔离级别都是如何实现的" class="headerlink" title="事务的各个隔离级别都是如何实现的"></a>事务的各个隔离级别都是如何实现的</h3><p><strong>读未提交</strong></p>
<p>读未提交，就不用多说了，采取的是读不加锁原理。</p>
<ul>
<li>事务读不加锁，不阻塞其他事务的读和写</li>
<li>事务写阻塞其他事务写，但不阻塞其他事务读；</li>
</ul>
<p><strong>读取已提交&amp;可重复读</strong></p>
<p>读取已提交和可重复读级别利用了<code>ReadView</code>和<code>MVCC</code>，也就是每个事务只能读取它能看到的版本（ReadView）。</p>
<ul>
<li>READ COMMITTED：每次读取数据前都生成一个 ReadView</li>
<li>REPEATABLE READ ：在第一次读取数据时生成一个 ReadView</li>
</ul>
<p><strong>串行化</strong></p>
<p>串行化的实现采用的是读写都加锁的原理。</p>
<p>串行化的情况下，对于同一行事务，<code>写</code>会加<code>写锁</code>，<code>读</code>会加<code>读锁</code>。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>
<h3 id="MVCC-了解吗？怎么实现的"><a href="#MVCC-了解吗？怎么实现的" class="headerlink" title="MVCC 了解吗？怎么实现的"></a>MVCC 了解吗？怎么实现的</h3><p>MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。关于它的实现，要抓住几个关键点，<strong>隐式字段、undo 日志、版本链、快照读&amp;当前读、Read View</strong>。</p>
<h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3><p>读写分离的基本原理是将数据库读写操作分散到不同的节点上，下面是基本架构图：</p>
<p><img src="%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.jpg" alt="读写分离"></p>
<p>读写分离的基本实现是:</p>
<ul>
<li>数据库服务器搭建主从集群，一主一从、一主多从都可以。</li>
<li>数据库主机负责读写操作，从机只负责读操作。</li>
<li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。</li>
<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机。</li>
</ul>
<h3 id="读写分离的分配怎么实现"><a href="#读写分离的分配怎么实现" class="headerlink" title="读写分离的分配怎么实现"></a>读写分离的分配怎么实现</h3><p>将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：程序代码封装和中间件封装。</p>
<ol>
<li>程序代码封装</li>
</ol>
<p>程序代码封装指在代码中抽象一个数据访问层（所以有的文章也称这种方式为 “中间层封装” ） ，实现读写操作分离和数据库服务器连接的管理。例如，基于 Hibernate 进行简单封装，就可以实现读写分离：</p>
<p><img src="%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81.jpg" alt="业务代码"></p>
<p>目前开源的实现方案中，淘宝的 TDDL （Taobao Distributed Data Layer, 外号：头都大了）是比较有名的。</p>
<ol>
<li>中间件封装</li>
</ol>
<p>中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。</p>
<p>对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。</p>
<p>其基本架构是：</p>
<p><img src="%E4%B8%AD%E9%97%B4%E4%BB%B6.jpg" alt="中间件"></p>
<h3 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h3><ul>
<li>master 数据写入，更新 binlog</li>
<li>master 创建一个 dump 线程向 slave 推送 binlog</li>
<li>slave 连接到 master 的时候，会创建一个 IO 线程接收 binlog，并记录到 relay log 中继日志中</li>
<li>slave 再开启一个 sql 线程读取 relay log 事件并在 slave 执行，完成同步</li>
<li>slave 记录自己的 binlog</li>
</ul>
<p><img src="%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B62.jpg" alt="主从复制"></p>
<h3 id="主从同步延迟"><a href="#主从同步延迟" class="headerlink" title="主从同步延迟"></a>主从同步延迟</h3><p><strong>主从同步延迟的原因</strong></p>
<p>一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取 binlog 的线程仅有一个，当某个 SQL 在从服务器上执行的时间稍长 或者由于某个 SQL 要进行锁表就会导致，主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。</p>
<p><strong>主从同步延迟的解决办法</strong></p>
<p>解决主从复制延迟有几种常见的方法:</p>
<ol>
<li><p>写操作后的读操作指定发给数据库主服务器</p>
<p>例如，注册账号完成后，登录时读取账号的读操作也发给数据库主服务器。这种方式和业务强绑定，对业务的侵入和影响较大，如果哪个新来的程序员不知道这样写代码，就会导致一个 bug。</p>
</li>
<li><p>读从机失败后再读一次主机</p>
<p>这就是通常所说的 “二次读取” ，二次读取和业务无绑定，只需要对底层数据库访问的 API 进行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。例如，黑客暴力破解账号，会导致大量的二次读取操作，主机可能顶不住读操作的压力从而崩溃。</p>
</li>
<li><p>关键业务读写操作全部指向主机，非关键业务采用读写分离</p>
<p>例如，对于一个用户管理系统来说，注册 + 登录的业务读写操作全部访问主机，用户的介绍、爰好、等级等业务，可以采用读写分离，因为即使用户改了自己的自我介绍，在查询时却看到了自我介绍还是旧的，业务影响与不能登录相比就小很多，还可以忍受。</p>
</li>
</ol>
<h3 id="怎么分库"><a href="#怎么分库" class="headerlink" title="怎么分库"></a>怎么分库</h3><p>分库分表是为了解决单库单表数据量过大导致数据库性能下降的一种解决方案。</p>
<p>分库的策略有两种：</p>
<p>①、垂直分库：按照业务模块将不同的表拆分到不同的库中，例如，用户表、订单表、商品表等分到不同的库中。</p>
<p><img src="%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93.jpg" alt="垂直分库"></p>
<p>②、水平分库：按照一定的策略将一个表中的数据拆分到多个库中，例如，按照用户 id 的 hash 值将用户表拆分到不同的库中。</p>
<p><img src="%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93.jpg" alt="水平分库"></p>
<h3 id="怎么分表"><a href="#怎么分表" class="headerlink" title="怎么分表"></a>怎么分表</h3><p>当单表数据增量过快，业界流传的说法是超过 500 万的数据量就要考虑分表了。</p>
<p>在技术派实战项目中，我们将文章表和文章详情表做了分表处理，因为文章的详情数据量会比较大，而文章的基本信息数据量会比较小。</p>
<p>垂直拆分可以减轻只查询文章基本数据，不需要附带文章详情时的查询压力。</p>
<p>当然了，当表的数据量过大时，仍然要考虑水平分表，将一个表的数据分散到多个表中，以减轻单表的查询压力。</p>
<p><img src="%E5%88%86%E8%A1%A82.jpg" alt="分表"></p>
<h3 id="不停机扩容怎么实现"><a href="#不停机扩容怎么实现" class="headerlink" title="不停机扩容怎么实现"></a>不停机扩容怎么实现</h3><p>实际上，不停机扩容，实操起来是个非常麻烦而且很有风险的操作，当然，面试回答起来就简单很多。</p>
<ul>
<li><strong>第一阶段：在线双写，查询走老库</strong></li>
</ul>
<ol>
<li>建立好新的库表结构，数据写入久库的同时，也写入拆分的新库</li>
<li>数据迁移，使用数据迁移程序，将旧库中的历史数据迁移到新库</li>
<li>使用定时任务，新旧库的数据对比，把差异补齐</li>
</ol>
<p><img src="1.jpg" alt="1"></p>
<ul>
<li><strong>第二阶段：在线双写，查询走新库</strong></li>
</ul>
<ol>
<li>完成了历史数据的同步和校验</li>
<li>把对数据的读切换到新库</li>
</ol>
<p><img src="2.jpg" alt="2"></p>
<ul>
<li><strong>第三阶段：旧库下线</strong></li>
</ul>
<ol>
<li>旧库不再写入新的数据</li>
<li>经过一段时间，确定旧库没有请求之后，就可以下线老库</li>
</ol>
<p><img src="3.jpg" alt="3"></p>
<h3 id="分库分表会带来什么问题"><a href="#分库分表会带来什么问题" class="headerlink" title="分库分表会带来什么问题"></a>分库分表会带来什么问题</h3><p>从分库的角度来讲：</p>
<ul>
<li><strong>事务的问题</strong></li>
</ul>
<p>使用关系型数据库，有很大一点在于它保证事务完整性。</p>
<p>而分库之后单机事务就用不上了，必须使用分布式事务来解决。</p>
<ul>
<li><strong>跨库 JOIN 问题</strong></li>
</ul>
<p>在一个库中的时候我们还可以利用 JOIN 来连表查询，而跨库了之后就无法使用 JOIN 了。</p>
<p>此时的解决方案就是<strong>在业务代码中进行关联</strong>，也就是先把一个表的数据查出来，然后通过得到的结果再去查另一张表，然后利用代码来关联得到最终的结果。</p>
<p>这种方式实现起来稍微比较复杂，不过也是可以接受的。</p>
<p>还有可以<strong>适当的冗余一些字段</strong>。比如以前的表就存储一个关联 ID，但是业务时常要求返回对应的 Name 或者其他字段。这时候就可以把这些字段冗余到当前表中，来去除需要关联的操作。</p>
<p>还有一种方式就是<strong>数据异构</strong>，通过 binlog 同步等方式，把需要跨库 join 的数据异构到 ES 等存储结构中，通过 ES 进行查询。</p>
<p>从分表的角度来看：</p>
<ul>
<li><strong>跨节点的 count,order by,group by 以及聚合函数问题</strong></li>
</ul>
<p>只能由业务代码来实现或者用中间件将各表中的数据汇总、排序、分页然后返回。</p>
<ul>
<li><strong>数据迁移，容量规划，扩容等问题</strong></li>
</ul>
<p>数据的迁移，容量如何规划，未来是否可能再次需要扩容，等等，都是需要考虑的问题。</p>
<ul>
<li><strong>ID 问题</strong></li>
</ul>
<p>数据库表被切分后，不能再依赖数据库自身的主键生成机制，所以需要一些手段来保证全局主键唯一。</p>
<ol>
<li>还是自增，只不过自增步长设置一下。比如现在有三张表，步长设置为 3，三张表 ID 初始值分别是 1、2、3。这样第一张表的 ID 增长是 1、4、7。第二张表是 2、5、8。第三张表是 3、6、9，这样就不会重复了。</li>
<li>UUID，这种最简单，但是不连续的主键插入会导致严重的页分裂，性能比较差。</li>
<li>分布式 ID，比较出名的就是 Twitter 开源的 sonwflake 雪花算法</li>
</ol>
<h3 id="百万千万级大表如何添加字段"><a href="#百万千万级大表如何添加字段" class="headerlink" title="百万千万级大表如何添加字段"></a>百万千万级大表如何添加字段</h3><p>当线上的数据库数据量到达几百万、上千万的时候，加一个字段就没那么简单，因为可能会长时间锁表。</p>
<p>大表添加字段，通常有这些做法：</p>
<ul>
<li>通过中间表转换过去</li>
</ul>
<p>创建一个临时的新表，把旧表的结构完全复制过去，添加字段，再把旧表数据复制过去，删除旧表，新表命名为旧表的名称，这种方式可能回丢掉一些数据。</p>
<ul>
<li>用 pt-online-schema-change</li>
</ul>
<p><code>pt-online-schema-change</code>是 percona 公司开发的一个工具，它可以在线修改表结构，它的原理也是通过中间表。</p>
<ul>
<li>先在从库添加 再进行主从切换</li>
</ul>
<p>如果一张表数据量大且是热表（读写特别频繁），则可以考虑先在从库添加，再进行主从切换，切换后再将其他几个节点上添加字段。</p>
<h3 id="MySQL-数据库-cpu-飙升，怎么处理"><a href="#MySQL-数据库-cpu-飙升，怎么处理" class="headerlink" title="MySQL 数据库 cpu 飙升，怎么处理"></a>MySQL 数据库 cpu 飙升，怎么处理</h3><p>排查过程：</p>
<p>（1）使用 top 命令观察，确定是 mysqld 导致还是其他原因。</p>
<p>（2）如果是 mysqld 导致的，show processlist，查看 session 情况，确定是不是有消耗资源的 sql 在运行。</p>
<p>（3）找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。</p>
<p>处理：</p>
<p>（1）kill 掉这些线程 (同时观察 cpu 使用率是否下降)，</p>
<p>（2）进行相应的调整 (比如说加索引、改 sql、改内存参数)</p>
<p>（3）重新跑这些 SQL。</p>
<h3 id="Redis和MySQL双写一致性如何保证"><a href="#Redis和MySQL双写一致性如何保证" class="headerlink" title="Redis和MySQL双写一致性如何保证"></a>Redis和MySQL双写一致性如何保证</h3><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。</p>
<ul>
<li><strong>强一致性</strong>：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</li>
<li><strong>弱一致性</strong>：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</li>
<li><strong>最终一致性</strong>：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据<strong>不一致性</strong>的问题。一般我们是如何使用缓存呢？有三种经典的缓存模式：</p>
<ul>
<li>Cache-Aside Pattern</li>
<li>Read-Through/Write through</li>
<li>Write behind</li>
</ul>
<h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache-Aside Pattern"></a>Cache-Aside Pattern</h4><p>Cache-Aside Pattern，即<strong>旁路缓存模式</strong>，它的提出是为了尽可能地解决缓存与数据库的数据不一致问题。</p>
<p><strong>Cache-Aside Pattern</strong>的读请求流程如下：</p>
<p><img src="cache-aside.png" alt="cache-aside"></p>
<ol>
<li>读的时候，先读缓存，缓存命中的话，直接返回数据</li>
<li>缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应。</li>
</ol>
<p><strong>Cache-Aside Pattern</strong>的写请求流程如下：</p>
<p><img src="cache-aside2.png" alt="cache-aside"></p>
<p>更新的时候，先<strong>更新数据库，然后再删除缓存</strong>。</p>
<h4 id="Read-Through-Write-Through（读写穿透）"><a href="#Read-Through-Write-Through（读写穿透）" class="headerlink" title="Read-Through/Write-Through（读写穿透）"></a>Read-Through/Write-Through（读写穿透）</h4><p><strong>Read/Write Through</strong>模式中，服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过<strong>抽象缓存层</strong>完成的。</p>
<p><strong>Read-Through</strong>的简要流程如下：</p>
<p><img src="read-through.png" alt="read-through"></p>
<ol>
<li>从缓存读取数据，读到直接返回</li>
<li>如果读取不到的话，从数据库加载，写入缓存后，再返回响应。</li>
</ol>
<p>这个简要流程是不是跟<strong>Cache-Aside</strong>很像呢？其实<strong>Read-Through</strong>就是多了一层<strong>Cache-Provider</strong>，流程如下：</p>
<p><img src="cache-provider.png" alt="cache-provider"></p>
<p>Read-Through实际只是在<strong>Cache-Aside</strong>之上进行了一层封装，它会让程序代码变得更简洁，同时也减少数据源上的负载。</p>
<p><strong>Write-Through</strong>模式下，当发生写请求时，也是由<strong>缓存抽象层</strong>完成数据源和缓存数据的更新,流程如下：</p>
<p><img src="write-through.png" alt="write-through"></p>
<h4 id="Write-behind-（异步缓存写入）"><a href="#Write-behind-（异步缓存写入）" class="headerlink" title="Write behind （异步缓存写入）"></a>Write behind （异步缓存写入）</h4><p><strong>Write behind</strong>跟<strong>Read-Through/Write-Through</strong>有相似的地方，都是由<code>Cache Provider</code>来负责缓存和数据库的读写。它两又有个很大的不同：<strong>Read/Write Through</strong>是同步更新缓存和数据的，<strong>Write Behind</strong>则是只更新缓存，不直接更新数据库，通过<strong>批量异步</strong>的方式来更新数据库。</p>
<p><img src="write-behind.png" alt="write-behind"></p>
<p>这种方式下，缓存和数据库的一致性不强，<strong>对一致性要求高的系统要谨慎使用</strong>。但是它适合频繁写的场景，MySQL的<strong>InnoDB Buffer Pool机制</strong>就使用到这种模式。</p>
<h3 id="操作缓存的时候，删除缓存呢，还是更新缓存？"><a href="#操作缓存的时候，删除缓存呢，还是更新缓存？" class="headerlink" title="操作缓存的时候，删除缓存呢，还是更新缓存？"></a>操作缓存的时候，删除缓存呢，还是更新缓存？</h3><p>一般业务场景，我们使用的就是<strong>Cache-Aside</strong>模式。 有些小伙伴可能会问， <strong>Cache-Aside</strong>在写入请求的时候，为什么是<strong>删除缓存而不是更新缓存</strong>呢？</p>
<p>看个例子：</p>
<p><img src="cache.png" alt="cache"></p>
<ol>
<li>线程A先发起一个写操作，第一步先更新数据库</li>
<li>线程B再发起一个写操作，第二步更新了数据库</li>
<li>由于网络等原因，线程B先更新了缓存</li>
<li>线程A更新缓存。</li>
</ol>
<p>这时候，缓存保存的是A的数据（老数据），数据库保存的是B的数据（新数据），数据<strong>不一致</strong>了，脏数据出现啦。如果是<strong>删除缓存取代更新缓存</strong>则不会出现这个脏数据问题。</p>
<p><strong>更新缓存相对于删除缓存</strong>，还有两点劣势：</p>
<ul>
<li>如果你写入的缓存值，是经过复杂计算才得到的话。更新缓存频率高的话，就浪费性能啦。</li>
<li>在写数据库场景多，读数据场景少的情况下，数据很多时候还没被读取到，又被更新了，这也浪费了性能呢(实际上，写多的场景，用缓存也不是很划算了)</li>
</ul>
<h3 id="双写的情况下，先操作数据库还是先操作缓存？"><a href="#双写的情况下，先操作数据库还是先操作缓存？" class="headerlink" title="双写的情况下，先操作数据库还是先操作缓存？"></a>双写的情况下，先操作数据库还是先操作缓存？</h3><p><code>Cache-Aside</code>缓存模式中，在写入请求的时候，为什么是<strong>先操作数据库呢</strong>？为什么<strong>不先操作缓存</strong>呢？</p>
<p>假设有A、B两个请求，请求A做更新操作，请求B做查询读取操作。</p>
<p><img src="cache2.png" alt="cache"></p>
<ol>
<li>线程A发起一个写操作，第一步del cache</li>
<li>此时线程B发起一个读操作，cache miss</li>
<li>线程B继续读DB，读出来一个老数据</li>
<li>然后线程B把老数据设置入cache</li>
<li>线程A写入DB最新的数据</li>
</ol>
<p>酱紫就有问题啦，<strong>缓存和数据库的数据不一致了。缓存保存的是老数据，数据库保存的是新数据</strong>。因此，<code>Cache-Aside</code>缓存模式，选择了先操作数据库而不是先操作缓存。</p>
<h3 id="缓存延时双删"><a href="#缓存延时双删" class="headerlink" title="缓存延时双删"></a>缓存延时双删</h3><p>有些小伙伴可能会说，不一定要先操作数据库呀，采用<strong>缓存延时双删</strong>策略就好啦？什么是延时双删呢？</p>
<p><img src="%E7%BC%93%E5%AD%98%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0.png" alt="缓存延时双删"></p>
<ol>
<li>先删除缓存</li>
<li>再更新数据库</li>
<li>休眠一会（比如1秒），再次删除缓存。</li>
</ol>
<p>这个休眠一会，一般多久呢？都是1秒？</p>
<blockquote>
<p>这个休眠时间 = 读业务逻辑数据的耗时 + 几百毫秒。 为了确保读请求结束，写请求可以删除读请求可能带来的缓存脏数据。</p>
</blockquote>
<h3 id="删除缓存重试机制"><a href="#删除缓存重试机制" class="headerlink" title="删除缓存重试机制"></a>删除缓存重试机制</h3><p>不管是<strong>延时双删</strong>还是<strong>Cache-Aside的先操作数据库再删除缓存</strong>，如果第二步的删除缓存失败呢，删除失败会导致脏数据哦</p>
<blockquote>
<p>删除失败就多删除几次呀,保证删除缓存成功呀~ 所以可以引入<strong>删除缓存重试机制</strong></p>
</blockquote>
<p><img src="%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6.png" alt="删除缓存重试机制"></p>
<ol>
<li>写请求更新数据库</li>
<li>缓存因为某些原因，删除失败</li>
<li>把删除失败的key放到消息队列</li>
<li>消费消息队列的消息，获取要删除的key</li>
<li>重试删除缓存操作</li>
</ol>
<h3 id="读取binlog异步删除缓存"><a href="#读取binlog异步删除缓存" class="headerlink" title="读取binlog异步删除缓存"></a>读取binlog异步删除缓存</h3><p>重试删除缓存机制还可以，就是会造成好多业务代码入侵。其实，还可以通过<strong>数据库的binlog来异步淘汰key</strong>。</p>
<p><img src="binlog.png" alt="binlog"></p>
<p>以mysql为例 可以使用阿里的canal将binlog日志采集发送到MQ队列里面，然后通过ACK机制确认处理这条更新消息，删除缓存，保证数据缓存一致性。</p>
]]></content>
  </entry>
</search>
