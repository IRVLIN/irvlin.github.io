<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/05/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>最近闲在家里没事，就用hexo搭建了一个博客。不过不知道写点啥，先开个头吧～</p>
<a id="more"></a>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/05/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>记录一下常规的排序算法</p>
<a id="more"></a>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h4><p>常见的排序算法可分为以下两大类：</p>
<blockquote>
<p>比较类排序：通过比较来决定元素间的相对顺序，由于其时间复杂度不能突破<code>O(nlogn)</code>，因此也称为非线性时间比较类排序。<br>非比较类排序：不通过比较来决定元素间的相对顺序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。<br><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png" alt=""></p>
</blockquote>
<h4 id="时间、空间复杂度分析"><a href="#时间、空间复杂度分析" class="headerlink" title="时间、空间复杂度分析"></a>时间、空间复杂度分析</h4><h2 id=""><a href="#" class="headerlink" title=""></a><img src="%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt=""></h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="算法逻辑"><a href="#算法逻辑" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>循环数组中的每一对元素，比较二者大小，逆序就交换位置。这样循环一轮后最大的数会在数组末尾。重复即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123; <span class="comment">// 除了最后一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123; <span class="comment">// 后面已经排好序无需再比</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="算法逻辑-1"><a href="#算法逻辑-1" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>个人认为选择排序是最直观、最好理解的排序算法。从第1个数开始循环数组，每次循环都把当前最小值放到数组前面。重复即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 保存最小值对应的索引</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[min];</span><br><span class="line">        arr[min] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="算法逻辑-2"><a href="#算法逻辑-2" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>从第1个数开始循环数组，取出当前元素，从后到前分别与每一个元素进行比较，直到遇到第一个比当前元素小的数字，将当前元素插入此数字后面即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prei = i - <span class="number">1</span>, cur = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (prei &gt;= <span class="number">0</span> &amp;&amp; arr[prei] &gt; cur) &#123; <span class="comment">// 遇到第一个比当前小的就退出</span></span><br><span class="line">            arr[prei+<span class="number">1</span>] = arr[prei];</span><br><span class="line">            prei--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[prei+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="算法逻辑-3"><a href="#算法逻辑-3" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>选出一个元素作为<code>pivot</code>，通过一次循环将<code>pivot</code>直接放到最终结果的正确位置，即<code>pivot</code>左边的元素均比它小，右边均比它大。将左右两个子数组<strong>递归</strong>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">int</span> pivot = partition(arr, start, end); <span class="comment">// 获取基准值对应的索引</span></span><br><span class="line">    <span class="comment">// 对两部分数组递归</span></span><br><span class="line">    quickSort(arr, start, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivot + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = end, counter = start; <span class="comment">// counter: 记录小于基准值的数的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="comment">// 比基准值小就放到前面</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, counter, i);</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, counter, pivot); <span class="comment">// 使基准值位于最终结果的正确位置</span></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="算法逻辑-4"><a href="#算法逻辑-4" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>算法采用<strong>分治</strong>的思想。先将数组分成长度为<code>n/2</code>的两个数组，再对这两个子数组递归进行归并排序，最后将子数组合并成有序数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>; <span class="comment">// 长度小于2退出递归</span></span><br><span class="line">    <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 递归到最小单元</span></span><br><span class="line">    mergeSort(arr, start, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">    merge(arr, start, mid, end); <span class="comment">// 合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>]; <span class="comment">// 中间数组</span></span><br><span class="line">    <span class="keyword">int</span> i = start, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 双指针归并</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">        tmp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= end) tmp[k++] = arr[j++];</span><br><span class="line">    <span class="comment">// 赋给源数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; end - start + <span class="number">1</span>; idx++) &#123;</span><br><span class="line">        arr[idx+start] = tmp[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="算法逻辑-5"><a href="#算法逻辑-5" class="headerlink" title="算法逻辑"></a>算法逻辑</h5><p>用堆维护一个大顶堆或小顶堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue; <span class="comment">// java中的优先队列底层数据结构就是堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(); <span class="comment">// 默认升序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) pq.offer(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) arr[i] = pq.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>上述几个排序算法都是比较排序，还有几种非比较排序算法，主要逻辑就是利用额外数组根据下标存储，缺点是源数组的元素只能是<strong>整数</strong>。本文不做多记录。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>原码、反码、补码</title>
    <url>/2020/05/28/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<p> 之前不了解机器为何要使用补码进行存储，学习之后记录一下。</p>
<a id="more"></a>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>原码就是符号位加上真值的绝对值，即最高位用<code>1</code>表示负数，<code>0</code>表示正数，其余位表示数值。<br>例如8位二进制：</p>
<blockquote>
<p>[+1]原：00000001<br>[-1]原：10000001</p>
</blockquote>
<p>可见8位二进制表示数字的范围为<code>[-127, 127]</code>。</p>
<hr>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>反码的表示形式是：</p>
<ul>
<li>正数的反码是其本身</li>
<li>负数的反码是在其原码的基础上，符号位不变，其余各个位取反</li>
</ul>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反<br>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>如果一个用反码表示的负数，人脑需要将其转成原码才比较好计算。</p>
<hr>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>反码的表示形式是：</p>
<ul>
<li>正数的补码是其本身</li>
<li>负数的补码是在其反码的基础上+1</li>
</ul>
<blockquote>
<p>[+1] = [00000001]原 = [10000001]反 = [00000001]补<br>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>如果一个用补码表示的负数，人脑依然很难直接看出数值。</p>
<hr>
<h3 id="为何要发明反码和补码"><a href="#为何要发明反码和补码" class="headerlink" title="为何要发明反码和补码"></a>为何要发明反码和补码</h3><p>首先，人脑可以很容易地根据最高位分辨出一个数是正数还是负数，但对于计算机来说，肯定要设计得尽量简单，让计算机判断符号位会使计算机的电路设计显得很复杂。于是计算机会将符号位也参与计算。比如对于<code>1-1</code>这个运算，计算机会将运算变成<code>1+(-1)</code>，这时如果用原码进行计算，就会出现问题。</p>
<blockquote>
<p>1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>
</blockquote>
<p>结果并不等于0。所以计算机并不使用原码表示一个数。</p>
<p>因此出现了反码。用反码进行计算。</p>
<blockquote>
<p>1 + (-1) = [00000001]反 + [11111110]反 = [11111111]反 = [10000000]原 = -0</p>
</blockquote>
<p>这时结果为-0，已经能得到正确结果。这时唯一的问题就是0。因为0带符号是没有意义的，而且原码的<code>[10000000]</code>和<code>[00000000]</code>都表示0，这显然不够完美。</p>
<p>于是补码应运而生，它完美的解决了这个问题。</p>
<blockquote>
<p>1 + (-1) = [00000001]补 + [11111111]补 = [00000000]补 = [00000000]原 = 0</p>
</blockquote>
<p>这时0只用一个编码来表示了，而-0则可以用来表示-128。</p>
<blockquote>
<p>(-1) + (-127) = [11111111]补 + [10000001]补 = [10000000]补</p>
</blockquote>
<p>所以在补码运算的结果中<code>[10000000]补</code>就是-128。但由于其实是用以前的-0的补码来表示-128，所以-128并没有反码和原码来表示。<br>这也是为什么对于8位二进制数，原码和反码表示的范围是<code>[-127, 127]</code>，而补码表示的是<code>[-128, 127]</code>。而对于常见的int32也是如此。由于机器是使用补码存储，所以int32表示的范围是<code>[-2^31, 2^31-1]</code>。</p>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(2)</title>
    <url>/2020/05/30/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-2/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(2)</p>
<a id="more"></a>
<h4 id="02-04-分割链表"><a href="#02-04-分割链表" class="headerlink" title="02.04 分割链表"></a>02.04 <a href="https://leetcode-cn.com/problems/partition-list-lcci/" target="_blank" rel="noopener">分割链表</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>双指针，与x比较进行交换。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode small = head, large = head;</span><br><span class="line">        <span class="keyword">while</span> (small != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (small.val &lt; x) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = small.val;</span><br><span class="line">                small.val = large.val;</span><br><span class="line">                large.val = tmp;</span><br><span class="line">                large = large = large.next;</span><br><span class="line">            &#125;</span><br><span class="line">            small = small.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-05-链表求和"><a href="#02-05-链表求和" class="headerlink" title="02.05 链表求和"></a>02.05 <a href="https://leetcode-cn.com/problems/sum-lists-lcci/" target="_blank" rel="noopener">链表求和</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>给定两个用链表表示的整数，每个节点包含一个数位。<br>这些数位是反向存放的，也就是个位排在链表首部。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>双指针从个位逐步累加，边界处理。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="keyword">int</span> tmp = n1 + n2 + carry;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">            l1 = l1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l1.next;</span><br><span class="line">            l2 = l2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l2.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) cur.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>); <span class="comment">// 处理最高位的进位</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-06-回文链表"><a href="#02-06-回文链表" class="headerlink" title="02.06 回文链表"></a>02.06 <a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">回文链表</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>编写一个函数，检查输入的链表是否是回文的。<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>找到中间节点，翻转后半部分链表，再与前半部分进行比较。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="comment">// 找到中间节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode latter = reverse(slow.next); <span class="comment">// 翻转后半部链表</span></span><br><span class="line">        <span class="keyword">while</span> (latter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != latter.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode cur = node, last = <span class="keyword">null</span>, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = last;</span><br><span class="line">            last = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-07-链表相交"><a href="#02-07-链表相交" class="headerlink" title="02.07 链表相交"></a>02.07 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">链表相交</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。<br>如果两个链表没有交点，返回 null 。<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>可以用set存储链表的引用，判断是否有重复。要求O(1)内存就使用两个指针。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA, b = headB;</span><br><span class="line">        <span class="comment">// 都指向交点或者null退出循环</span></span><br><span class="line">        <span class="comment">// 一个链表的指针到末尾就指向另一个链表头</span></span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a == <span class="keyword">null</span> ? headB : a.next;</span><br><span class="line">            b = b == <span class="keyword">null</span> ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-08-环路检测"><a href="#02-08-环路检测" class="headerlink" title="02.08 环路检测"></a>02.08 <a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/" target="_blank" rel="noopener">环路检测</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>给定一个有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。<br>你是否可以不用额外空间解决此题？</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>快慢指针找环的入口。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head.next, fast = head.next.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 遇到空指针说明没有环</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(1)</title>
    <url>/2020/05/30/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-1/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(1)</p>
<a id="more"></a>
<h4 id="01-01-判定字符是否唯一"><a href="#01-01-判定字符是否唯一" class="headerlink" title="01.01 判定字符是否唯一"></a>01.01 <a href="https://leetcode-cn.com/problems/is-unique-lcci/" target="_blank" rel="noopener">判定字符是否唯一</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>用set存储字符出现次数，判断是否有重复。<br>如果字符范围在字母内，可以用int32，利用每一位判断出现次数。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; astr.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = astr.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> ((n &gt;&gt; tmp &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            n ^= (<span class="number">1</span> &lt;&lt; tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="01-05-一次编辑"><a href="#01-05-一次编辑" class="headerlink" title="01.05 一次编辑"></a>01.05 <a href="https://leetcode-cn.com/problems/one-away-lcci/" target="_blank" rel="noopener">一次编辑</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>用双指针以及两个字符串的长短判断修改的次数。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">oneEditAway</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first.equals(second)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> m = first.length(), n = second.length();</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(m - n) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 长度差超过1直接返回false</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n; i++, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.charAt(i) != second.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 修改次数已用完</span></span><br><span class="line">                <span class="comment">// 短的字符串指针不移动</span></span><br><span class="line">                <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="01-07-旋转矩阵"><a href="#01-07-旋转矩阵" class="headerlink" title="01.07 旋转矩阵"></a>01.07 <a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">旋转矩阵</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像顺时针旋转 90 度。<br>不占用额外内存空间能否做到？</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>先按 \ 对角线翻转数组再左右翻转数组，或者先按 / 对角线翻转数组再上下翻转数组。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 按 \ 翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][l];</span><br><span class="line">                matrix[i][l] = matrix[i][r];</span><br><span class="line">                matrix[i][r] = tmp;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-01-移除重复节点"><a href="#02-01-移除重复节点" class="headerlink" title="02.01 移除重复节点"></a>02.01 <a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener">移除重复节点</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>用set存储出现过的节点值，判断。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        set.add(cur.val);</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(cur.next.val)) &#123;</span><br><span class="line">                set.add(cur.next.val);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = cur.next.next; <span class="comment">// set存在当前节点值，删除节点，当前指针不移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="02-02-返回倒数第-k-个节点"><a href="#02-02-返回倒数第-k-个节点" class="headerlink" title="02.02 返回倒数第 k 个节点"></a>02.02 <a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/" target="_blank" rel="noopener">返回倒数第 k 个节点</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>先让一个指针走k步，再双指针一起走。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(3)</title>
    <url>/2020/05/30/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-3/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(3)</p>
<a id="more"></a>
<h4 id="03-04-化栈为队"><a href="#03-04-化栈为队" class="headerlink" title="03.04 化栈为队"></a>03.04 <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/" target="_blank" rel="noopener">化栈为队</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>实现一个MyQueue类，该类用两个栈来实现一个队列。<br>假设所有操作都是有效的（例如，一个空的队列不会调用 pop 或者 peek 操作）。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>一个栈存元素，另一个栈取元素。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1; <span class="comment">// 存元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2; <span class="comment">// 取元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.empty() &amp;&amp; stack2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-02-最小高度树"><a href="#04-02-最小高度树" class="headerlink" title="04.02 最小高度树"></a>04.02 <a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/" target="_blank" rel="noopener">最小高度树</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>二叉搜索树<strong>中序遍历</strong>有序，所以以数组中间元素为根节点，不断二分递归。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(nums[mid]); <span class="comment">// 中间元素为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="comment">// 递归得到左右子树</span></span><br><span class="line">        node.left = buildTree(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        node.right = buildTree(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-04-检查平衡性"><a href="#04-04-检查平衡性" class="headerlink" title="04.04 检查平衡性"></a>04.04 <a href="https://leetcode-cn.com/problems/check-balance-lcci/" target="_blank" rel="noopener">检查平衡性</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p><strong>递归</strong>判断所有节点的两子树的最大高度差。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 递归判断</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(getHeight(root.left) - getHeight(root.right)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取树的最大高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getHeight(node.left), getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-08-首个共同祖先"><a href="#04-08-首个共同祖先" class="headerlink" title="04.08 首个共同祖先"></a>04.08 <a href="https://leetcode-cn.com/problems/first-common-ancestor-lcci/" target="_blank" rel="noopener">首个共同祖先</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。<br>所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p><strong>递归</strong>寻找共同祖先。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root; <span class="comment">// 找到节点</span></span><br><span class="line">        root.left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        root.right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// 如果p、q分别在两子树，首个共同祖先为此节点，否则为某个子节点。</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="keyword">return</span> root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="04-10-检查子树"><a href="#04-10-检查子树" class="headerlink" title="04.10 检查子树"></a>04.10 <a href="https://leetcode-cn.com/problems/check-subtree-lcci/" target="_blank" rel="noopener">检查子树</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。<br>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p><strong>递归</strong>比较子树是否相等。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 节点值相等，则递归检查以此节点为根的子树与t2是否相等。</span></span><br><span class="line">        <span class="keyword">if</span> (t1.val == t2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkSubTree(t1.left, t2.left) &amp;&amp; checkSubTree(t1.right, t2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则遍历t1其他节点</span></span><br><span class="line">        <span class="keyword">return</span> checkSubTree(t1.left, t2) || checkSubTree(t1.right, t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(4)</title>
    <url>/2020/05/31/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-4/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(4)</p>
<a id="more"></a>
<h4 id="04-12-求和路径"><a href="#04-12-求和路径" class="headerlink" title="04.12 求和路径"></a>04.12 <a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/" target="_blank" rel="noopener">求和路径</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>暴力求解，<strong>递归</strong>每一个节点。或者用<strong>前缀和</strong>进行缓存，降低时间复杂度。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力(9ms)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="comment">// 递归每个节点</span></span><br><span class="line">        pathSum(root.left, sum);</span><br><span class="line">        pathSum(root.right, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.val == sum) ans++; <span class="comment">// 找到路径</span></span><br><span class="line">        dfs(node.left, sum - node.val);</span><br><span class="line">        dfs(node.right, sum - node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀和(2ms)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录前缀和(前缀和有可能重复，所以要用map)</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; prefixSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        prefixSum.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        dfs(root, sum, root.val);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum, <span class="keyword">int</span> curSum)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 判断是否找到路径</span></span><br><span class="line">        ans += prefixSum.getOrDefault(curSum - sum, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 添加当前前缀和</span></span><br><span class="line">        prefixSum.put(curSum, prefixSum.getOrDefault(curSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) dfs(node.left, sum, curSum + node.left.val);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) dfs(node.right, sum, curSum + node.right.val);</span><br><span class="line">        <span class="comment">// 回滚</span></span><br><span class="line">        prefixSum.put(curSum, prefixSum.get(curSum) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="05-01-插入"><a href="#05-01-插入" class="headerlink" title="05.01 插入"></a>05.01 <a href="https://leetcode-cn.com/problems/insert-into-bits-lcci/" target="_blank" rel="noopener">插入</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>题目描述得不太好，就是将N的第j位到第i位替换成M，长度不够高位补0。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>先将N的j到i位替换成0，再加上移位后的M即可。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBits</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">        	<span class="comment">// 替换</span></span><br><span class="line">            N -= (<span class="number">1</span> &amp; (N &gt;&gt; k)) == <span class="number">1</span> ? (<span class="number">1</span> &lt;&lt; k) : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        N |= (M &lt;&lt; i); <span class="comment">// 覆盖</span></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="05-02-二进制数转字符串"><a href="#05-02-二进制数转字符串" class="headerlink" title="05.02 二进制数转字符串"></a>05.02 <a href="https://leetcode-cn.com/problems/bianry-number-to-string-lcci/" target="_blank" rel="noopener">二进制数转字符串</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>二进制数转字符串。给定一个介于0和1之间的实数(如0.72)，类型为double，打印它的二进制表达式。如果该数字不在0和1之间，或者无法精确地用32位以内的二进制表示，则打印“ERROR”。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>十进制小数转二进制：<strong>乘2取整，顺序排列</strong>。<br><img src="%E5%8D%81%E8%BF%9B%E5%88%B6%E5%B0%8F%E6%95%B0%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt=""><br><strong>末尾不为5的十进制小数无法精确转换为二进制，因为小数部分永远不可能为0。</strong></p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printBin</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">"0."</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                num *= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(<span class="number">1</span>);</span><br><span class="line">                    num -= <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">// 等于1说明小数部分已为0</span></span><br><span class="line">                    sb.append(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> sb.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行到这里说明此小数无法精确转换成二进制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="05-03-翻转数位"><a href="#05-03-翻转数位" class="headerlink" title="05.03 翻转数位"></a>05.03 <a href="https://leetcode-cn.com/problems/reverse-bits-lcci/" target="_blank" rel="noopener">翻转数位</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>因为只能改变一个0，所以记录先前长度，遇到0时减去即可。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, cur = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">            	<span class="comment">// 减去上次改动0的位置</span></span><br><span class="line">                cur -= pre;</span><br><span class="line">                <span class="comment">// pre记录的是上一次改动0的位置</span></span><br><span class="line">                pre = cur + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur++;</span><br><span class="line">            max = Math.max(max, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="05-07-配对交换"><a href="#05-07-配对交换" class="headerlink" title="05.07 配对交换"></a>05.07 <a href="https://leetcode-cn.com/problems/exchange-lcci/" target="_blank" rel="noopener">配对交换</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。<br>num的范围在[0, 2^30 - 1]之间，不会发生整数溢出。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>循环。或者使用<code>0x55555555</code>和<code>0xaaaaaaaa</code>得到奇偶位进行交换。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为1，奇数位为0）</span></span><br><span class="line">        <span class="comment">// 0x55555555 = 01010101010101010101010101010101 (偶数位为0，奇数位为1）</span></span><br><span class="line">        <span class="comment">// 分别与num位与，可以分别得到num奇偶位的数位。因为要交换，所以分别位移后进行或运算即可。</span></span><br><span class="line">        <span class="keyword">return</span> ((num &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>) | ((num &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(1)</title>
    <url>/2020/06/01/%E5%89%91%E6%8C%87offer-1/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(1)</p>
<a id="more"></a>
<h4 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03 数组中重复的数字"></a>03 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>排序后查找重复数字。<br>哈希表。<br>二分。<br>利用题中条件<strong>所有数字都在 0～n-1 的范围内</strong>，比较下标以及下标对应的数字进行交换。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n)  空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	<span class="comment">// 下标对应的数字不等于下标时</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">            	<span class="comment">// 数字相等说明已找到重复</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[nums[i]];</span><br><span class="line">                <span class="comment">// 这里不能用nums[nums[i]] = tmp，因为上一步nums[i]已被更改。</span></span><br><span class="line">                nums[tmp] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上一段代码更改了源数组。如果要求不能更改，可以使用二分。</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(nlogn)  空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">// 此方法不一定能找出所有重复的数字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = i + ((j - i) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">int</span> cnt = countRange(nums, i, mid);</span><br><span class="line">			<span class="keyword">if</span> (i == j) &#123; <span class="comment">// 只剩一个数字</span></span><br><span class="line">				<span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// i～mid数字在数组中出现次数大于mid-i+1说明此范围有重复</span></span><br><span class="line">			<span class="keyword">if</span> (cnt &gt; (mid - i + <span class="number">1</span>)) j = mid;</span><br><span class="line">			<span class="keyword">else</span> i = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n &gt;= i &amp;&amp; n &lt;= j) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11 旋转数组的最小数字"></a>11 <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>数组相对有序，使用二分查找。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(logn)  空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 中间比右边大，说明此元素属于被旋转的那部分，最小元素一定不在这里。</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[l]) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> r--; <span class="comment">// 相等时无法判断处于哪部分，只能缩小范围去重。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="14-i-剪绳子"><a href="#14-i-剪绳子" class="headerlink" title="14 i.剪绳子"></a>14 <a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">i.剪绳子</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]*k[1]*…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>动态规划或者贪心。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(n^2)  空间复杂度：O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 由于至少剪一次，n=2或3时特殊处理。</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 绳子剩余2或3时，已经至少剪过1次，此时最好的情况是不剪</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>; dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] * dp[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-ii-剪绳子"><a href="#14-ii-剪绳子" class="headerlink" title="14 ii.剪绳子"></a>14 <a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">ii.剪绳子</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>与上题一样。但答案可能会很大，需要取模 1e9+7（1000000007）。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>本题不能用动态规划。因为取模后无法正确比较大小。只能用贪心。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        	<span class="comment">// 有3取3</span></span><br><span class="line">            ans *= <span class="number">3</span>;</span><br><span class="line">            ans %= <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (ans * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16 数值的整数次方"></a>16 <a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">数值的整数次方</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>快速幂。注意边界问题。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// -2147483648直接取绝对值会溢出，需要先转成long。</span></span><br><span class="line">        <span class="keyword">long</span> y = n;</span><br><span class="line">        y = y &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line">        <span class="comment">// 快速幂</span></span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((y &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? res : <span class="number">1</span> / res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(2)</title>
    <url>/2020/06/02/%E5%89%91%E6%8C%87offer-2/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(2)</p>
<a id="more"></a>
<h4 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19 正则表达式匹配"></a>19 <a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">正则表达式匹配</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>动态规划。二维dp数组。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="comment">// 需要判断为空的情况，所以长度+1</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// s为空也可能被p匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">2</span>] &amp;&amp; p.charAt(i-<span class="number">1</span>) == <span class="string">'*'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// s的前i位能否被p的前j位匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                	<span class="comment">// 1.之前元素出现0次，直接移除p两个元素，s不变</span></span><br><span class="line">                	<span class="comment">// 2.之前元素出现1或多次，比较s的i元素与p的j-1元素，</span></span><br><span class="line">                	<span class="comment">//   相等则移除s当前元素，p继续匹配</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] || (check(s, p, i, j - <span class="number">1</span>) &amp;&amp; dp[i][j+<span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">// s的i元素与p的j元素是否相等，相等则分别移除当前元素比较之前元素</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] &amp;&amp; check(s, p, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.charAt(j) == <span class="string">'.'</span> || s.charAt(i) == p.charAt(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29 顺时针打印矩阵"></a>29 <a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">顺时针打印矩阵</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>四个变量分别记录当前上下左右边界的索引，判断结束条件。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">        <span class="comment">// 当前边界索引</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, u = <span class="number">0</span>, d = m - <span class="number">1</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        	<span class="comment">// 右下左上顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                res[idx++] = matrix[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++u &gt; d) <span class="keyword">break</span>; <span class="comment">// 跳出循环条件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = u; i &lt;= d; i++) &#123;</span><br><span class="line">                res[idx++] = matrix[i][r];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--) &#123;</span><br><span class="line">                res[idx++] = matrix[d][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--d &lt; u) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &gt;= u; i--) &#123;</span><br><span class="line">                res[idx++] = matrix[i][l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33 二叉搜索树的后序遍历序列"></a>33 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>数组最后一位为根节点，根据大小找到左子树与右子树，递归判断是否合法。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = postorder.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> check(postorder, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 剩一个元素，递归终止。</span></span><br><span class="line">        <span class="keyword">int</span> idx; <span class="comment">// 左子树索引</span></span><br><span class="line">        <span class="keyword">for</span> (idx = left; idx &lt; right; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[idx] &gt; arr[right]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; right; i++) &#123;</span><br><span class="line">        	<span class="comment">// 如果右子树有值小于根节点的数，则不是二叉搜索树。</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[right]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归判断子树</span></span><br><span class="line">        <span class="keyword">return</span> check(arr, left, idx - <span class="number">1</span>) &amp;&amp; check(arr, idx, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35 复杂链表的复制"></a>35 <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>普通方法只能复制一般的链表，无法复制random指针。<br>可以利用哈希表存储原链表与复制链表，这样就可以根据键值对找到random指针，但要消耗O(n)空间。<br>所以还有一种原地修改的方法。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node cur = head, copy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 1-&gt;2-&gt;3 ----&gt; 1-&gt;1'-&gt;2-&gt;2'-&gt;3-&gt;3'</span></span><br><span class="line">        <span class="comment">// 这样就可以定位random指针的位置</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            copy = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            copy.next = cur.next;</span><br><span class="line">            cur.next = copy;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">// 复制random指针</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        Node ans = head.next, tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 分离原始链表和复制链表，head.next即为复制的链表。</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = tmp.next;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36 二叉搜索树与双向链表"></a>36 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>二叉搜索树<strong>中序遍历</strong>有序。全局变量记录头节点和上一个节点，利用中序遍历将所有节点连在一起，最后将头尾相连即可。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node head = <span class="keyword">null</span>, pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">// 执行完dfs，pre即为尾节点，将头尾相连。</span></span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) dfs(node.left);</span><br><span class="line">        node.left = pre;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.right = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// pre == null，说明当前节点是中序遍历头节点。</span></span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) dfs(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(3)</title>
    <url>/2020/06/05/%E5%89%91%E6%8C%87offer-3/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(3)</p>
<a id="more"></a>
<h4 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38 字符串的排列"></a>38 <a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>输入一个字符串，打印出该字符串中字符的所有排列。<br>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>dfs。因为有重复元素需要剪枝去重。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n!)  // 空间复杂度 O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        dfs(c, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> String[ans.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 到达最后一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> String(arr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">        	<span class="comment">// 如果字符已经存在，跳过这个字符</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(arr[j])) <span class="keyword">continue</span>;</span><br><span class="line">            set.add(arr[j]);</span><br><span class="line">            <span class="comment">// 固定arr[j]在i位置</span></span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">            dfs(arr, i + <span class="number">1</span>, n);</span><br><span class="line">            <span class="comment">// 恢复交换</span></span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42 连续子数组的最大和"></a>42 <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>要求时间复杂度为O(n)。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p><strong>动态规划</strong>。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 初始值为nums[0]，如果数组只有一个数，直接返回。</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	<span class="comment">// dp[i]表示以第i个数结尾的子数组的最大和</span></span><br><span class="line">        	<span class="comment">// 如果之前的最大和加上当前这个数比这个数大，就加上</span></span><br><span class="line">            dp[i] = Math.max(nums[i], dp[i-<span class="number">1</span>] + nums[i]);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="43-1-n整数中1出现的次数"><a href="#43-1-n整数中1出现的次数" class="headerlink" title="43 1~n整数中1出现的次数"></a>43 <a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">1~n整数中1出现的次数</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。<br>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。<br>1 &lt;= n &lt; 2^31</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>暴力。由于n的范围较大，会超时。<br>循环每一位数，统计每一位数上1出现的次数，最后累加即为结果。时间复杂度为O(logn)。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n / i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> high = n / (<span class="number">10</span> * i); <span class="comment">// 高位</span></span><br><span class="line">            <span class="keyword">long</span> cur = n / i % <span class="number">10</span>; <span class="comment">// 当前位</span></span><br><span class="line">            <span class="keyword">long</span> low = n - n / i * i; <span class="comment">// 低位</span></span><br><span class="line">            <span class="comment">// 当前位等于0，出现1的次数只与高位有关。</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += high * i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="comment">// 等于1与高低位都有关</span></span><br><span class="line">                ans += high * i + low + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 其他数也只与高位有关</span></span><br><span class="line">                ans += (high + <span class="number">1</span>) * i;</span><br><span class="line">            &#125;</span><br><span class="line">            i *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44 数字序列中某一位的数字"></a>44 <a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">数字序列中某一位的数字</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。<br>请写一个函数，求任意第n位对应的数字。<br>0 &lt;= n &lt; 2^31</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>转成字符串处理。由于数字范围较大，内存会溢出。<br>找规律，判断数字出现的范围。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 1～9 9位  10～99 90位。100～999 900位。以此类推。</span></span><br><span class="line">        <span class="keyword">long</span> cnt = <span class="number">9</span>, start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; cnt) &#123;</span><br><span class="line">            n -= cnt;</span><br><span class="line">            digit++;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            cnt = start * digit * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断数位在哪个数字中</span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit;</span><br><span class="line">        <span class="comment">// 判断在数字的哪一位</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48 最长不含重复字符的子字符串"></a>48 <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>动态规划。记录当前字符在字符串中上一次出现的下标，与当前长度对比更新最大值。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] lastIdx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 初始化下标为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) lastIdx[i] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = lastIdx[(<span class="keyword">int</span>) s.charAt(i)];</span><br><span class="line">            <span class="comment">// 如果当前字符未出现过或者出现的距离大于当前子串长度，长度+1</span></span><br><span class="line">            <span class="comment">// 否则将当前子串长度设为出现的位置下标之差以保证不含重复字符</span></span><br><span class="line">            <span class="keyword">if</span> (last == -<span class="number">1</span> || i - last &gt; cur) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = i - last;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, cur);</span><br><span class="line">            <span class="comment">// 更新最后出现当前字符的下标</span></span><br><span class="line">            lastIdx[(<span class="keyword">int</span>) s.charAt(i)] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(4)</title>
    <url>/2020/06/06/%E5%89%91%E6%8C%87offer-4/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(4)</p>
<a id="more"></a>
<h4 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49 丑数"></a>49 <a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>三指针。第一个丑数是1，以后的丑数都是基于前面的小丑数分别乘2，3，5构成的。每次添加当前计算出的最小的丑数，更新相应的指针。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">6</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 第一个丑数是1</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx2 = <span class="number">0</span>, idx3 = <span class="number">0</span>, idx5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	<span class="comment">// 计算出当前最小丑数</span></span><br><span class="line">            dp[i] = Math.min(dp[idx2] * <span class="number">2</span>, Math.min(dp[idx3] * <span class="number">3</span>, dp[idx5] * <span class="number">5</span>));</span><br><span class="line">            <span class="comment">// 更新指针。由于可能出现相等的情况，这时多个指针都要更新，所以不用else if。</span></span><br><span class="line">            <span class="keyword">if</span> (dp[idx2] * <span class="number">2</span> == dp[i]) idx2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[idx3] * <span class="number">3</span> == dp[i]) idx3++;</span><br><span class="line">            <span class="keyword">if</span> (dp[idx5] * <span class="number">5</span> == dp[i]) idx5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51 数组中的逆序对"></a>51 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>归并排序。每次归并时统计有多少逆序对。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        mergeSort(nums, start, mid);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// 归并并找逆序对</span></span><br><span class="line">        merge(nums, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = start, r = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= nums[r]) &#123;</span><br><span class="line">                tmp[k++] = nums[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 如果左半边的数比右边大，存在逆序</span></span><br><span class="line">            	<span class="comment">// 2, 3, 4, 5      1, 3, 6, 7</span></span><br><span class="line">            	<span class="comment">// 2比1大，说明2到mid的数全大于1，存在4个逆序对</span></span><br><span class="line">                cnt += mid - l + <span class="number">1</span>;</span><br><span class="line">                tmp[k++] = nums[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">            tmp[k++] = nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= end) &#123;</span><br><span class="line">            tmp[k++] = nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 赋给源数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            nums[i] = tmp[i - start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53 在排序数组中查找数字"></a>53 <a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">在排序数组中查找数字</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>统计一个数字在排序数组中出现的次数。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>有序数组，使用两次二分法分别找出数字的左右边界。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左边界</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 小的话target左边界只可能在另一边</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 大的话target左边界只可能在左边</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 相等的话左边界可能是这个或者在左边</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右下标即为左边界</span></span><br><span class="line">        <span class="keyword">int</span> left = r;</span><br><span class="line">        l = <span class="number">0</span>; r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右边界</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左下标为右边界</span></span><br><span class="line">        <span class="keyword">return</span> l - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="56-数组中数字出现的次数-i"><a href="#56-数组中数字出现的次数-i" class="headerlink" title="56 数组中数字出现的次数 i"></a>56 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">数组中数字出现的次数 i</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。<br>要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>循环数组取异或，结果为这两个数字的异或。判断这个数最低位的1的位置，对数组中的元素根据此位是否为1划分为两部分。<br>再次异或即可得到其中一个数，由<code>a ^ b ^ a = b</code>得到另一个数。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        	<span class="comment">// n最终为两个出现了一次的数的异或</span></span><br><span class="line">            n ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找出最低位的1</span></span><br><span class="line">        <span class="keyword">while</span> ((n &amp; (<span class="number">1</span> &lt;&lt; idx)) == <span class="number">0</span>) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 筛选idx位为0的数，得到其中一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; idx)) == <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再异或得到另一个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;a, n ^ a&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="56-数组中数字出现的次数-ii"><a href="#56-数组中数字出现的次数-ii" class="headerlink" title="56 数组中数字出现的次数 ii"></a>56 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">数组中数字出现的次数 ii</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>如果一个数出现了三次，它的二进制表示的每一位也出现三次，即每一位的和可以被3整除。<br>将所有数字的每一位相加，最后如果某一位能被3整除，说明出现一次的数字的这一位是0，否则是1。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">// 计算每一位的和，对3取模。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                arr[i] += (n &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">                arr[i] %= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 得到出现一次的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            ans += arr[i] == <span class="number">1</span> ? <span class="number">1</span> &lt;&lt; i : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(5)</title>
    <url>/2020/06/07/%E5%89%91%E6%8C%87offer-5/</url>
    <content><![CDATA[<p>记录Leetcode剑指0ffer面试题(5)</p>
<a id="more"></a>
<h4 id="59-i-滑动窗口的最大值"><a href="#59-i-滑动窗口的最大值" class="headerlink" title="59-i 滑动窗口的最大值"></a>59-i <a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">滑动窗口的最大值</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>维护一个队列，首元素为当前窗口的最大值。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化前k位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        	<span class="comment">// 当前元素和队列里的元素进行比较，大的话就删除队列里的元素</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) deque.pollLast();</span><br><span class="line">            deque.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = deque.peek();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">        	<span class="comment">// 如果队列里的最大元素等于nums[i-k]，说明此最大值已不再当前窗口</span></span><br><span class="line">            <span class="keyword">if</span> (deque.peek() == nums[i-k]) deque.poll();</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) deque.pollLast();</span><br><span class="line">            deque.offer(nums[i]);</span><br><span class="line">            <span class="comment">// 当前窗口的最大值为队列首元素</span></span><br><span class="line">            ans[i-k+<span class="number">1</span>] = deque.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60 n个骰子的点数"></a>60 <a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">n个骰子的点数</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。<br>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>动态规划。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] twoSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    	<span class="comment">// dp[i][j]表示扔了i个骰子后和为j的排列情况总数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">6</span>*n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 结果数组长度为6n-n+1</span></span><br><span class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>*n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 第一个骰子，总和只能为1～6，每种出现一次。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// n个骰子，每个1～6点数，总共6^n种排列情况。</span></span><br><span class="line">        <span class="keyword">double</span> all = Math.pow(<span class="number">6</span>, n);</span><br><span class="line">        <span class="comment">// n个骰子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        	<span class="comment">// i个骰子可能出现的点数总和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= <span class="number">6</span> * i; j++) &#123;</span><br><span class="line">            	<span class="comment">// 每个骰子1～6点数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span>; k++) &#123;</span><br><span class="line">                	<span class="comment">// i个骰子总和为j的情况总数等于</span></span><br><span class="line">                	<span class="comment">// i-1个骰子总和为j-k的情况总数，k为当前着个骰子扔的点数。</span></span><br><span class="line">                    dp[i][j] += j &gt;= k ? dp[i-<span class="number">1</span>][j-k] : <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// i == n，说明已经扔到了最后一个骰子，可以开始添加结果。</span></span><br><span class="line">                    <span class="keyword">if</span> (i == n) ans[j-i] = dp[i][j] / all;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 <a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">不用加减乘除做加法</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。<br>a, b 均可能是负数或 0，结果不会溢出 32 位整数。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>既然不能用加减乘除，那就用位运算。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123; <span class="comment">// 进位为0退出</span></span><br><span class="line">        	<span class="comment">// 非进位和(相当于异或)</span></span><br><span class="line">            <span class="keyword">int</span> sum = a ^ b;</span><br><span class="line">            <span class="comment">// 进位和(位与再左移一位，这样当某一位上两个数都是1时就会进位)</span></span><br><span class="line">            <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(5)</title>
    <url>/2020/06/09/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-5/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(5)</p>
<a id="more"></a>
<h4 id="08-05-递归乘法"><a href="#08-05-递归乘法" class="headerlink" title="08.05 递归乘法"></a>08.05 <a href="https://leetcode-cn.com/problems/recursive-mulitply-lcci/" target="_blank" rel="noopener">递归乘法</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>可以利用加法，效率偏低。<br>还可以借助快速幂的思想，降低循环次数。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 较小值进行循环，提高效率</span></span><br><span class="line">        <span class="keyword">return</span> dfs(Math.max(A, B), Math.min(A, B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="comment">// 20 * 6 == 40 * 3</span></span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> dfs(a &lt;&lt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 20 * 3 == 20 + 40 * 1</span></span><br><span class="line">        <span class="keyword">return</span> a + (dfs(a &lt;&lt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="08-11-硬币"><a href="#08-11-硬币" class="headerlink" title="08.11 硬币"></a>08.11 <a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">硬币</a></h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>完全背包问题。动态规划。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">// dp[i]表示i分有几种表示方法</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 0分有一种表示法</span></span><br><span class="line">        <span class="comment">// 每种硬币都可以选无数次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 大于当前硬币数额的分数才可以选这个硬币</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="comment">// 之前选的种类数加上这一步选的</span></span><br><span class="line">                dp[i] = (dp[i] + dp[i-coin]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="08-12-八皇后"><a href="#08-12-八皇后" class="headerlink" title="08.12 八皇后"></a>08.12 <a href="https://leetcode-cn.com/problems/eight-queens-lcci/" target="_blank" rel="noopener">八皇后</a></h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>dfs。遍历所有情况，判断在不在同一对角线剪枝。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; pie = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 对于/对角线，在同一对角线上i+j相等。</span></span><br><span class="line">    Set&lt;Integer&gt; na = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 对于\对角线，在同一对角线上i-j相等。</span></span><br><span class="line">    Set&lt;Integer&gt; col = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 当前列是否出现过Q</span></span><br><span class="line">    List&lt;String&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 一行一行遍历</span></span><br><span class="line">        dfs(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历完了最后一行，说明这种摆法可行</span></span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历第i行每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col.contains(j) || pie.contains(i + j) || na.contains(i - j)) <span class="keyword">continue</span>;</span><br><span class="line">            col.add(j);</span><br><span class="line">            pie.add(i + j);</span><br><span class="line">            na.add(i - j);</span><br><span class="line">            cur.add(generate(j, n)); <span class="comment">// 生成字符串</span></span><br><span class="line">            dfs(i + <span class="number">1</span>, n); <span class="comment">// 搜索下一行</span></span><br><span class="line">            <span class="comment">// 撤回这一列的选择</span></span><br><span class="line">            col.remove(j);</span><br><span class="line">            pie.remove(i + j);</span><br><span class="line">            na.remove(i - j);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generate</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i) sb.append(<span class="string">"Q"</span>);</span><br><span class="line">            <span class="keyword">else</span> sb.append(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="08-13-堆箱子"><a href="#08-13-堆箱子" class="headerlink" title="08.13 堆箱子"></a>08.13 <a href="https://leetcode-cn.com/problems/pile-box-lcci/" target="_blank" rel="noopener">堆箱子</a></h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。<br>输入使用数组[wi, di, hi]表示每个箱子。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>按某一维排序，转换成最长递增子序列问题。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pileBox</span><span class="params">(<span class="keyword">int</span>[][] box)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = box.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按宽排序</span></span><br><span class="line">        Arrays.sort(box, (x, y) -&gt; x[<span class="number">0</span>] - y[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// dp[i]表示第i个箱子在最底下时最大的箱子高度总和</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 最低高度就是只有第i个这一个箱子</span></span><br><span class="line">            dp[i] = box[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (box[i][<span class="number">0</span>] &gt; box[j][<span class="number">0</span>] &amp;&amp; box[i][<span class="number">1</span>] &gt; box[j][<span class="number">1</span>] &amp;&amp; box[i][<span class="number">2</span>] &gt; box[j][<span class="number">2</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 第i个箱子高度+第j个箱子在最底的最高高度与当前相比</span></span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + box[i][<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每一步都需要比较</span></span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="10-05-稀疏数组搜索"><a href="#10-05-稀疏数组搜索" class="headerlink" title="10.05 稀疏数组搜索"></a>10.05 <a href="https://leetcode-cn.com/problems/sparse-array-search-lcci/" target="_blank" rel="noopener">稀疏数组搜索</a></h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>二分查找。遇到空字符串特殊处理。</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findString</span><span class="params">(String[] words, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>), tmp = mid;</span><br><span class="line">            <span class="comment">// 如果words[mid]是空串，一直循环直到右边第一个非空串。</span></span><br><span class="line">            <span class="keyword">while</span> (words[mid].equals(<span class="string">""</span>) &amp;&amp; mid &lt; r) mid++;</span><br><span class="line">            <span class="comment">// 如果此时还是空串，说明从mid到r都是空串</span></span><br><span class="line">            <span class="keyword">if</span> (words[mid].equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="comment">// 将r直接变成mid-1</span></span><br><span class="line">                r = tmp - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 二分模板</span></span><br><span class="line">            <span class="keyword">int</span> cmp = words[mid].compareTo(s);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode面试题(6)</title>
    <url>/2020/06/18/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-6/</url>
    <content><![CDATA[<p>记录Leetcode一些面试题(6)</p>
<a id="more"></a>
<h4 id="16-05-阶乘尾数"><a href="#16-05-阶乘尾数" class="headerlink" title="16.05 阶乘尾数"></a>16.05 <a href="https://leetcode-cn.com/problems/factorial-zeros-lcci/" target="_blank" rel="noopener">阶乘尾数</a></h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>设计一个算法，算出 n 阶乘有多少个尾随零。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>0是由<code>*10</code>得到的，而10是由<code>2*5</code>得到的。<br>2的个数比5多，所以计算5的个数。每隔5个数就会出现一个5，隔25出现两个5，以此类推。<br>count = n / 5 + n / 5 / 5 + n / 5 / 5 / 5 + …</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            ans += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>/2020/06/20/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行<strong>校验、转换解析和初始化</strong>，最<br>终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
<a id="more"></a>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。<br>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有:<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_n_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。<br>例如以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行后，只会输出”SuperClass init!”，而不会输出”SubClass init!”。<br>因为对于静态字段，只有直接定义这个字段的类才会被初始化。所以对于上述代码子类不会被初始化。</p>
<p>再如，对上述<code>SuperClass</code>类，如果有以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后依然没有输出”SuperClass init!”。说明通过数组定义来引用类，不会触发类的初始化。</p>
<p>还有一种是调用类的常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量在编译阶段会存入调用类的<strong>常量池</strong>中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。<br>而接口的加载过程与类加载过程稍有不同。接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器，用于初始化接口中所定义的成员变量。<br>一个接口在初始化时，并不要求父接口都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>
<hr>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><ol>
<li><strong>加载</strong><br>在加载阶段，Java虚拟机需要完成以下三件事情：<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
</li>
<li><strong>验证</strong><br>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。<br>验证阶段大致上会完成下面四个阶段的检验动作：<strong>文件格式验证、元数据验证、字节码验证和符号引用验证。</strong><ul>
<li>文件格式验证。主要验证字节流是否符合Class文件格式的规范。比如魔数开头、版本号、常量类型等等问题。</li>
<li>元数据验证。对字节码描述的信息进行语义分析。比如一个类是否有父类、是不是抽象类等等。</li>
<li>字节码验证。主要通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。比如保证类中的方法体在运行时不会危害虚拟机。</li>
<li>符号引用验证。发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</li>
</ul>
</li>
<li><strong>准备</strong><br>准备阶段是正式为类中定义的变量（即<strong>静态变量</strong>，被static修饰的变量）分配内存并设置类变量初始值的阶段。<br>也就是说，<strong>实例变量</strong>在这个阶段是不会被初始化的。例如：<blockquote>
<p>public static int value = 123;<br>public int value = 123;</p>
</blockquote>
</li>
</ol>
<p>对于以上两行代码，只有第一行会执行并初始化值为0。赋值为123要等到类的初始化阶段才会执行。<br>然而也有特殊情况，比如，如果上述<code>value</code>字段被<code>final</code>修饰，那么在这一阶段将会被直接赋值为123。<br>4. <strong>解析</strong><br>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。JVM针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类引用进行解析。<br>5. <strong>初始化</strong><br>到了这个阶段，Java虚拟机才真正开始执行类中编写的Java代码。在这个阶段，JVM会对类进行初始化。具体场景在前面<strong>类加载的时机</strong>已经描述。<br>6. <strong>使用</strong><br>JVM完成初始化后，便从入口方法开始执行代码。<br>7. <strong>卸载</strong><br>执行完程序代码后，JVM开始销毁创建的Class对象，最后JVM也退出内存。</p>
<hr>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandPa</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"grandpa代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"grandpa静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrandPa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"grandpa构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandPa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"father静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"father代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"son静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，输出是</p>
<blockquote>
<p>grandpa静态代码块<br>  father静态代码块<br>  30</p>
</blockquote>
<p>首先程序找到main方法，程序输出Son类的age类变量，但是由于Son类并没有直接定义这个变量，于是往父类找，触发了Father类初始化。<br>接着根据<strong>类加载的时机</strong>第3条<strong>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</strong>所以又会触发GrandPa类的初始化。<br>最后再输出Father类中age的值30。</p>
<p>再看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Test静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Test代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test构造器"</span>);</span><br><span class="line">        System.out.println(<span class="string">"age: "</span> + age + <span class="string">" weight: "</span> + weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> weight = <span class="number">120</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码输出是</p>
<blockquote>
<p>Test代码块<br>  Test构造器<br>  age: 20 weight: 0<br>  Test静态代码块<br>  Test静态方法</p>
</blockquote>
<p>之前那个例子，main方法所在的类没有多余的代码，所以忽略了类的初始化。这个例子就不同了。<br>首先在准备阶段，会为类变量分配内存，初始化值。<code>test</code>实例变量被初始化为null，<code>weight</code>类变量初始化为0。<br>接着进入初始化阶段，首先初始化类构造器，也就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Test静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> weight = <span class="number">120</span>;</span><br></pre></td></tr></table></figure>
<p>首先执行第一句，触发了类的实例化。于是执行对象构造器，也就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"Test代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Test构造器"</span>);</span><br><span class="line">    System.out.println(<span class="string">"age: "</span> + age + <span class="string">" weight: "</span> + weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>对于以上代码，JVM先初始化代码块，然后初始化变量，最后是构造器。所以先打印了<code>Test代码块</code>，为<code>age</code>赋值20，然后打印<code>Test构造器</code>。<br>接着，打印<code>age: 20 weight: 0</code>，因为<code>age</code>已被赋值，但是<code>weight</code>目前只在准备阶段被赋了0。<br>执行完对象构造器，接着执行类构造器第二句，打印<code>Test静态代码块</code>，然后初始化<code>weight</code>为120。<br>此时已完成类的初始化，开始执行main方法，执行run方法输出<code>Test静态方法</code>。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java中的静态变量和静态代码块在类加载的时候就会执行，执行顺序与代码书写顺序一致。然后执行对象构造器，构造函数最后执行，其余按书写顺序。如果子类继承了父类，则会先进行父类的初始化。</p>
<hr>
<p>参见《深入理解 java 虚拟机》。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载器</title>
    <url>/2020/06/22/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
